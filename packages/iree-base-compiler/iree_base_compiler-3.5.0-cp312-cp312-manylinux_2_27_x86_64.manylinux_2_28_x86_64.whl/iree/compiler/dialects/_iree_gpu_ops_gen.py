
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_result_or_op_results as _get_op_result_or_op_results,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir

import builtins
from typing import Sequence as _Sequence, Union as _Union


@_ods_cext.register_dialect
class _Dialect(_ods_ir.Dialect):
  DIALECT_NAMESPACE = "iree_gpu"

@_ods_cext.register_operation(_Dialect)
class BarrierRegionOp(_ods_ir.OpView):
  OPERATION_NAME = "iree_gpu.barrier_region"

  _ODS_REGIONS = (1, True)

  def __init__(self, results_, inputs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def results_(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self):
    return self.regions[0]

def barrier_region(results_, inputs, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(BarrierRegionOp(results_=results_, inputs=inputs, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class BufferResourceCastOp(_ods_ir.OpView):
  OPERATION_NAME = "iree_gpu.buffer_resource_cast"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, input, *, cache_swizzle_stride=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(input)
    if cache_swizzle_stride is not None: operands.append(cache_swizzle_stride)
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def input(self):
    return self.operation.operands[0]

  @builtins.property
  def cache_swizzle_stride(self):
    return None if len(self.operation.operands) < 2 else self.operation.operands[1]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def buffer_resource_cast(result, input, *, cache_swizzle_stride=None, loc=None, ip=None) -> _ods_ir.Value:
  return BufferResourceCastOp(result=result, input=input, cache_swizzle_stride=cache_swizzle_stride, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class GlobalLoadDMAOp(_ods_ir.OpView):
  OPERATION_NAME = "iree_gpu.global_load_dma"

  _ODS_REGIONS = (0, True)

  def __init__(self, source, sourceIndices, target, targetIndices, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(source)
    operands.extend(_get_op_results_or_values(sourceIndices))
    operands.append(target)
    operands.extend(_get_op_results_or_values(targetIndices))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def source(self):
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 2, 2, 0, 0)
    return self.operation.operands[start]

  @builtins.property
  def sourceIndices(self):
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 2, 2, 1, 0)
    return self.operation.operands[start:start + elements_per_group]

  @builtins.property
  def target(self):
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 2, 2, 1, 1)
    return self.operation.operands[start]

  @builtins.property
  def targetIndices(self):
    start, elements_per_group = _ods_equally_sized_accessor(self.operation.operands, 2, 2, 2, 1)
    return self.operation.operands[start:start + elements_per_group]

def global_load_dma(source, source_indices, target, target_indices, *, loc=None, ip=None) -> _ods_ir.Operation:
  return GlobalLoadDMAOp(source=source, sourceIndices=source_indices, target=target, targetIndices=target_indices, loc=loc, ip=ip)

@_ods_cext.register_operation(_Dialect)
class MultiMmaOp(_ods_ir.OpView):
  OPERATION_NAME = "iree_gpu.multi_mma"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, lhs, rhs, acc, indexing_maps, iterator_types, kind, *, lhs_permutation=None, rhs_permutation=None, acc_permutation=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(lhs)
    operands.append(rhs)
    operands.append(acc)
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["indexing_maps"] = (indexing_maps if (
    isinstance(indexing_maps, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('ArrayAttr')) else
      _ods_ir.AttrBuilder.get('ArrayAttr')(indexing_maps, context=_ods_context))
    attributes["iterator_types"] = (iterator_types if (
    isinstance(iterator_types, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('IREEGPU_IteratorTypeArrayAttr')) else
      _ods_ir.AttrBuilder.get('IREEGPU_IteratorTypeArrayAttr')(iterator_types, context=_ods_context))
    attributes["kind"] = (kind if (
    isinstance(kind, _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('IREEGPU_AnyMmaAttr')) else
      _ods_ir.AttrBuilder.get('IREEGPU_AnyMmaAttr')(kind, context=_ods_context))
    if lhs_permutation is not None: attributes["lhs_permutation"] = (lhs_permutation if (
        isinstance(lhs_permutation, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(lhs_permutation, context=_ods_context))
    if rhs_permutation is not None: attributes["rhs_permutation"] = (rhs_permutation if (
        isinstance(rhs_permutation, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(rhs_permutation, context=_ods_context))
    if acc_permutation is not None: attributes["acc_permutation"] = (acc_permutation if (
        isinstance(acc_permutation, _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(acc_permutation, context=_ods_context))
    results.append(result)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def lhs(self):
    return self.operation.operands[0]

  @builtins.property
  def rhs(self):
    return self.operation.operands[1]

  @builtins.property
  def acc(self):
    return self.operation.operands[2]

  @builtins.property
  def indexing_maps(self):
    return self.operation.attributes["indexing_maps"]

  @indexing_maps.setter
  def indexing_maps(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["indexing_maps"] = value

  @builtins.property
  def iterator_types(self):
    return self.operation.attributes["iterator_types"]

  @iterator_types.setter
  def iterator_types(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["iterator_types"] = value

  @builtins.property
  def kind(self):
    return self.operation.attributes["kind"]

  @kind.setter
  def kind(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["kind"] = value

  @builtins.property
  def lhs_permutation(self):
    if "lhs_permutation" not in self.operation.attributes:
      return None
    return self.operation.attributes["lhs_permutation"]

  @lhs_permutation.setter
  def lhs_permutation(self, value):
    if value is not None:
      self.operation.attributes["lhs_permutation"] = value
    elif "lhs_permutation" in self.operation.attributes:
      del self.operation.attributes["lhs_permutation"]

  @lhs_permutation.deleter
  def lhs_permutation(self):
    del self.operation.attributes["lhs_permutation"]

  @builtins.property
  def rhs_permutation(self):
    if "rhs_permutation" not in self.operation.attributes:
      return None
    return self.operation.attributes["rhs_permutation"]

  @rhs_permutation.setter
  def rhs_permutation(self, value):
    if value is not None:
      self.operation.attributes["rhs_permutation"] = value
    elif "rhs_permutation" in self.operation.attributes:
      del self.operation.attributes["rhs_permutation"]

  @rhs_permutation.deleter
  def rhs_permutation(self):
    del self.operation.attributes["rhs_permutation"]

  @builtins.property
  def acc_permutation(self):
    if "acc_permutation" not in self.operation.attributes:
      return None
    return self.operation.attributes["acc_permutation"]

  @acc_permutation.setter
  def acc_permutation(self, value):
    if value is not None:
      self.operation.attributes["acc_permutation"] = value
    elif "acc_permutation" in self.operation.attributes:
      del self.operation.attributes["acc_permutation"]

  @acc_permutation.deleter
  def acc_permutation(self):
    del self.operation.attributes["acc_permutation"]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def multi_mma(result, lhs, rhs, acc, indexing_maps, iterator_types, kind, *, lhs_permutation=None, rhs_permutation=None, acc_permutation=None, loc=None, ip=None) -> _ods_ir.Value:
  return MultiMmaOp(result=result, lhs=lhs, rhs=rhs, acc=acc, indexing_maps=indexing_maps, iterator_types=iterator_types, kind=kind, lhs_permutation=lhs_permutation, rhs_permutation=rhs_permutation, acc_permutation=acc_permutation, loc=loc, ip=ip).result

@_ods_cext.register_operation(_Dialect)
class ValueBarrierOp(_ods_ir.OpView):
  OPERATION_NAME = "iree_gpu.value_barrier"

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, inputs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def results_(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def value_barrier(results_, inputs, *, loc=None, ip=None) -> _ods_ir.Value:
  return _get_op_result_or_op_results(ValueBarrierOp(results_=results_, inputs=inputs, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class YieldOp(_ods_ir.OpView):
  OPERATION_NAME = "iree_gpu.yield"

  _ODS_REGIONS = (0, True)

  def __init__(self, values, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(values))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.OPERATION_NAME, self._ODS_REGIONS, self._ODS_OPERAND_SEGMENTS, self._ODS_RESULT_SEGMENTS, attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip)

  @builtins.property
  def values(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

def yield_(values, *, loc=None, ip=None) -> _ods_ir.Operation:
  return YieldOp(values=values, loc=loc, ip=ip)
