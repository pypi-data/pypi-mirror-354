# TestFoundry Architecture

## System Overview

TestFoundry follows a layered architecture that separates concerns and enables extensibility:

```
┌─────────────────────────────────────────────────────────────────┐
│                        Application Layer                         │
│  (FraiseQL Types, GraphQL Mutations, Business Logic)           │
└─────────────────────────┬───────────────────────────────────────┘
                          │
┌─────────────────────────▼───────────────────────────────────────┐
│                     TestFoundry Core                             │
│  ┌─────────────────┐ ┌──────────────┐ ┌───────────────────┐   │
│  │ Metadata Tables │ │  Generators  │ │ Random Functions  │   │
│  └─────────────────┘ └──────────────┘ └───────────────────┘   │
└─────────────────────────┬───────────────────────────────────────┘
                          │
┌─────────────────────────▼───────────────────────────────────────┐
│                    PostgreSQL Database                           │
│  (Tables, Views, Functions, Constraints, pgTAP)                │
└─────────────────────────────────────────────────────────────────┘
```

## Core Components

### 1. Metadata Tables

#### `testfoundry_tb_input_field_mapping`

Describes how to generate each field within an input type:

```sql
CREATE TABLE testfoundry_tb_input_field_mapping (
    id INTEGER GENERATED BY DEFAULT AS IDENTITY,
    pk_input_field UUID DEFAULT gen_random_uuid() NOT NULL,
    input_type TEXT NOT NULL,              -- e.g., 'user_input'
    field_name TEXT NOT NULL,              -- e.g., 'email'
    generator_type TEXT NOT NULL,          -- 'random', 'resolve_fk', 'nested'
    fk_mapping_key TEXT,                   -- References FK mapping
    fk_dependency_fields TEXT[],           -- Dependencies for FK resolution
    nested_type TEXT,                      -- For nested composite types
    random_function TEXT,                  -- Custom random generator
    required BOOLEAN DEFAULT TRUE,
    generator_group TEXT,                  -- Group name for related fields
    group_leader BOOLEAN DEFAULT FALSE,    -- Is this the group leader?
    group_dependency_fields TEXT[],        -- Fields generated by group leader
    PRIMARY KEY (input_type, field_name)
);
```

#### `testfoundry_tb_fk_mapping`

Defines how to resolve foreign key relationships:

```sql
CREATE TABLE testfoundry_tb_fk_mapping (
    input_type TEXT PRIMARY KEY,           -- Logical name (e.g., 'user_id')
    from_expression TEXT NOT NULL,         -- SQL FROM clause with JOINs
    select_field TEXT NOT NULL,            -- Field to SELECT
    random_select_expression TEXT,         -- Custom SELECT expression
    random_pk_field TEXT,                  -- PK field name
    random_value_field TEXT,               -- Display value field
    random_select_where TEXT,              -- WHERE conditions
    dependency_fields TEXT[],              -- Required input fields
    dependency_field_mapping JSONB,        -- Map input fields to DB fields
    dependency_field_types TEXT[]          -- Field types for casting
);
```

#### `testfoundry_tb_entity_dependents`

Tracks entity relationships for cascade testing:

```sql
CREATE TABLE testfoundry_tb_entity_dependents (
    entity_name TEXT NOT NULL,
    dependent_entity_name TEXT NOT NULL,
    dependency_type TEXT,                  -- 'CASCADE', 'RESTRICT', etc.
    parent_pk_fields TEXT[],
    parent_view TEXT,
    child_fk_fields TEXT[],
    child_view TEXT,
    deleted_indicator TEXT,
    deleted_value TEXT,
    archive_timestamp_field TEXT
);
```

### 2. Core Functions

#### Entity Analysis

- **`testfoundry_get_entity_structure(entity_name)`**: Analyzes entity metadata
- **`testfoundry_list_input_fields(entity_name)`**: Lists fields with generation info
- **`testfoundry_infer_dependency_field_type()`**: Infers field types from schema

#### Random Data Generation

- **`testfoundry_generate_random_input(input_type, debug_mode)`**: Main generator
- **`testfoundry_random_value(field_type)`**: Type-specific random values
- **`testfoundry_random_value_from_mapping(mapping_key, args)`**: FK resolution
- **`testfoundry_random_entity_generator(entity, filters)`**: Entity-specific generation

#### Test Generation

- **`testfoundry_generate_happy_create(entity)`**: Happy path tests
- **`testfoundry_generate_duplicate_create(entity)`**: Unique constraint tests
- **`testfoundry_generate_fk_violation_create(entity)`**: FK violation tests
- **`testfoundry_generate_soft_delete(entity)`**: Soft delete tests

### 3. The Group Leader Pattern

The group leader pattern is TestFoundry's key innovation for maintaining data consistency:

```
┌──────────────────┐
│  Group Leader    │ ──── Executes FK Query ────▶ ┌─────────────────┐
│  (country)       │                               │ Database Record │
└──────────────────┘                               │ ┌─────────────┐ │
         │                                         │ │ Country: FR │ │
         │                                         │ │ Postal: 75001│ │
         ▼                                         │ │ City: PAR   │ │
┌──────────────────┐                               │ └─────────────┘ │
│ Dependent Fields │ ◀──── Returns All Fields ─── └─────────────────┘
│ - postal_code    │
│ - city_code      │
└──────────────────┘
```

Benefits:
- **Atomic Generation**: All related fields from one query
- **Consistency**: No mismatched data combinations
- **Performance**: Single query instead of multiple
- **Simplicity**: Declarative configuration

## Data Flow

### 1. Test Generation Flow

```
User Request
     │
     ▼
Parse Entity Metadata ──────▶ Read testfoundry_tb_input_field_mapping
     │
     ▼
Generate Random Input ──────▶ Process each field based on generator_type
     │
     ▼
Resolve Foreign Keys ───────▶ Query testfoundry_tb_fk_mapping
     │
     ▼
Apply Group Leaders ────────▶ Generate related fields together
     │
     ▼
Build Test Function ────────▶ Create pgTAP test with generated data
     │
     ▼
Return SQL Test
```

### 2. Field Generation Decision Tree

```
Field to Generate
     │
     ├─ generator_type = 'random'
     │   └─▶ Use random_function or testfoundry_random_value()
     │
     ├─ generator_type = 'resolve_fk'
     │   ├─ Check dependencies satisfied
     │   ├─ Query FK mapping
     │   └─▶ Return resolved value
     │
     └─ generator_type = 'nested'
         └─▶ Recursively generate nested type
```

## Extension Points

### 1. Custom Random Functions

Add domain-specific generators:

```sql
CREATE FUNCTION testfoundry_random_phone_number()
RETURNS TEXT AS $$
BEGIN
    RETURN '+1-' ||
           LPAD((RANDOM() * 999)::INT::TEXT, 3, '0') || '-' ||
           LPAD((RANDOM() * 999)::INT::TEXT, 3, '0') || '-' ||
           LPAD((RANDOM() * 9999)::INT::TEXT, 4, '0');
END;
$$ LANGUAGE plpgsql;
```

### 2. Custom Test Scenarios

Define manual test scenarios:

```sql
INSERT INTO test_manual_scenarios
(entity_name, scenario_type, input_json, expected_result)
VALUES
('users', 'edge_case', '{"email": "test@example.com", "name": null}', 'error');
```

### 3. Custom Generators

Extend test generation for specific patterns:

```sql
CREATE FUNCTION testfoundry_generate_custom_test(entity_name TEXT)
RETURNS TEXT AS $$
BEGIN
    -- Custom test generation logic
END;
$$ LANGUAGE plpgsql;
```

## Performance Considerations

### 1. Metadata Caching

TestFoundry caches metadata queries within a session to avoid repeated lookups.

### 2. Batch Generation

Generate multiple test records efficiently:

```sql
SELECT testfoundry_generate_random_input('user_input', false)
FROM generate_series(1, 100);
```

### 3. Index Optimization

Key indexes for performance:

```sql
CREATE INDEX idx_field_mapping_input_type
ON testfoundry_tb_input_field_mapping(input_type);

CREATE INDEX idx_fk_mapping_input_type
ON testfoundry_tb_fk_mapping(input_type);
```

## Security Model

### 1. Schema Isolation

TestFoundry operates in its own schema:
- Prevents namespace pollution
- Easy permission management
- Simple uninstallation

### 2. Execution Context

Tests run with the permissions of the executing user:
- Respects database RLS policies
- Tests actual permission boundaries
- No privilege escalation

### 3. Data Safety

TestFoundry never modifies application data:
- Read-only analysis of schema
- Generated tests use transactions
- Rollback-safe test execution

## Integration Architecture

### With FraiseQL

```
FraiseQL Type System
     │
     ├─▶ @fraise_type ────────┐
     │                        │
     ├─▶ @fraise_input ───────┤
     │                        ▼
     │              TestFoundry Analyzer
     │                        │
     │                        ▼
     │              Metadata Population
     │                        │
     └─▶ PostgreSQL ◀─────────┘
         Functions
```

### With pgTAP

```
TestFoundry Generators
     │
     ▼
pgTAP Test Functions ──▶ BEGIN;
     │                    SELECT plan(n);
     │                    -- Test assertions
     │                    SELECT * FROM finish();
     │                   ROLLBACK;
     │
     ▼
Test Results
```

## Best Practices

1. **Metadata First**: Always define metadata before generating tests
2. **Group Leaders**: Use for related fields that must be consistent
3. **Custom Functions**: Create domain-specific random generators
4. **Dependency Order**: Ensure parent entities are defined before children
5. **Debug Mode**: Use debug mode to understand generation logic
6. **Version Control**: Keep metadata definitions in version control
7. **CI Integration**: Run generated tests in continuous integration

## Limitations

1. **Complex Logic**: Very complex business rules may need manual scenarios
2. **Dynamic Schemas**: Works best with stable, well-defined schemas
3. **Performance**: Large-scale generation can be resource intensive
4. **Cross-Schema**: Limited support for cross-schema relationships

## Future Enhancements

1. **ML-Based Generation**: Use patterns from production data
2. **Visual Designer**: GUI for metadata configuration
3. **Test Optimization**: Identify redundant test cases
4. **Mutation Testing**: Verify test quality
5. **Distributed Testing**: Parallel test execution
