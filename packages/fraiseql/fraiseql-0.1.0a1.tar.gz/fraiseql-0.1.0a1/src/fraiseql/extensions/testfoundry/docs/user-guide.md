# TestFoundry User Guide

This guide walks you through using TestFoundry to generate comprehensive tests for your PostgreSQL database.

## Table of Contents

1. [Installation](#installation)
2. [Basic Setup](#basic-setup)
3. [Defining Input Mappings](#defining-input-mappings)
4. [Working with Foreign Keys](#working-with-foreign-keys)
5. [Using Group Leaders](#using-group-leaders)
6. [Generating Tests](#generating-tests)
7. [Running Tests](#running-tests)
8. [Advanced Features](#advanced-features)

## Installation

### Prerequisites

- PostgreSQL 14 or higher
- pgTAP extension installed
- FraiseQL (if using with FraiseQL)

### Install TestFoundry Schema

```sql
-- Create the TestFoundry schema
CREATE SCHEMA IF NOT EXISTS testfoundry;

-- Run the installation scripts in order:
-- 1. Tables (1_tables/*.sql)
-- 2. Functions (3_functions/*.sql)
-- 3. Generators (590_test_generation/*.sql)
```

Or using the Python API:

```python
from fraiseql.extensions.testfoundry import FoundrySetup

setup = FoundrySetup(repository)
await setup.install()
```

## Basic Setup

### Step 1: Identify Your Entities

List the entities you want to test:
- Table names (e.g., `tb_users`, `tb_posts`)
- Input type names (e.g., `user_input`, `post_input`)
- Relationships between entities

### Step 2: Create Input Type (if not exists)

```sql
-- Example: User input type
CREATE TYPE type_user_input AS (
    email TEXT,
    name TEXT,
    bio TEXT,
    avatar_url TEXT
);
```

## Defining Input Mappings

### Basic Field Mapping

For each field in your input type, define how it should be generated:

```sql
INSERT INTO testfoundry.testfoundry_tb_input_field_mapping
(input_type, field_name, generator_type, random_function, required)
VALUES
-- Email with custom function
('user_input', 'email', 'random', 'testfoundry_random_email', TRUE),

-- Simple text field
('user_input', 'name', 'random', NULL, TRUE),

-- Optional field
('user_input', 'bio', 'random', NULL, FALSE),

-- URL field
('user_input', 'avatar_url', 'random', 'testfoundry_random_url', FALSE);
```

### Generator Types

| Type | Purpose | Example |
|------|---------|---------|
| `random` | Generate random values | Names, descriptions, numbers |
| `resolve_fk` | Resolve foreign keys | user_id, post_id |
| `nested` | Nested composite types | Address, metadata objects |

### Built-in Random Functions

| Function | Generates | Example Output |
|----------|-----------|----------------|
| `testfoundry_random_email` | Email addresses | user_8d3f2a@example.com |
| `testfoundry_random_url` | URLs | https://example.com/a3f2d8 |
| `testfoundry_random_phone` | Phone numbers | +1-555-123-4567 |
| `testfoundry_random_latitude` | Latitudes | 42.3601 |
| `testfoundry_random_longitude` | Longitudes | -71.0589 |

## Working with Foreign Keys

### Step 1: Define FK Mapping

Tell TestFoundry how to resolve foreign key values:

```sql
INSERT INTO testfoundry.testfoundry_tb_fk_mapping
(input_type, from_expression, select_field, random_pk_field,
 random_value_field, random_select_where)
VALUES
(
    'user_id',                          -- Logical name
    'tb_users',                         -- Table to select from
    'id',                               -- Field to select
    'id',                               -- PK field name
    'email',                            -- Display field
    'deleted_at IS NULL'                -- WHERE conditions
);
```

### Step 2: Use FK in Field Mapping

```sql
INSERT INTO testfoundry.testfoundry_tb_input_field_mapping
(input_type, field_name, generator_type, fk_mapping_key, required)
VALUES
('post_input', 'author_id', 'resolve_fk', 'user_id', TRUE);
```

### Complex FK with Dependencies

For FKs that depend on other fields:

```sql
-- FK mapping with dependency
INSERT INTO testfoundry.testfoundry_tb_fk_mapping
(input_type, from_expression, select_field, random_select_where,
 dependency_fields, dependency_field_mapping)
VALUES
(
    'city_id',
    'tb_cities c JOIN tb_countries co ON c.country_id = co.id',
    'c.id',
    'c.deleted_at IS NULL AND co.name = $1',
    ARRAY['country'],                   -- Depends on country field
    '{"country": "co.name"}'::jsonb    -- Map to SQL field
);
```

## Using Group Leaders

Group leaders ensure related fields maintain consistency.

### Example: Address Fields

```sql
-- Country is the group leader
INSERT INTO testfoundry.testfoundry_tb_input_field_mapping
(input_type, field_name, generator_type, fk_mapping_key,
 group_leader, generator_group, group_dependency_fields)
VALUES
-- Group leader that generates all fields
('address_input', 'country', 'resolve_fk', 'country_with_postal',
 TRUE, 'address_group', ARRAY['country', 'postal_code', 'city']),

-- Dependent fields (generated by leader)
('address_input', 'postal_code', 'resolve_fk', 'postal_code',
 FALSE, 'address_group', NULL),

('address_input', 'city', 'resolve_fk', 'city',
 FALSE, 'address_group', NULL);
```

### FK Mapping for Group Leader

```sql
INSERT INTO testfoundry.testfoundry_tb_fk_mapping
(input_type, from_expression, random_select_expression)
VALUES
(
    'country_with_postal',
    '
    tb_countries c
    JOIN tb_postal_codes p ON p.country_id = c.id
    JOIN tb_cities ci ON ci.postal_code_id = p.id
    ',
    -- Return multiple fields as JSONB
    'jsonb_build_object(
        ''country'', c.name,
        ''postal_code'', p.code,
        ''city'', ci.name
    )'
);
```

## Generating Tests

### Generate Individual Test Types

```sql
-- Happy path test
SELECT testfoundry_generate_happy_create('users');

-- Duplicate constraint test
SELECT testfoundry_generate_duplicate_create('users');

-- Foreign key violation test
SELECT testfoundry_generate_fk_violation_create('posts');

-- Soft delete test
SELECT testfoundry_generate_soft_delete('users');
```

### Using Python API

```python
from fraiseql.extensions.testfoundry import FoundryGenerator

generator = FoundryGenerator(repository)

# Generate all tests for an entity
tests = await generator.generate_tests_for_entity(
    entity_name="users",
    table_name="tb_users",
    input_type_name="user_input"
)

# Write to files
await generator.write_tests_to_files(tests, "users")
```

### Batch Generation

Generate tests for multiple entities:

```python
entities = [
    {"entity_name": "users", "table_name": "tb_users", "input_type_name": "user_input"},
    {"entity_name": "posts", "table_name": "tb_posts", "input_type_name": "post_input"},
    {"entity_name": "comments", "table_name": "tb_comments", "input_type_name": "comment_input"}
]

await generator.generate_all_tests(entities)
```

## Running Tests

### Direct Execution

```sql
-- Run a generated test
SELECT * FROM test_users_happy_create();

-- Run all tests for an entity
SELECT * FROM run_tests('test_users_%');
```

### With pgTAP

```bash
# Run all tests
pg_prove -U postgres -d mydb tests/generated/*.sql

# Run specific test
pg_prove -U postgres -d mydb tests/generated/users/happy_create.sql
```

### With pytest

If you generated pytest wrappers:

```bash
# Run all generated tests
pytest tests/generated/

# Run tests for specific entity
pytest tests/generated/users/

# Run with database marker
pytest -m database tests/generated/
```

## Advanced Features

### Custom Random Functions

Create domain-specific generators:

```sql
-- Social Security Number generator
CREATE FUNCTION testfoundry_random_ssn()
RETURNS TEXT AS $$
BEGIN
    RETURN LPAD((RANDOM() * 999)::INT::TEXT, 3, '0') || '-' ||
           LPAD((RANDOM() * 99)::INT::TEXT, 2, '0') || '-' ||
           LPAD((RANDOM() * 9999)::INT::TEXT, 4, '0');
END;
$$ LANGUAGE plpgsql;

-- Use in mapping
INSERT INTO testfoundry.testfoundry_tb_input_field_mapping
(input_type, field_name, generator_type, random_function, required)
VALUES
('employee_input', 'ssn', 'random', 'testfoundry_random_ssn', TRUE);
```

### Manual Test Scenarios

Define specific test cases:

```sql
INSERT INTO testfoundry.test_manual_scenarios
(entity_name, scenario_type, input_json, expected_result, description)
VALUES
(
    'users',
    'boundary_test',
    '{"email": "a@b.c", "name": "A"}',  -- Minimum valid email
    'success',
    'Test minimum valid email format'
);
```

### Entity Dependencies

Define parent-child relationships:

```sql
INSERT INTO testfoundry.testfoundry_tb_entity_dependents
(entity_name, dependent_entity_name, dependency_type,
 parent_pk_fields, child_fk_fields)
VALUES
('users', 'posts', 'RESTRICT', ARRAY['id'], ARRAY['author_id']),
('posts', 'comments', 'CASCADE', ARRAY['id'], ARRAY['post_id']);
```

### Debug Mode

Understand how data is generated:

```sql
-- Enable debug output
SELECT testfoundry_generate_random_input('user_input', true);
```

### Custom Test Generators

Create specialized test scenarios:

```sql
CREATE FUNCTION testfoundry_generate_performance_test(entity_name TEXT)
RETURNS TEXT AS $$
DECLARE
    test_sql TEXT;
BEGIN
    test_sql := format($test$
CREATE OR REPLACE FUNCTION test_%I_performance()
RETURNS SETOF TEXT AS $func$
BEGIN
    -- Generate 1000 records
    PERFORM create_%I(
        testfoundry_generate_random_input('%I_input')::jsonb
    )
    FROM generate_series(1, 1000);

    RETURN NEXT pass('Created 1000 %I records');
END;
$func$ LANGUAGE plpgsql;
    $test$, entity_name, entity_name, entity_name, entity_name);

    RETURN test_sql;
END;
$$ LANGUAGE plpgsql;
```

## Best Practices

### 1. Start Simple

Begin with basic mappings and add complexity gradually:
1. Define simple random fields first
2. Add FK relationships
3. Implement group leaders for complex relationships
4. Add custom scenarios for edge cases

### 2. Use Meaningful Names

- Input types: `<entity>_input` (e.g., `user_input`)
- FK mappings: `<entity>_id` (e.g., `user_id`)
- Groups: `<concept>_group` (e.g., `address_group`)

### 3. Document Complex Mappings

```sql
-- Add comments to explain complex logic
COMMENT ON COLUMN testfoundry.testfoundry_tb_input_field_mapping.field_name
IS 'Use group leader for address fields to ensure country/postal/city consistency';
```

### 4. Test Your Mappings

Before generating many tests, verify your mappings work:

```sql
-- Test single random generation
SELECT testfoundry_generate_random_input('user_input', false);

-- Check FK resolution
SELECT testfoundry_random_value_from_mapping('user_id', NULL);
```

### 5. Version Control

Keep your metadata definitions in version control:

```sql
-- migrations/001_testfoundry_metadata.sql
BEGIN;

-- Clear existing mappings
DELETE FROM testfoundry.testfoundry_tb_input_field_mapping
WHERE input_type = 'user_input';

-- Insert new mappings
INSERT INTO testfoundry.testfoundry_tb_input_field_mapping ...

COMMIT;
```

## Common Patterns

### Email Uniqueness Testing

```sql
-- Ensure email generator creates unique values
CREATE FUNCTION testfoundry_random_email_unique()
RETURNS TEXT AS $$
BEGIN
    RETURN 'user_' || gen_random_uuid()::TEXT || '@example.com';
END;
$$ LANGUAGE plpgsql;
```

### Temporal Data

```sql
-- Generate dates within business rules
CREATE FUNCTION testfoundry_random_birth_date()
RETURNS DATE AS $$
BEGIN
    -- Ages 18-80
    RETURN CURRENT_DATE - (RANDOM() * 365 * 62 + 365 * 18)::INT;
END;
$$ LANGUAGE plpgsql;
```

### Status Fields

```sql
-- Generate weighted random statuses
CREATE FUNCTION testfoundry_random_status()
RETURNS TEXT AS $$
BEGIN
    -- 70% active, 20% pending, 10% inactive
    RETURN CASE
        WHEN RANDOM() < 0.7 THEN 'active'
        WHEN RANDOM() < 0.9 THEN 'pending'
        ELSE 'inactive'
    END;
END;
$$ LANGUAGE plpgsql;
```

## Next Steps

- Review [Examples](./examples.md) for complete scenarios
- Check [API Reference](./api-reference.md) for all functions
- See [Troubleshooting](./troubleshooting.md) for common issues
