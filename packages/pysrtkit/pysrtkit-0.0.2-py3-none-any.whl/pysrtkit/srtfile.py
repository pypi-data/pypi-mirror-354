# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_srtfile.ipynb.

# %% auto 0
__all__ = ['BOMS', 'CODECS_BOMS', 'BIGGER_BOM', 'InvalidItem', 'Error', 'SubRipTime', 'ComparableMixin', 'SubRipItem',
           'SubRipFile']

# %% ../nbs/00_srtfile.ipynb 2
import re
import os
import sys
import codecs
from collections import UserList
from itertools import chain
from copy import copy

# %% ../nbs/00_srtfile.ipynb 3
# Dummy classes for demonstration; replace with your actual implementations
class InvalidItem(Exception):
    pass


class Error(Exception):
    pass


class SubRipTime:
    @staticmethod
    def coerce(value):
        # Dummy implementation; replace with your actual logic
        return value if isinstance(value, SubRipTime) else SubRipTime()

    def __sub__(self, other):
        # Dummy implementation; replace with your actual logic
        return self

    @property
    def ordinal(self):
        # Dummy implementation; replace with your actual logic
        return 1000

    def shift(self, *args, **kwargs):
        pass


class ComparableMixin:
    def __lt__(self, other):
        return self._cmpkey() < other._cmpkey()

    def __eq__(self, other):
        return self._cmpkey() == other._cmpkey()


class SubRipItem(ComparableMixin):
    ITEM_PATTERN = "%s\n%s --> %s%s\n%s\n"
    TIMESTAMP_SEPARATOR = "-->"

    def __init__(self, index=0, start=None, end=None, text="", position=""):
        try:
            self.index = int(index)
        except (TypeError, ValueError):
            self.index = index
        self.start = SubRipTime.coerce(start or 0)
        self.end = SubRipTime.coerce(end or 0)
        self.position = str(position)
        self.text = str(text)

    @property
    def duration(self):
        return self.end - self.start

    @property
    def text_without_tags(self):
        RE_TAG = re.compile(r"<[^>]*?>")
        return RE_TAG.sub("", self.text)

    @property
    def characters_per_second(self):
        characters_count = len(self.text_without_tags.replace("\n", ""))
        try:
            return characters_count / (self.duration.ordinal / 1000.0)
        except ZeroDivisionError:
            return 0.0

    def __str__(self):
        position = " %s" % self.position if self.position.strip() else ""
        return self.ITEM_PATTERN % (
            self.index,
            self.start,
            self.end,
            position,
            self.text,
        )

    def _cmpkey(self):
        return (self.start, self.end)

    def shift(self, *args, **kwargs):
        self.start.shift(*args, **kwargs)
        self.end.shift(*args, **kwargs)

    @classmethod
    def from_string(cls, source):
        return cls.from_lines(source.splitlines(True))

    @classmethod
    def from_lines(cls, lines):
        if len(lines) < 2:
            raise InvalidItem()
        lines = [l.rstrip() for l in lines]
        index = None
        if cls.TIMESTAMP_SEPARATOR not in lines[0]:
            index = lines.pop(0)
        start, end, position = cls.split_timestamps(lines[0])
        body = "\n".join(lines[1:])
        return cls(index, start, end, body, position)

    @classmethod
    def split_timestamps(cls, line):
        timestamps = line.split(cls.TIMESTAMP_SEPARATOR)
        if len(timestamps) != 2:
            raise InvalidItem()
        start, end_and_position = timestamps
        end_and_position = end_and_position.lstrip().split(" ", 1)
        end = end_and_position[0]
        position = end_and_position[1] if len(end_and_position) > 1 else ""
        return (s.strip() for s in (start, end, position))


BOMS = (
    (codecs.BOM_UTF32_LE, "utf_32_le"),
    (codecs.BOM_UTF32_BE, "utf_32_be"),
    (codecs.BOM_UTF16_LE, "utf_16_le"),
    (codecs.BOM_UTF16_BE, "utf_16_be"),
    (codecs.BOM_UTF8, "utf_8"),
)
CODECS_BOMS = dict((codec, str(bom, codec)) for bom, codec in BOMS)
BIGGER_BOM = max(len(bom) for bom, encoding in BOMS)

# %% ../nbs/00_srtfile.ipynb 4
class SubRipFile(UserList):
    ERROR_PASS = 0
    ERROR_LOG = 1
    ERROR_RAISE = 2
    DEFAULT_ENCODING = "utf_8"

    def __init__(self, items=None, eol=None, path=None, encoding="utf-8"):
        super().__init__(items or [])
        self._eol = eol
        self.path = path
        self.encoding = encoding

    @property
    def eol(self):
        return self._eol or os.linesep

    @eol.setter
    def eol(self, eol):
        self._eol = self._eol or eol

    def slice(
        self, starts_before=None, starts_after=None, ends_before=None, ends_after=None
    ):
        clone = copy(self)
        if starts_before:
            clone.data = (i for i in clone.data if i.start < starts_before)
        if starts_after:
            clone.data = (i for i in clone.data if i.start > starts_after)
        if ends_before:
            clone.data = (i for i in clone.data if i.end < ends_before)
        if ends_after:
            clone.data = (i for i in clone.data if i.end > ends_after)
        clone.data = list(clone.data)
        return clone

    def at(self, timestamp=None, **kwargs):
        time = timestamp or kwargs
        return self.slice(starts_before=time, ends_after=time)

    def shift(self, *args, **kwargs):
        for item in self:
            item.shift(*args, **kwargs)

    def clean_indexes(self):
        self.sort()
        for index, item in enumerate(self):
            item.index = index + 1

    @property
    def text(self):
        return "\n".join(i.text for i in self)

    @classmethod
    def open(cls, path="", encoding=None, error_handling=ERROR_PASS):
        source_file, encoding = cls._open_unicode_file(path, claimed_encoding=encoding)
        new_file = cls(path=path, encoding=encoding)
        new_file.read(source_file, error_handling=error_handling)
        source_file.close()
        return new_file

    @classmethod
    def from_string(cls, source, **kwargs):
        error_handling = kwargs.pop("error_handling", None)
        new_file = cls(**kwargs)
        new_file.read(source.splitlines(True), error_handling=error_handling)
        return new_file

    def read(self, source_file, error_handling=ERROR_PASS):
        self.eol = self._guess_eol(source_file)
        self.extend(self.stream(source_file, error_handling=error_handling))
        return self

    @classmethod
    def stream(cls, source_file, error_handling=ERROR_PASS):
        string_buffer = []
        for index, line in enumerate(chain(source_file, "\n")):
            if line.strip():
                string_buffer.append(line)
            else:
                source = string_buffer
                string_buffer = []
                if source and all(source):
                    try:
                        yield SubRipItem.from_lines(source)
                    except Error as error:
                        error.args += ("".join(source),)
                        cls._handle_error(error, error_handling, index)

    def save(self, path=None, encoding=None, eol=None):
        path = path or self.path
        encoding = encoding or self.encoding
        save_file = codecs.open(path, "w+", encoding=encoding)
        self.write_into(save_file, eol=eol)
        save_file.close()

    def write_into(self, output_file, eol=None):
        output_eol = eol or self.eol
        for item in self:
            string_repr = str(item)
            if output_eol != "\n":
                string_repr = string_repr.replace("\n", output_eol)
            output_file.write(string_repr)
            if not string_repr.endswith(2 * output_eol):
                output_file.write(output_eol)

    @classmethod
    def _guess_eol(cls, string_iterable):
        first_line = cls._get_first_line(string_iterable)
        for eol in ("\r\n", "\r", "\n"):
            if first_line.endswith(eol):
                return eol
        return os.linesep

    @classmethod
    def _get_first_line(cls, string_iterable):
        if hasattr(string_iterable, "tell"):
            previous_position = string_iterable.tell()
        try:
            first_line = next(iter(string_iterable))
        except StopIteration:
            return ""
        if hasattr(string_iterable, "seek"):
            string_iterable.seek(previous_position)
        return first_line

    @classmethod
    def _detect_encoding(cls, path):
        file_descriptor = open(path, "rb")
        first_chars = file_descriptor.read(BIGGER_BOM)
        file_descriptor.close()
        for bom, encoding in BOMS:
            if first_chars.startswith(bom):
                return encoding
        return cls.DEFAULT_ENCODING

    @classmethod
    def _open_unicode_file(cls, path, claimed_encoding=None):
        encoding = claimed_encoding or cls._detect_encoding(path)
        source_file = codecs.open(path, "r", encoding=encoding)
        possible_bom = CODECS_BOMS.get(encoding, None)
        if possible_bom:
            file_bom = source_file.read(len(possible_bom))
            if not file_bom == possible_bom:
                source_file.seek(0)
        return source_file, encoding

    @classmethod
    def _handle_error(cls, error, error_handling, index):
        if error_handling == cls.ERROR_RAISE:
            error.args = (index,) + error.args
            raise error
        if error_handling == cls.ERROR_LOG:
            name = type(error).__name__
            sys.stderr.write("PySRT-%s(line %s): \n" % (name, index))
            sys.stderr.write(error.args[0].encode("ascii", "replace"))
            sys.stderr.write("\n")
