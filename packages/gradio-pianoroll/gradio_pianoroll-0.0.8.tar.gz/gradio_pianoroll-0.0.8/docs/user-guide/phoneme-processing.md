# ìŒì†Œ ì²˜ë¦¬ (G2P)

í•œêµ­ì–´ ê°€ì‚¬ë¥¼ ìŒì†Œë¡œ ë³€í™˜í•˜ëŠ” G2P(Grapheme-to-Phoneme) ê¸°ëŠ¥ì„ í™œìš©í•´ë³´ì„¸ìš”.

## ğŸ—£ï¸ ê°œìš”

ìŒì†Œ ì²˜ë¦¬ ê¸°ëŠ¥ì€ í•œêµ­ì–´ ê°€ì‚¬ë¥¼ ë°œìŒ ê¸°í˜¸(phoneme)ë¡œ ìë™ ë³€í™˜í•˜ì—¬ ë” ì •í™•í•œ ìŒì„± í•©ì„±ì„ ê°€ëŠ¥í•˜ê²Œ í•©ë‹ˆë‹¤.

### ì£¼ìš” ê¸°ëŠ¥
- **ìë™ G2P**: ê°€ì‚¬ ì…ë ¥ ì‹œ ìë™ìœ¼ë¡œ ìŒì†Œ ìƒì„±
- **ì»¤ìŠ¤í…€ ë§¤í•‘**: ì‚¬ìš©ì ì •ì˜ ìŒì†Œ ë§¤í•‘ ê´€ë¦¬
- **ì¼ê´„ ì²˜ë¦¬**: ì—¬ëŸ¬ ë…¸íŠ¸ì˜ ìŒì†Œë¥¼ í•œ ë²ˆì— ìƒì„±
- **ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸**: ê°€ì‚¬ ë³€ê²½ ì‹œ ì¦‰ì‹œ ìŒì†Œ ë°˜ì˜

## ğŸ”¤ í•œêµ­ì–´ ìŒì„±í•™ ê¸°ì´ˆ

### ê¸°ë³¸ ììŒ (19ê°œ)

| í•œê¸€ | ìŒì†Œ | ì˜ˆì‹œ | ì„¤ëª… |
|------|------|------|------|
| ã„± | g | **ê°€**ë½ | ì—°ìŒ |
| ã„² | kk | **ê¹Œ**ì¹˜ | ê²½ìŒ |
| ã„´ | n | **ë‚˜**ë¬´ | ë¹„ìŒ |
| ã„· | d | **ë‹¤**ë¦¬ | ì—°ìŒ |
| ã„¸ | tt | **ë”°**ë¼ | ê²½ìŒ |
| ã„¹ | r/l | **ë¼**ë””ì˜¤ | ìœ ìŒ |
| ã… | m | **ë§ˆ**ìŒ | ë¹„ìŒ |
| ã…‚ | b | **ë°”**ë‹¤ | ì—°ìŒ |
| ã…ƒ | pp | **ë¹ **ë¥¸ | ê²½ìŒ |
| ã…… | s | **ì‚¬**ëŒ | ë§ˆì°°ìŒ |
| ã…† | ss | **ìŒ€** | ê²½ìŒ |
| ã…‡ | ng | í•˜**ã…‡** | ë¹„ìŒ (ë°›ì¹¨) |
| ã…ˆ | j | **ì**ë™ì°¨ | íŒŒì°°ìŒ |
| ã…‰ | jj | **ì§œ**ì¥ë©´ | ê²½ìŒ |
| ã…Š | ch | **ì°¨**ê°€ìš´ | íŒŒì°°ìŒ |
| ã…‹ | k | **ì¹´**ë©”ë¼ | íŒŒì—´ìŒ |
| ã…Œ | t | **íƒ€**ì´ì–´ | íŒŒì—´ìŒ |
| ã… | p | **íŒŒ**ì¼ | íŒŒì—´ìŒ |
| ã… | h | **í•˜**ëŠ˜ | ë§ˆì°°ìŒ |

### ê¸°ë³¸ ëª¨ìŒ (21ê°œ)

| í•œê¸€ | ìŒì†Œ | ì˜ˆì‹œ | ë¶„ë¥˜ |
|------|------|------|------|
| ã… | a | ê°€**ã…** | ì €ëª¨ìŒ, í›„ì„¤ëª¨ìŒ |
| ã…‘ | ya | **ã…‘**êµ¬ | ì´ì¤‘ëª¨ìŒ |
| ã…“ | eo | ê°€**ã…“** | ì¤‘ëª¨ìŒ, í›„ì„¤ëª¨ìŒ |
| ã…• | yeo | **ã…•**ë¦„ | ì´ì¤‘ëª¨ìŒ |
| ã…— | o | ê°€**ã…—** | ì¤‘ê³ ëª¨ìŒ, í›„ì„¤ëª¨ìŒ |
| ã…› | yo | **ã…›**ì¼ | ì´ì¤‘ëª¨ìŒ |
| ã…œ | u | ê°€**ã…œ** | ê³ ëª¨ìŒ, í›„ì„¤ëª¨ìŒ |
| ã…  | yu | **ã… **ëŸ½ | ì´ì¤‘ëª¨ìŒ |
| ã…¡ | eu | ê°€**ã…¡** | ê³ ëª¨ìŒ, ì¤‘ì„¤ëª¨ìŒ |
| ã…£ | i | ê°€**ã…£** | ê³ ëª¨ìŒ, ì „ì„¤ëª¨ìŒ |
| ã… | ae | ê°€**ã…** | ì¤‘ì €ëª¨ìŒ, ì „ì„¤ëª¨ìŒ |
| ã…’ | yae | **ã…’** | ì´ì¤‘ëª¨ìŒ |
| ã…” | e | ê°€**ã…”** | ì¤‘ê³ ëª¨ìŒ, ì „ì„¤ëª¨ìŒ |
| ã…– | ye | **ã…–**ì˜ë‹¤ | ì´ì¤‘ëª¨ìŒ |
| ã…˜ | wa | ê°€**ã…˜** | ì´ì¤‘ëª¨ìŒ |
| ã…™ | wae | ê°€**ã…™** | ì‚¼ì¤‘ëª¨ìŒ |
| ã…š | oe | ê°€**ã…š** | ì´ì¤‘ëª¨ìŒ |
| ã… | wo | ê°€**ã…** | ì´ì¤‘ëª¨ìŒ |
| ã… | we | ê°€**ã…** | ì‚¼ì¤‘ëª¨ìŒ |
| ã…Ÿ | wi | ê°€**ã…Ÿ** | ì´ì¤‘ëª¨ìŒ |
| ã…¢ | ui | ê°€**ã…¢** | ì´ì¤‘ëª¨ìŒ |

### ë°›ì¹¨ ììŒ (7ê°œ ëŒ€í‘œìŒ)

| ë°›ì¹¨ | ìŒì†Œ | ì˜ˆì‹œ | ì„¤ëª… |
|------|------|------|------|
| ã„±, ã…‹, ã„² | k | ì•…, ë°–, ê¹ | [k] ìŒ |
| ã„´ | n | ì•ˆ, ì²œ | [n] ìŒ |
| ã„·, ã……, ã…†, ã…ˆ, ã…Š, ã…Œ, ã… | t | ì•, ì˜·, ìˆ, ìˆ, ë§, ë°­, ë†“ | [t] ìŒ |
| ã„¹ | l | ë§, ì†” | [l] ìŒ |
| ã… | m | ê°, ê³° | [m] ìŒ |
| ã…‚, ã… | p | ë°¥, ì• | [p] ìŒ |
| ã…‡ | ng | ê°•, ê³µ | [Å‹] ìŒ |

## ğŸ¯ ê¸°ë³¸ ì‚¬ìš©ë²•

### 1. ê¸°ë³¸ ì„¤ì •

```python
import gradio as gr
from gradio_pianoroll import PianoRoll

# ê¸°ë³¸ ìŒì†Œ ë§¤í•‘ ì‹œìŠ¤í…œ
user_phoneme_map = {
    'ê°€': 'g a',
    'ë‚˜': 'n a',
    'ë‹¤': 'd a',
    'ë¼': 'l aa',
    'ë§ˆ': 'm a',
    'ë°”': 'b a',
    'ì‚¬': 's a',
    'ì•„': 'aa',
    'ì': 'j a',
    'ì°¨': 'ch a',
    'ì¹´': 'k a',
    'íƒ€': 't a',
    'íŒŒ': 'p a',
    'í•˜': 'h a',
    'ì•ˆë…•': 'aa n ny eo ng',
    'í•˜ì„¸ìš”': 'h a s e y o',
    'ìŒì•…': 'eu m a k',
    'í”¼ì•„ë…¸': 'p i a n o'
}

def mock_g2p(text: str) -> str:
    """í•œêµ­ì–´ G2P í•¨ìˆ˜"""
    text = text.strip()
    
    # ì‚¬ìš©ì ì •ì˜ ë§¤í•‘ì—ì„œ ì°¾ê¸°
    if text in user_phoneme_map:
        return user_phoneme_map[text]
    
    # ê¸€ìë³„ ì²˜ë¦¬
    result = []
    for char in text:
        if char in user_phoneme_map:
            result.append(user_phoneme_map[char])
        else:
            result.append(char)  # ì•Œ ìˆ˜ ì—†ëŠ” ê¸€ìëŠ” ê·¸ëŒ€ë¡œ
    
    return ' '.join(result)
```

### 2. í”¼ì•„ë…¸ë¡¤ ì„¤ì •

```python
# ìŒì†Œê°€ í¬í•¨ëœ ë…¸íŠ¸ ë°ì´í„°
initial_notes = {
    "notes": [
        {
            "id": "note_0",
            "start": 0,
            "duration": 160,
            "pitch": 60,
            "velocity": 100,
            "lyric": "ì•ˆë…•",
            "phoneme": "aa n ny eo ng"
        },
        {
            "id": "note_1",
            "start": 160,
            "duration": 160,
            "pitch": 62,
            "velocity": 100,
            "lyric": "í•˜ì„¸ìš”",
            "phoneme": "h a s e y o"
        }
    ],
    "tempo": 120,
    "timeSignature": {"numerator": 4, "denominator": 4},
    "editMode": "select",
    "snapSetting": "1/4"
}

piano_roll = PianoRoll(
    height=600,
    width=1000,
    value=initial_notes
)
```

## ğŸ”„ ìë™ G2P ì²˜ë¦¬

### ì‹¤ì‹œê°„ ìŒì†Œ ìƒì„±

ê°€ì‚¬ ì…ë ¥ ì‹œ ìë™ìœ¼ë¡œ ìŒì†Œê°€ ìƒì„±ë˜ë„ë¡ ì„¤ì •:

```python
def auto_generate_missing_phonemes(piano_roll_data):
    """ê°€ì‚¬ê°€ ìˆì§€ë§Œ phonemeì´ ì—†ëŠ” ë…¸íŠ¸ë“¤ì— ëŒ€í•´ ìë™ ìŒì†Œ ìƒì„±"""
    if not piano_roll_data or 'notes' not in piano_roll_data:
        return piano_roll_data, "í”¼ì•„ë…¸ë¡¤ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤."

    notes = piano_roll_data['notes'].copy()
    updated_notes = []
    changes_made = 0

    for note in notes:
        note_copy = note.copy()
        lyric = note.get('lyric', '').strip()
        current_phoneme = note.get('phoneme', '').strip()

        if lyric:
            # G2P ì‹¤í–‰
            new_phoneme = mock_g2p(lyric)
            
            # ê¸°ì¡´ phonemeê³¼ ë‹¤ë¥´ê±°ë‚˜ ì—†ìœ¼ë©´ ì—…ë°ì´íŠ¸
            if not current_phoneme or current_phoneme != new_phoneme:
                note_copy['phoneme'] = new_phoneme
                changes_made += 1
                print(f"G2P ì ìš©: '{lyric}' -> '{new_phoneme}'")
        else:
            # ê°€ì‚¬ê°€ ì—†ìœ¼ë©´ phonemeë„ ì œê±°
            if current_phoneme:
                note_copy['phoneme'] = None
                changes_made += 1

        updated_notes.append(note_copy)

    if changes_made > 0:
        updated_piano_roll = piano_roll_data.copy()
        updated_piano_roll['notes'] = updated_notes
        return updated_piano_roll, f"ìë™ G2P ì™„ë£Œ: {changes_made}ê°œ ë…¸íŠ¸ ì—…ë°ì´íŠ¸"
    else:
        return piano_roll_data, "G2P ì ìš©í•  ë³€ê²½ì‚¬í•­ì´ ì—†ìŠµë‹ˆë‹¤."

# ì´ë²¤íŠ¸ ì—°ê²°
piano_roll.input(
    fn=auto_generate_missing_phonemes,
    inputs=[piano_roll],
    outputs=[piano_roll, status_text]
)
```

### ì¼ê´„ ìŒì†Œ ìƒì„±

ëª¨ë“  ë…¸íŠ¸ì— ëŒ€í•´ í•œ ë²ˆì— ìŒì†Œ ìƒì„±:

```python
def auto_generate_all_phonemes(piano_roll_data):
    """ëª¨ë“  ë…¸íŠ¸ì˜ ê°€ì‚¬ì— ëŒ€í•´ ìë™ìœ¼ë¡œ phoneme ìƒì„±"""
    if not piano_roll_data or 'notes' not in piano_roll_data:
        return piano_roll_data, "í”¼ì•„ë…¸ë¡¤ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤."

    notes = piano_roll_data['notes'].copy()
    updated_count = 0

    for note in notes:
        lyric = note.get('lyric')
        if lyric:
            phoneme = mock_g2p(lyric)
            note['phoneme'] = phoneme
            updated_count += 1
            print(f"ìë™ ìƒì„±: '{lyric}' -> '{phoneme}'")

    updated_piano_roll = piano_roll_data.copy()
    updated_piano_roll['notes'] = notes

    return updated_piano_roll, f"{updated_count}ê°œ ë…¸íŠ¸ì˜ phonemeì´ ìë™ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤."

# ì¼ê´„ ìƒì„± ë²„íŠ¼
btn_auto_generate = gr.Button("ğŸ¤– ëª¨ë“  Phoneme ìë™ ìƒì„±")
btn_auto_generate.click(
    fn=auto_generate_all_phonemes,
    inputs=[piano_roll],
    outputs=[piano_roll, status_text]
)
```

## ğŸ“ ìŒì†Œ ë§¤í•‘ ê´€ë¦¬

### ë§¤í•‘ í…Œì´ë¸” í‘œì‹œ

í˜„ì¬ ìŒì†Œ ë§¤í•‘ì„ í…Œì´ë¸”ë¡œ ê´€ë¦¬:

```python
def get_phoneme_mapping_for_dataframe():
    """Dataframeìš© phoneme ë§¤í•‘ ë¦¬ìŠ¤íŠ¸ ë°˜í™˜"""
    global user_phoneme_map
    return [[k, v] for k, v in user_phoneme_map.items()]

# Gradio Dataframeìœ¼ë¡œ ë§¤í•‘ í…Œì´ë¸” í‘œì‹œ
phoneme_mapping_dataframe = gr.Dataframe(
    headers=["ê°€ì‚¬", "Phoneme"],
    datatype=["str", "str"],
    value=get_phoneme_mapping_for_dataframe(),
    label="í˜„ì¬ Phoneme ë§¤í•‘",
    interactive=True,
    wrap=True
)
```

### ìƒˆ ë§¤í•‘ ì¶”ê°€

```python
def add_phoneme_mapping(lyric: str, phoneme: str):
    """ìƒˆë¡œìš´ phoneme ë§¤í•‘ ì¶”ê°€"""
    global user_phoneme_map
    user_phoneme_map[lyric.strip()] = phoneme.strip()
    return get_phoneme_mapping_for_dataframe(), f"'{lyric}' â†’ '{phoneme}' ë§¤í•‘ì´ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤."

def update_phoneme_mapping(old_lyric: str, new_lyric: str, new_phoneme: str):
    """ê¸°ì¡´ phoneme ë§¤í•‘ ìˆ˜ì •"""
    global user_phoneme_map
    
    # ê¸°ì¡´ ë§¤í•‘ ì‚­ì œ
    if old_lyric in user_phoneme_map:
        del user_phoneme_map[old_lyric]
    
    # ìƒˆ ë§¤í•‘ ì¶”ê°€
    user_phoneme_map[new_lyric.strip()] = new_phoneme.strip()
    return get_phoneme_mapping_for_dataframe(), f"ë§¤í•‘ì´ '{new_lyric}' â†’ '{new_phoneme}'ë¡œ ìˆ˜ì •ë˜ì—ˆìŠµë‹ˆë‹¤."

def delete_phoneme_mapping(lyric: str):
    """phoneme ë§¤í•‘ ì‚­ì œ"""
    global user_phoneme_map
    if lyric in user_phoneme_map:
        del user_phoneme_map[lyric]
        return get_phoneme_mapping_for_dataframe(), f"'{lyric}' ë§¤í•‘ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤."
    else:
        return get_phoneme_mapping_for_dataframe(), f"'{lyric}' ë§¤í•‘ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."

# UI ì»´í¬ë„ŒíŠ¸
with gr.Row():
    add_lyric_input = gr.Textbox(label="ê°€ì‚¬", placeholder="ì˜ˆ: ë¼")
    add_phoneme_input = gr.Textbox(label="Phoneme", placeholder="ì˜ˆ: l aa")

btn_add_mapping = gr.Button("â• ë§¤í•‘ ì¶”ê°€", variant="primary")
btn_add_mapping.click(
    fn=add_phoneme_mapping,
    inputs=[add_lyric_input, add_phoneme_input],
    outputs=[phoneme_mapping_dataframe, status_text]
)
```

### ë§¤í•‘ ì´ˆê¸°í™”

```python
def initialize_phoneme_map():
    """ê¸°ë³¸ í•œêµ­ì–´ phoneme ë§¤í•‘ìœ¼ë¡œ ì´ˆê¸°í™”"""
    global user_phoneme_map
    user_phoneme_map = {
        # ê¸°ë³¸ ììŒ/ëª¨ìŒ
        'ê°€': 'g a', 'ë‚˜': 'n a', 'ë‹¤': 'd a', 'ë¼': 'l aa', 'ë§ˆ': 'm a',
        'ë°”': 'b a', 'ì‚¬': 's a', 'ì•„': 'aa', 'ì': 'j a', 'ì°¨': 'ch a',
        'ì¹´': 'k a', 'íƒ€': 't a', 'íŒŒ': 'p a', 'í•˜': 'h a',
        
        # ìŒê³„
        'ë„': 'd o', 'ë ˆ': 'l e', 'ë¯¸': 'm i', 'íŒŒ': 'p aa',
        'ì†”': 's o l', 'ë¼': 'l aa', 'ì‹œ': 's i',
        
        # ì¼ë°˜ì ì¸ ë‹¨ì–´
        'ì•ˆë…•': 'aa n ny eo ng',
        'í•˜ì„¸ìš”': 'h a s e y o',
        'ë…¸ë˜': 'n o l ae',
        'ì‚¬ë‘': 's a l a ng',
        'í–‰ë³µ': 'h ae ng b o k',
        'ìŒì•…': 'eu m a k',
        'í”¼ì•„ë…¸': 'p i a n o'
    }

def reset_phoneme_mapping():
    """phoneme ë§¤í•‘ì„ ê¸°ë³¸ê°’ìœ¼ë¡œ ë¦¬ì…‹"""
    initialize_phoneme_map()
    return get_phoneme_mapping_for_dataframe(), "Phoneme ë§¤í•‘ì´ ê¸°ë³¸ê°’ìœ¼ë¡œ ë¦¬ì…‹ë˜ì—ˆìŠµë‹ˆë‹¤."

btn_reset_mapping = gr.Button("ğŸ”„ ë§¤í•‘ ê¸°ë³¸ê°’ìœ¼ë¡œ ë¦¬ì…‹")
btn_reset_mapping.click(
    fn=reset_phoneme_mapping,
    outputs=[phoneme_mapping_dataframe, status_text]
)
```

## ğŸµ ì‹¤ì œ í™œìš© ì˜ˆì œ

### ì™„ì „í•œ ìŒì†Œ ì²˜ë¦¬ ì‹œìŠ¤í…œ

```python
import gradio as gr
from gradio_pianoroll import PianoRoll

class PhonemeMappingSystem:
    def __init__(self):
        self.phoneme_map = {
            # ê¸°ë³¸ ë§¤í•‘ë“¤...
            'ê°€': 'g a', 'ë‚˜': 'n a', 'ë‹¤': 'd a',
            # ... (ìœ„ì˜ initialize_phoneme_map ë‚´ìš©)
        }
    
    def g2p(self, text: str) -> str:
        """G2P ë³€í™˜"""
        text = text.strip()
        if text in self.phoneme_map:
            return self.phoneme_map[text]
        
        # ê¸€ìë³„ ì²˜ë¦¬
        result = []
        for char in text:
            if char in self.phoneme_map:
                result.append(self.phoneme_map[char])
            else:
                result.append(char)
        return ' '.join(result)
    
    def add_mapping(self, lyric: str, phoneme: str):
        """ë§¤í•‘ ì¶”ê°€"""
        self.phoneme_map[lyric.strip()] = phoneme.strip()
    
    def get_mappings(self):
        """í˜„ì¬ ë§¤í•‘ ë¦¬ìŠ¤íŠ¸ ë°˜í™˜"""
        return [[k, v] for k, v in self.phoneme_map.items()]

# ì „ì—­ ì¸ìŠ¤í„´ìŠ¤
phoneme_system = PhonemeMappingSystem()

def create_phoneme_demo():
    """ìŒì†Œ ì²˜ë¦¬ ë°ëª¨ ìƒì„±"""
    initial_data = {
        "notes": [
            {
                "id": "note_0",
                "start": 0,
                "duration": 160,
                "pitch": 60,
                "velocity": 100,
                "lyric": "ì•ˆë…•",
                "phoneme": phoneme_system.g2p("ì•ˆë…•")
            },
            {
                "id": "note_1", 
                "start": 160,
                "duration": 160,
                "pitch": 64,
                "velocity": 100,
                "lyric": "ìŒì•…"
            }  # ì˜ë„ì ìœ¼ë¡œ phoneme ì—†ìŒ
        ],
        "tempo": 120,
        "timeSignature": {"numerator": 4, "denominator": 4},
        "editMode": "select",
        "snapSetting": "1/4"
    }
    
    return initial_data

def process_lyric_changes(piano_roll_data):
    """ê°€ì‚¬ ë³€ê²½ ì‹œ ìë™ ìŒì†Œ ì²˜ë¦¬"""
    notes = piano_roll_data.get('notes', [])
    changes = 0
    
    for note in notes:
        lyric = note.get('lyric', '').strip()
        if lyric and not note.get('phoneme'):
            note['phoneme'] = phoneme_system.g2p(lyric)
            changes += 1
    
    return piano_roll_data, f"ìë™ G2P ì²˜ë¦¬: {changes}ê°œ ë…¸íŠ¸"

def clear_all_phonemes(piano_roll_data):
    """ëª¨ë“  phoneme ì§€ìš°ê¸°"""
    notes = piano_roll_data.get('notes', [])
    for note in notes:
        note['phoneme'] = None
    
    return piano_roll_data, "ëª¨ë“  phonemeì´ ì§€ì›Œì¡ŒìŠµë‹ˆë‹¤."

# Gradio ì¸í„°í˜ì´ìŠ¤
with gr.Blocks() as demo:
    gr.Markdown("# ğŸ—£ï¸ ìŒì†Œ ì²˜ë¦¬ ì‹œìŠ¤í…œ")
    
    with gr.Row():
        with gr.Column(scale=3):
            piano_roll = PianoRoll(
                height=600,
                width=1000,
                value=create_phoneme_demo()
            )
        
        with gr.Column(scale=1):
            gr.Markdown("### ìŒì†Œ ë§¤í•‘ ê´€ë¦¬")
            
            phoneme_table = gr.Dataframe(
                headers=["ê°€ì‚¬", "Phoneme"],
                value=phoneme_system.get_mappings(),
                label="í˜„ì¬ ë§¤í•‘"
            )
            
            with gr.Row():
                new_lyric = gr.Textbox(label="ê°€ì‚¬")
                new_phoneme = gr.Textbox(label="Phoneme")
            
            btn_add = gr.Button("ì¶”ê°€")
            
            with gr.Row():
                btn_auto = gr.Button("ğŸ¤– ìë™ ìƒì„±")
                btn_clear = gr.Button("ğŸ—‘ï¸ ëª¨ë‘ ì§€ìš°ê¸°")
    
    status = gr.Textbox(label="ìƒíƒœ")
    
    # ì´ë²¤íŠ¸ ì—°ê²°
    piano_roll.input(process_lyric_changes, 
                    inputs=piano_roll, 
                    outputs=[piano_roll, status])
    
    btn_add.click(
        lambda l, p: (phoneme_system.add_mapping(l, p), 
                     phoneme_system.get_mappings(),
                     f"'{l}' â†’ '{p}' ì¶”ê°€ë¨")[1:],
        inputs=[new_lyric, new_phoneme],
        outputs=[phoneme_table, status]
    )
    
    btn_auto.click(process_lyric_changes, 
                  inputs=piano_roll, 
                  outputs=[piano_roll, status])
    
    btn_clear.click(clear_all_phonemes,
                   inputs=piano_roll,
                   outputs=[piano_roll, status])

demo.launch()
```

## ğŸ¯ ê³ ê¸‰ ìŒì†Œ ì²˜ë¦¬

### ë³µí•© ë‹¨ì–´ ì²˜ë¦¬

```python
def advanced_g2p(text: str, phoneme_map: dict) -> str:
    """ê³ ê¸‰ G2P ì²˜ë¦¬ - ë³µí•© ë‹¨ì–´ ìš°ì„  ì²˜ë¦¬"""
    text = text.strip()
    
    # 1. ì „ì²´ ë‹¨ì–´ë¡œ ë¨¼ì € ë§¤í•‘ ì‹œë„
    if text in phoneme_map:
        return phoneme_map[text]
    
    # 2. ë¶€ë¶„ ë‹¨ì–´ ë§¤í•‘ (ê¸´ ê²ƒë¶€í„°)
    for length in range(len(text), 0, -1):
        for start in range(len(text) - length + 1):
            substr = text[start:start + length]
            if substr in phoneme_map:
                before = text[:start]
                after = text[start + length:]
                
                before_phoneme = advanced_g2p(before, phoneme_map) if before else ""
                after_phoneme = advanced_g2p(after, phoneme_map) if after else ""
                
                parts = [p for p in [before_phoneme, phoneme_map[substr], after_phoneme] if p]
                return ' '.join(parts)
    
    # 3. ê¸€ìë³„ ì²˜ë¦¬
    result = []
    for char in text:
        if char in phoneme_map:
            result.append(phoneme_map[char])
        else:
            result.append(char)
    
    return ' '.join(result)
```

### ìŒì†Œ ê²€ì¦

```python
def validate_phoneme(phoneme: str) -> bool:
    """ìŒì†Œ í˜•ì‹ ê²€ì¦"""
    if not phoneme:
        return False
    
    # ê¸°ë³¸ì ì¸ ìŒì†Œ íŒ¨í„´ ì²´í¬
    valid_phonemes = {
        # ììŒ
        'g', 'n', 'd', 'l', 'm', 'b', 's', 'j', 'ch', 'k', 't', 'p', 'h',
        'gg', 'nn', 'dd', 'll', 'mm', 'bb', 'ss', 'jj',
        # ëª¨ìŒ
        'a', 'aa', 'e', 'eo', 'i', 'o', 'u', 'eu', 'ui', 'ae', 'oe', 'wi',
        'ya', 'yaa', 'ye', 'yeo', 'yo', 'yu', 'yae'
    }
    
    parts = phoneme.split()
    for part in parts:
        if part not in valid_phonemes:
            return False
    
    return True

def validate_and_correct_phoneme(lyric: str, phoneme: str) -> tuple[str, str]:
    """ìŒì†Œ ê²€ì¦ ë° ìë™ ìˆ˜ì •"""
    if validate_phoneme(phoneme):
        return phoneme, "ìœ íš¨í•œ ìŒì†Œì…ë‹ˆë‹¤."
    else:
        # ìë™ ìˆ˜ì • ì‹œë„
        corrected = phoneme.replace('r', 'l').replace('f', 'p')
        if validate_phoneme(corrected):
            return corrected, f"ìŒì†Œê°€ ìë™ ìˆ˜ì •ë˜ì—ˆìŠµë‹ˆë‹¤: '{phoneme}' â†’ '{corrected}'"
        else:
            return phoneme, f"âš ï¸ ìœ íš¨í•˜ì§€ ì•Šì€ ìŒì†Œ: '{phoneme}'"
```

## ğŸ“Š ìŒì†Œ ë¶„ì„

### ìŒì†Œ í†µê³„

```python
def analyze_phonemes(piano_roll_data):
    """ìŒì†Œ ì‚¬ìš© í†µê³„ ë¶„ì„"""
    notes = piano_roll_data.get('notes', [])
    
    phoneme_count = {}
    lyric_count = {}
    
    for note in notes:
        lyric = note.get('lyric', '')
        phoneme = note.get('phoneme', '')
        
        if lyric:
            lyric_count[lyric] = lyric_count.get(lyric, 0) + 1
        
        if phoneme:
            for p in phoneme.split():
                phoneme_count[p] = phoneme_count.get(p, 0) + 1
    
    analysis = {
        'ì´ ë…¸íŠ¸ ìˆ˜': len(notes),
        'ê°€ì‚¬ê°€ ìˆëŠ” ë…¸íŠ¸': len([n for n in notes if n.get('lyric')]),
        'ìŒì†Œê°€ ìˆëŠ” ë…¸íŠ¸': len([n for n in notes if n.get('phoneme')]),
        'ì‚¬ìš©ëœ ê°€ì‚¬ ì¢…ë¥˜': len(lyric_count),
        'ì‚¬ìš©ëœ ìŒì†Œ ì¢…ë¥˜': len(phoneme_count),
        'ê°€ì¥ ë§ì´ ì‚¬ìš©ëœ ê°€ì‚¬': max(lyric_count.items(), key=lambda x: x[1]) if lyric_count else None,
        'ê°€ì¥ ë§ì´ ì‚¬ìš©ëœ ìŒì†Œ': max(phoneme_count.items(), key=lambda x: x[1]) if phoneme_count else None
    }
    
    return analysis
```

## ğŸ’¾ ë§¤í•‘ ë°ì´í„° ê´€ë¦¬

### ë§¤í•‘ ì €ì¥/ë¡œë“œ

```python
import json

def save_phoneme_mapping(phoneme_map: dict, filename: str):
    """ìŒì†Œ ë§¤í•‘ì„ íŒŒì¼ë¡œ ì €ì¥"""
    with open(filename, 'w', encoding='utf-8') as f:
        json.dump(phoneme_map, f, ensure_ascii=False, indent=2)

def load_phoneme_mapping(filename: str) -> dict:
    """íŒŒì¼ì—ì„œ ìŒì†Œ ë§¤í•‘ ë¡œë“œ"""
    try:
        with open(filename, 'r', encoding='utf-8') as f:
            return json.load(f)
    except FileNotFoundError:
        return {}

def export_phoneme_mapping():
    """í˜„ì¬ ë§¤í•‘ì„ íŒŒì¼ë¡œ ë‚´ë³´ë‚´ê¸°"""
    global user_phoneme_map
    save_phoneme_mapping(user_phoneme_map, "phoneme_mapping.json")
    return "ë§¤í•‘ì´ phoneme_mapping.jsonìœ¼ë¡œ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤."

def import_phoneme_mapping():
    """íŒŒì¼ì—ì„œ ë§¤í•‘ ê°€ì ¸ì˜¤ê¸°"""
    global user_phoneme_map
    imported_map = load_phoneme_mapping("phoneme_mapping.json")
    if imported_map:
        user_phoneme_map.update(imported_map)
        return "ë§¤í•‘ì„ ì„±ê³µì ìœ¼ë¡œ ê°€ì ¸ì™”ìŠµë‹ˆë‹¤."
    else:
        return "ë§¤í•‘ íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."
```

---

ìŒì†Œ ì²˜ë¦¬ ì‹œìŠ¤í…œì„ í†µí•´ í•œêµ­ì–´ ê°€ì‚¬ì˜ ì •í™•í•œ ë°œìŒì„ ê´€ë¦¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤! ğŸ—£ï¸

**ë‹¤ìŒ ë‹¨ê³„**: [ì˜¤ë””ì˜¤ ë¶„ì„](audio-analysis.md)ì—ì„œ F0ì™€ ìŒì„± íŠ¹ì„± ë¶„ì„ì„ ì•Œì•„ë³´ì„¸ìš”! 