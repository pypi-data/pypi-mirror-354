# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: control/control.proto, debug/debug.proto, infrastructure/finish-line.proto, outputs/battery.proto, outputs/camera.proto, outputs/controller.proto, outputs/distance.proto, outputs/energy.proto, outputs/generic.proto, outputs/imu.proto, outputs/laptime.proto, outputs/lidar.proto, outputs/lux.proto, outputs/rpm.proto, outputs/speed.proto, outputs/wrapper.proto, segmentation/segmentation.proto, simulator/simulator.proto, tuning/tuning.proto
# plugin: python-betterproto
from dataclasses import dataclass
from typing import List

import betterproto


class DetectedObjects(betterproto.Enum):
    """Possible Objects the Imaging Module may detect"""

    FINISH_LINE = 0
    OFF_TRACK = 1
    OBSTACLE = 2
    INTERSECTION = 3
    MISSING_LEFT_LANE = 4
    MISSING_RIGHT_LANE = 5
    SHARP_RIGHT = 6
    SHARP_LEFT = 7
    U_TURN = 8
    S_TURN = 9


class SimStatus(betterproto.Enum):
    """Possible Sim Requests. Useful for interfaces with Gym"""

    SIM_PAUSED = 0
    SIM_REQ_STEP = 1
    SIM_REQ_RESET = 2


@dataclass
class ConnectionState(betterproto.Message):
    """Tell a client if a given client/rover is connected or not"""

    client: str = betterproto.string_field(1)
    connected: bool = betterproto.bool_field(2)
    timestamp_offset: int = betterproto.int64_field(3)


@dataclass
class ControlError(betterproto.Message):
    message: str = betterproto.string_field(1)
    timestamp: int = betterproto.int64_field(2)


@dataclass
class ServiceIdentifier(betterproto.Message):
    """Used to identify a service within the pipeline"""

    name: str = betterproto.string_field(1)
    pid: int = betterproto.int32_field(2)


@dataclass
class ServiceEndpoint(betterproto.Message):
    """An endpoint that is made available by a service"""

    name: str = betterproto.string_field(1)
    address: str = betterproto.string_field(2)


@dataclass
class DebugOutput(betterproto.Message):
    """
    When the transceivers picks up a SensorOutput from a service, it will wrap
    it in a ServiceMessage message, so that the receiver can determine from
    which process the message originated
    """

    service: "ServiceIdentifier" = betterproto.message_field(1)
    endpoint: "ServiceEndpoint" = betterproto.message_field(2)
    sent_at: int = betterproto.int64_field(4)
    message: bytes = betterproto.bytes_field(3)


@dataclass
class FinishLineEvent(betterproto.Message):
    timestamp: int = betterproto.uint64_field(1)


@dataclass
class BatterySensorOutput(betterproto.Message):
    current_output_voltage: float = betterproto.float_field(1)
    warn_voltage: float = betterproto.float_field(2)
    kill_voltage: float = betterproto.float_field(3)


@dataclass
class CanvasObject(betterproto.Message):
    line: "CanvasObjectLine" = betterproto.message_field(1, group="object")
    rectangle: "CanvasObjectRectangle" = betterproto.message_field(2, group="object")
    circle: "CanvasObjectCircle" = betterproto.message_field(3, group="object")


@dataclass
class CanvasObjectPoint(betterproto.Message):
    x: int = betterproto.uint32_field(1)
    y: int = betterproto.uint32_field(2)


@dataclass
class CanvasObjectColor(betterproto.Message):
    r: int = betterproto.uint32_field(1)
    g: int = betterproto.uint32_field(2)
    b: int = betterproto.uint32_field(3)
    a: int = betterproto.uint32_field(4)


@dataclass
class CanvasObjectLine(betterproto.Message):
    start: "CanvasObjectPoint" = betterproto.message_field(1)
    end: "CanvasObjectPoint" = betterproto.message_field(2)
    width: int = betterproto.uint32_field(3)
    color: "CanvasObjectColor" = betterproto.message_field(4)


@dataclass
class CanvasObjectRectangle(betterproto.Message):
    top_left: "CanvasObjectPoint" = betterproto.message_field(1)
    bottom_right: "CanvasObjectPoint" = betterproto.message_field(2)
    width: int = betterproto.uint32_field(3)
    color: "CanvasObjectColor" = betterproto.message_field(4)


@dataclass
class CanvasObjectCircle(betterproto.Message):
    center: "CanvasObjectPoint" = betterproto.message_field(1)
    radius: int = betterproto.uint32_field(2)
    width: int = betterproto.uint32_field(3)
    color: "CanvasObjectColor" = betterproto.message_field(4)


@dataclass
class Canvas(betterproto.Message):
    width: int = betterproto.uint32_field(1)
    height: int = betterproto.uint32_field(2)
    objects: List["CanvasObject"] = betterproto.message_field(3)


@dataclass
class CameraSensorOutput(betterproto.Message):
    """
    The following sensor outputs are specific to the sensor type, bring your
    own sensor and add your own output here!
    """

    trajectory: "CameraSensorOutputTrajectory" = betterproto.message_field(1)
    debug_frame: "CameraSensorOutputDebugFrame" = betterproto.message_field(2)
    objects: "CameraSensorOutputObjects" = betterproto.message_field(3)


@dataclass
class CameraSensorOutputTrajectory(betterproto.Message):
    """Defined by the Path Planner"""

    points: List["CameraSensorOutputTrajectoryPoint"] = betterproto.message_field(1)
    width: int = betterproto.uint32_field(2)
    height: int = betterproto.uint32_field(3)


@dataclass
class CameraSensorOutputTrajectoryPoint(betterproto.Message):
    x: int = betterproto.int32_field(1)
    y: int = betterproto.int32_field(2)


@dataclass
class CameraSensorOutputDebugFrame(betterproto.Message):
    jpeg: bytes = betterproto.bytes_field(1)
    # if image livestreaming is disabled, or imaging module wants to draw
    # additional information on the image, it can be done here
    canvas: "Canvas" = betterproto.message_field(5)


@dataclass
class CameraSensorOutputObjects(betterproto.Message):
    items: List["DetectedObjects"] = betterproto.enum_field(1)


@dataclass
class ControllerOutput(betterproto.Message):
    # Steering angle (-1.0 to 1.0 <-> left - right)
    steering_angle: float = betterproto.float_field(2)
    # Throttle (-1.0 to 1.0 <-> full reverse - full forward)
    left_throttle: float = betterproto.float_field(3)
    right_throttle: float = betterproto.float_field(4)
    # Onboard lights (0.0 to 1.0 <-> off - on)
    front_lights: bool = betterproto.bool_field(5)
    # Fan speed (0.0 to 1.0 <-> off - full speed)
    fan_speed: float = betterproto.float_field(6)
    # Useful for debugging
    raw_error: float = betterproto.float_field(7)
    scaled_error: float = betterproto.float_field(8)


@dataclass
class DistanceSensorOutput(betterproto.Message):
    # distance in meters
    distance: float = betterproto.float_field(1)


@dataclass
class EnergySensorOutput(betterproto.Message):
    # The measure supply voltage measured in volts (V).
    supply_voltage: float = betterproto.float_field(1)
    # The current amp draw in amperes (A) of the power supply source.
    current_amps: float = betterproto.float_field(2)
    # The current power output of the Rover measured in watts (W).
    power_watts: float = betterproto.float_field(3)


@dataclass
class GenericIntScalar(betterproto.Message):
    """
    This message holds a single integer value, it will be plotted in the debug
    view of roverctl
    """

    key: str = betterproto.string_field(1)
    value: int = betterproto.int32_field(2)


@dataclass
class GenericFloatScalar(betterproto.Message):
    """
    This message holds a single float value, it will be plotted in the debug
    view of roverctl
    """

    key: str = betterproto.string_field(1)
    value: float = betterproto.float_field(2)


@dataclass
class GenericBoolScalar(betterproto.Message):
    """
    This message holds a single boolean value, it will *NOT* be plotted in the
    debug view of roverctl
    """

    key: str = betterproto.string_field(1)
    value: bool = betterproto.bool_field(2)


@dataclass
class GenericStringScalar(betterproto.Message):
    """
    This message holds a single string value, it will *NOT* be plotted in the
    debug view of roverctl
    """

    key: str = betterproto.string_field(1)
    value: str = betterproto.string_field(2)


@dataclass
class GenericIntArray(betterproto.Message):
    """
    This message holds an array of integer values, it will *NOT* be plotted in
    the debug view of roverctl
    """

    key: str = betterproto.string_field(1)
    values: List[int] = betterproto.int32_field(2)


@dataclass
class GenericFloatArray(betterproto.Message):
    """
    This message holds an array of float values, it will *NOT* be plotted in
    the debug view of roverctl
    """

    key: str = betterproto.string_field(1)
    values: List[float] = betterproto.float_field(2)


@dataclass
class GenericBoolArray(betterproto.Message):
    """
    This message holds an array of boolean values, it will *NOT* be plotted in
    the debug view of roverctl
    """

    key: str = betterproto.string_field(1)
    values: List[bool] = betterproto.bool_field(2)


@dataclass
class GenericStringArray(betterproto.Message):
    """
    This message holds an array of string values, it will *NOT* be plotted in
    the debug view of roverctl
    """

    key: str = betterproto.string_field(1)
    values: List[str] = betterproto.string_field(2)


@dataclass
class ImuSensorOutput(betterproto.Message):
    temperature: int = betterproto.int32_field(1)
    magnetometer: "ImuSensorOutputVector" = betterproto.message_field(2)
    gyroscope: "ImuSensorOutputVector" = betterproto.message_field(3)
    euler: "ImuSensorOutputVector" = betterproto.message_field(4)
    accelerometer: "ImuSensorOutputVector" = betterproto.message_field(5)
    linear_accelerometer: "ImuSensorOutputVector" = betterproto.message_field(6)
    velocity: "ImuSensorOutputVector" = betterproto.message_field(7)
    speed: float = betterproto.float_field(8)


@dataclass
class ImuSensorOutputVector(betterproto.Message):
    x: float = betterproto.float_field(1)
    y: float = betterproto.float_field(2)
    z: float = betterproto.float_field(3)


@dataclass
class LapTimeOutput(betterproto.Message):
    lap_time: int = betterproto.uint64_field(1)
    lap_start_time: int = betterproto.uint64_field(2)


@dataclass
class LidarSensorOutput(betterproto.Message):
    # Many (but not necessarily all) scans in a single rotation
    scans: List["LidarSensorOutputScan"] = betterproto.message_field(1)


@dataclass
class LidarSensorOutputScan(betterproto.Message):
    """
    A scan corresponds to a single shot of the laser. One rotation contains
    many scans.
    """

    # angle in degrees
    angle: float = betterproto.float_field(1)
    # distance in meters
    distance: float = betterproto.float_field(2)
    # quality of the scan (0 is worst, 255 is best)
    quality: int = betterproto.uint32_field(3)
    # true if this is the start of a new scan rotation
    is_start: bool = betterproto.bool_field(4)


@dataclass
class LuxSensorOutput(betterproto.Message):
    lux: int = betterproto.int32_field(1)


@dataclass
class RpmSensorOutput(betterproto.Message):
    left_rpm: float = betterproto.float_field(1)
    left_angle: float = betterproto.float_field(2)
    right_rpm: float = betterproto.float_field(3)
    right_angle: float = betterproto.float_field(4)


@dataclass
class SpeedSensorOutput(betterproto.Message):
    rpm: int = betterproto.int32_field(1)


@dataclass
class SensorOutput(betterproto.Message):
    # Every sensor has a unique ID to support multiple sensors of the same type
    sensor_id: int = betterproto.uint32_field(1)
    # Add a timestamp to the output to make debugging, logging and
    # synchronisation easier
    timestamp: int = betterproto.uint64_field(2)
    # Report an error if the sensor is not working correctly (controller can
    # decide to ignore or stop the car) 0 = no error, any other value = error
    status: int = betterproto.uint32_field(3)
    camera_output: "CameraSensorOutput" = betterproto.message_field(
        4, group="sensorOutput"
    )
    distance_output: "DistanceSensorOutput" = betterproto.message_field(
        5, group="sensorOutput"
    )
    speed_output: "SpeedSensorOutput" = betterproto.message_field(
        6, group="sensorOutput"
    )
    controller_output: "ControllerOutput" = betterproto.message_field(
        7, group="sensorOutput"
    )
    imu_output: "ImuSensorOutput" = betterproto.message_field(8, group="sensorOutput")
    battery_output: "BatterySensorOutput" = betterproto.message_field(
        9, group="sensorOutput"
    )
    rpm_ouput: "RpmSensorOutput" = betterproto.message_field(10, group="sensorOutput")
    lux_output: "LuxSensorOutput" = betterproto.message_field(11, group="sensorOutput")
    laptime_output: "LapTimeOutput" = betterproto.message_field(
        12, group="sensorOutput"
    )
    generic_int_scalar: "GenericIntScalar" = betterproto.message_field(
        13, group="sensorOutput"
    )
    generic_float_scalar: "GenericFloatScalar" = betterproto.message_field(
        14, group="sensorOutput"
    )
    generic_bool_scalar: "GenericBoolScalar" = betterproto.message_field(
        15, group="sensorOutput"
    )
    generic_string_scalar: "GenericStringScalar" = betterproto.message_field(
        16, group="sensorOutput"
    )
    generic_int_array: "GenericIntArray" = betterproto.message_field(
        17, group="sensorOutput"
    )
    generic_float_array: "GenericFloatArray" = betterproto.message_field(
        18, group="sensorOutput"
    )
    generic_bool_array: "GenericBoolArray" = betterproto.message_field(
        19, group="sensorOutput"
    )
    generic_string_array: "GenericStringArray" = betterproto.message_field(
        20, group="sensorOutput"
    )
    lidar_output: "LidarSensorOutput" = betterproto.message_field(
        21, group="sensorOutput"
    )
    energy_output: "EnergySensorOutput" = betterproto.message_field(
        22, group="sensorOutput"
    )


@dataclass
class Segment(betterproto.Message):
    """
    Control messages exchanged by client(s), the server and the car to send
    data in multiple segments
    """

    packet_id: int = betterproto.int64_field(1)
    segment_id: int = betterproto.int64_field(2)
    total_segments: int = betterproto.int64_field(3)
    data: bytes = betterproto.bytes_field(4)


@dataclass
class SimulatorImageOutput(betterproto.Message):
    """Simulator sensor outputs."""

    width: int = betterproto.uint32_field(2)
    height: int = betterproto.uint32_field(3)
    pixels: bytes = betterproto.bytes_field(4)


@dataclass
class SimulatorState(betterproto.Message):
    """Generic state of Simulator"""

    speed: float = betterproto.float_field(1)
    wheel_off_track: List[bool] = betterproto.bool_field(2)
    image: "SimulatorImageOutput" = betterproto.message_field(3)
    pos: List[float] = betterproto.float_field(4)
    is_drifting: bool = betterproto.bool_field(5)


@dataclass
class TuningState(betterproto.Message):
    timestamp: int = betterproto.uint64_field(1)
    dynamic_parameters: List["TuningStateParameter"] = betterproto.message_field(2)


@dataclass
class TuningStateParameter(betterproto.Message):
    number: "TuningStateParameterNumberParameter" = betterproto.message_field(
        1, group="parameter"
    )
    string: "TuningStateParameterStringParameter" = betterproto.message_field(
        3, group="parameter"
    )


@dataclass
class TuningStateParameterNumberParameter(betterproto.Message):
    """
    note: it may seem weird to not extract the key from the oneof, but this is
    so that the parser can easily determine the type of the parameter
    extracting it to a separate field on the same level as oneof would make it
    ambiguous
    """

    key: str = betterproto.string_field(1)
    value: float = betterproto.float_field(2)


@dataclass
class TuningStateParameterStringParameter(betterproto.Message):
    key: str = betterproto.string_field(1)
    value: str = betterproto.string_field(2)
