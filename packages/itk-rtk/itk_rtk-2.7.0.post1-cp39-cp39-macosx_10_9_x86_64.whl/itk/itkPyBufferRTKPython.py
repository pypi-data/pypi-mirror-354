# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.3.0
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.


import collections

from sys import version_info as _version_info
if _version_info < (3, 7, 0):
    raise RuntimeError("Python 3.7 or later required")

from . import _ITKCommonPython


from . import _RTKPython



from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _itkPyBufferRTKPython
else:
    import _itkPyBufferRTKPython

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


if _swig_python_version_info[0:2] >= (3, 3):
    import collections.abc
else:
    import collections

import itk.itkImageRTKPython
import itk.ITKCommonBasePython
import itk.itkMatrixPython
import itk.vnl_vectorPython
import itk.vnl_matrixPython
import itk.stdcomplexPython
import itk.pyBasePython
import itk.itkPointPython
import itk.itkFixedArrayPython
import itk.itkVectorPython
import itk.vnl_vector_refPython
import itk.itkCovariantVectorPython
import itk.vnl_matrix_fixedPython
import itk.itkIndexPython
import itk.itkOffsetPython
import itk.itkSizePython
import itk.itkImageBaseRTKPython
import itk.itkImageRegionRTKPython
import itk.itkMatrixRTKPython
import itk.itkCovariantVectorRTKPython
import itk.itkPointRTKPython
import itk.itkImagePython
import itk.itkRGBPixelPython
import itk.itkRGBAPixelPython
import itk.itkImageRegionPython
import itk.itkSymmetricSecondRankTensorPython


import numpy as np
class NDArrayITKBase(np.ndarray):
  """A numpy array that provides a view on the data associated with an optional itk "base" object."""

  def __new__(cls, input_array, itk_base=None):
      obj = np.asarray(input_array).view(cls)
      obj.itk_base = itk_base
      return obj

  def __array_finalize__(self, obj):
      if obj is None: return
      self.itk_base = getattr(obj, 'itk_base', None)

try:
    from distributed.protocol import dask_serialize, dask_deserialize
    from typing import Dict, List, Tuple
except (ImportError, RuntimeError):
    pass
else:
    @dask_serialize.register(NDArrayITKBase)
    def serialize(ndarray_itk_base: NDArrayITKBase) -> Tuple[Dict, List[bytes]]:
        dumps = dask_serialize.dispatch(np.ndarray)
        return dumps(ndarray_itk_base)

    @dask_deserialize.register(NDArrayITKBase)
    def deserialize(header: Dict, frames: List[bytes]) -> NDArrayITKBase:
        loads = dask_deserialize.dispatch(np.ndarray)
        return NDArrayITKBase(loads(header, frames))

def _get_numpy_pixelid(itk_Image_type):
    """Returns a ITK PixelID given a numpy array."""

# This is a Mapping from numpy array types to itk pixel types.
    _np_itk = {"UC":np.uint8,
               "US":np.uint16,
               "UI":np.uint32,
               "UL":np.uint64,
               "ULL":np.uint64,
               "SC":np.int8,
               "SS":np.int16,
               "SI":np.int32,
               "SL":np.int64,
               "SLL":np.int64,
               "F":np.float32,
               "D":np.float64,
               "PF2":np.float32,
               "PF3":np.float32,
                }
    import os
    if os.name == 'nt':
        _np_itk['UL'] = np.uint32
        _np_itk['SL'] = np.int32
    try:
        return _np_itk[itk_Image_type]
    except KeyError as e:
        raise e

class itkPyBufferICVF52(object):
    r"""Proxy of C++ itkPyBufferICVF52 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def _GetArrayViewFromImage(image):
        r"""
        _GetArrayViewFromImage(image) -> PyObject *

        Parameters
        ----------
        image: itkImageCVF52 *

        """
        return _itkPyBufferRTKPython.itkPyBufferICVF52__GetArrayViewFromImage(image)

    @staticmethod
    def _GetImageViewFromArray(arr, shape, numOfComponent):
        r"""
        _GetImageViewFromArray(arr, shape, numOfComponent) -> itkImageCVF52_Pointer const

        Parameters
        ----------
        arr: PyObject *
        shape: PyObject *
        numOfComponent: PyObject *

        """
        return _itkPyBufferRTKPython.itkPyBufferICVF52__GetImageViewFromArray(arr, shape, numOfComponent)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferICVF52
        __init__(self, arg0) -> itkPyBufferICVF52

        Parameters
        ----------
        arg0: itkPyBufferICVF52 const &

        """
        _itkPyBufferRTKPython.itkPyBufferICVF52_swiginit(self, _itkPyBufferRTKPython.new_itkPyBufferICVF52(*args))
    __swig_destroy__ = _itkPyBufferRTKPython.delete_itkPyBufferICVF52


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        import itk

        if image.GetBufferPointer() is None:
            return None

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetBufferedRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if image.GetNumberOfComponentsPerPixel() > 1 or isinstance(image, itk.VectorImage):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferICVF52._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """
        if image.GetBufferPointer() is None:
            return None

        arrayView = itkPyBufferICVF52.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferICVF52._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferICVF52._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferICVF52._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferICVF52.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferICVF52 in _itkPyBufferRTKPython:
_itkPyBufferRTKPython.itkPyBufferICVF52_swigregister(itkPyBufferICVF52)
class itkPyBufferICVF53(object):
    r"""Proxy of C++ itkPyBufferICVF53 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def _GetArrayViewFromImage(image):
        r"""
        _GetArrayViewFromImage(image) -> PyObject *

        Parameters
        ----------
        image: itkImageCVF53 *

        """
        return _itkPyBufferRTKPython.itkPyBufferICVF53__GetArrayViewFromImage(image)

    @staticmethod
    def _GetImageViewFromArray(arr, shape, numOfComponent):
        r"""
        _GetImageViewFromArray(arr, shape, numOfComponent) -> itkImageCVF53_Pointer const

        Parameters
        ----------
        arr: PyObject *
        shape: PyObject *
        numOfComponent: PyObject *

        """
        return _itkPyBufferRTKPython.itkPyBufferICVF53__GetImageViewFromArray(arr, shape, numOfComponent)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferICVF53
        __init__(self, arg0) -> itkPyBufferICVF53

        Parameters
        ----------
        arg0: itkPyBufferICVF53 const &

        """
        _itkPyBufferRTKPython.itkPyBufferICVF53_swiginit(self, _itkPyBufferRTKPython.new_itkPyBufferICVF53(*args))
    __swig_destroy__ = _itkPyBufferRTKPython.delete_itkPyBufferICVF53


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        import itk

        if image.GetBufferPointer() is None:
            return None

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetBufferedRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if image.GetNumberOfComponentsPerPixel() > 1 or isinstance(image, itk.VectorImage):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferICVF53._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """
        if image.GetBufferPointer() is None:
            return None

        arrayView = itkPyBufferICVF53.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferICVF53._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferICVF53._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferICVF53._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferICVF53.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferICVF53 in _itkPyBufferRTKPython:
_itkPyBufferRTKPython.itkPyBufferICVF53_swigregister(itkPyBufferICVF53)
class itkPyBufferICVF54(object):
    r"""Proxy of C++ itkPyBufferICVF54 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def _GetArrayViewFromImage(image):
        r"""
        _GetArrayViewFromImage(image) -> PyObject *

        Parameters
        ----------
        image: itkImageCVF54 *

        """
        return _itkPyBufferRTKPython.itkPyBufferICVF54__GetArrayViewFromImage(image)

    @staticmethod
    def _GetImageViewFromArray(arr, shape, numOfComponent):
        r"""
        _GetImageViewFromArray(arr, shape, numOfComponent) -> itkImageCVF54_Pointer const

        Parameters
        ----------
        arr: PyObject *
        shape: PyObject *
        numOfComponent: PyObject *

        """
        return _itkPyBufferRTKPython.itkPyBufferICVF54__GetImageViewFromArray(arr, shape, numOfComponent)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferICVF54
        __init__(self, arg0) -> itkPyBufferICVF54

        Parameters
        ----------
        arg0: itkPyBufferICVF54 const &

        """
        _itkPyBufferRTKPython.itkPyBufferICVF54_swiginit(self, _itkPyBufferRTKPython.new_itkPyBufferICVF54(*args))
    __swig_destroy__ = _itkPyBufferRTKPython.delete_itkPyBufferICVF54


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        import itk

        if image.GetBufferPointer() is None:
            return None

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetBufferedRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if image.GetNumberOfComponentsPerPixel() > 1 or isinstance(image, itk.VectorImage):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferICVF54._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """
        if image.GetBufferPointer() is None:
            return None

        arrayView = itkPyBufferICVF54.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferICVF54._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferICVF54._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferICVF54._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferICVF54.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferICVF54 in _itkPyBufferRTKPython:
_itkPyBufferRTKPython.itkPyBufferICVF54_swigregister(itkPyBufferICVF54)
class itkPyBufferID1(object):
    r"""Proxy of C++ itkPyBufferID1 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def _GetArrayViewFromImage(image):
        r"""
        _GetArrayViewFromImage(image) -> PyObject *

        Parameters
        ----------
        image: itkImageD1 *

        """
        return _itkPyBufferRTKPython.itkPyBufferID1__GetArrayViewFromImage(image)

    @staticmethod
    def _GetImageViewFromArray(arr, shape, numOfComponent):
        r"""
        _GetImageViewFromArray(arr, shape, numOfComponent) -> itkImageD1_Pointer const

        Parameters
        ----------
        arr: PyObject *
        shape: PyObject *
        numOfComponent: PyObject *

        """
        return _itkPyBufferRTKPython.itkPyBufferID1__GetImageViewFromArray(arr, shape, numOfComponent)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferID1
        __init__(self, arg0) -> itkPyBufferID1

        Parameters
        ----------
        arg0: itkPyBufferID1 const &

        """
        _itkPyBufferRTKPython.itkPyBufferID1_swiginit(self, _itkPyBufferRTKPython.new_itkPyBufferID1(*args))
    __swig_destroy__ = _itkPyBufferRTKPython.delete_itkPyBufferID1


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        import itk

        if image.GetBufferPointer() is None:
            return None

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetBufferedRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if image.GetNumberOfComponentsPerPixel() > 1 or isinstance(image, itk.VectorImage):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "D"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferID1._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """
        if image.GetBufferPointer() is None:
            return None

        arrayView = itkPyBufferID1.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferID1._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferID1._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferID1._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferID1.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferID1 in _itkPyBufferRTKPython:
_itkPyBufferRTKPython.itkPyBufferID1_swigregister(itkPyBufferID1)
class itkPyBufferIF1(object):
    r"""Proxy of C++ itkPyBufferIF1 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def _GetArrayViewFromImage(image):
        r"""
        _GetArrayViewFromImage(image) -> PyObject *

        Parameters
        ----------
        image: itkImageF1 *

        """
        return _itkPyBufferRTKPython.itkPyBufferIF1__GetArrayViewFromImage(image)

    @staticmethod
    def _GetImageViewFromArray(arr, shape, numOfComponent):
        r"""
        _GetImageViewFromArray(arr, shape, numOfComponent) -> itkImageF1_Pointer const

        Parameters
        ----------
        arr: PyObject *
        shape: PyObject *
        numOfComponent: PyObject *

        """
        return _itkPyBufferRTKPython.itkPyBufferIF1__GetImageViewFromArray(arr, shape, numOfComponent)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferIF1
        __init__(self, arg0) -> itkPyBufferIF1

        Parameters
        ----------
        arg0: itkPyBufferIF1 const &

        """
        _itkPyBufferRTKPython.itkPyBufferIF1_swiginit(self, _itkPyBufferRTKPython.new_itkPyBufferIF1(*args))
    __swig_destroy__ = _itkPyBufferRTKPython.delete_itkPyBufferIF1


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        import itk

        if image.GetBufferPointer() is None:
            return None

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetBufferedRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if image.GetNumberOfComponentsPerPixel() > 1 or isinstance(image, itk.VectorImage):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIF1._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """
        if image.GetBufferPointer() is None:
            return None

        arrayView = itkPyBufferIF1.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferIF1._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferIF1._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferIF1._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIF1.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIF1 in _itkPyBufferRTKPython:
_itkPyBufferRTKPython.itkPyBufferIF1_swigregister(itkPyBufferIF1)
class itkPyBufferIUC1(object):
    r"""Proxy of C++ itkPyBufferIUC1 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def _GetArrayViewFromImage(image):
        r"""
        _GetArrayViewFromImage(image) -> PyObject *

        Parameters
        ----------
        image: itkImageUC1 *

        """
        return _itkPyBufferRTKPython.itkPyBufferIUC1__GetArrayViewFromImage(image)

    @staticmethod
    def _GetImageViewFromArray(arr, shape, numOfComponent):
        r"""
        _GetImageViewFromArray(arr, shape, numOfComponent) -> itkImageUC1_Pointer const

        Parameters
        ----------
        arr: PyObject *
        shape: PyObject *
        numOfComponent: PyObject *

        """
        return _itkPyBufferRTKPython.itkPyBufferIUC1__GetImageViewFromArray(arr, shape, numOfComponent)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferIUC1
        __init__(self, arg0) -> itkPyBufferIUC1

        Parameters
        ----------
        arg0: itkPyBufferIUC1 const &

        """
        _itkPyBufferRTKPython.itkPyBufferIUC1_swiginit(self, _itkPyBufferRTKPython.new_itkPyBufferIUC1(*args))
    __swig_destroy__ = _itkPyBufferRTKPython.delete_itkPyBufferIUC1


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        import itk

        if image.GetBufferPointer() is None:
            return None

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetBufferedRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if image.GetNumberOfComponentsPerPixel() > 1 or isinstance(image, itk.VectorImage):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "UC"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIUC1._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """
        if image.GetBufferPointer() is None:
            return None

        arrayView = itkPyBufferIUC1.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferIUC1._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferIUC1._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferIUC1._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIUC1.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIUC1 in _itkPyBufferRTKPython:
_itkPyBufferRTKPython.itkPyBufferIUC1_swigregister(itkPyBufferIUC1)
class itkPyBufferIUS1(object):
    r"""Proxy of C++ itkPyBufferIUS1 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def _GetArrayViewFromImage(image):
        r"""
        _GetArrayViewFromImage(image) -> PyObject *

        Parameters
        ----------
        image: itkImageUS1 *

        """
        return _itkPyBufferRTKPython.itkPyBufferIUS1__GetArrayViewFromImage(image)

    @staticmethod
    def _GetImageViewFromArray(arr, shape, numOfComponent):
        r"""
        _GetImageViewFromArray(arr, shape, numOfComponent) -> itkImageUS1_Pointer const

        Parameters
        ----------
        arr: PyObject *
        shape: PyObject *
        numOfComponent: PyObject *

        """
        return _itkPyBufferRTKPython.itkPyBufferIUS1__GetImageViewFromArray(arr, shape, numOfComponent)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferIUS1
        __init__(self, arg0) -> itkPyBufferIUS1

        Parameters
        ----------
        arg0: itkPyBufferIUS1 const &

        """
        _itkPyBufferRTKPython.itkPyBufferIUS1_swiginit(self, _itkPyBufferRTKPython.new_itkPyBufferIUS1(*args))
    __swig_destroy__ = _itkPyBufferRTKPython.delete_itkPyBufferIUS1


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        import itk

        if image.GetBufferPointer() is None:
            return None

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetBufferedRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if image.GetNumberOfComponentsPerPixel() > 1 or isinstance(image, itk.VectorImage):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "US"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIUS1._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """
        if image.GetBufferPointer() is None:
            return None

        arrayView = itkPyBufferIUS1.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferIUS1._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferIUS1._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferIUS1._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIUS1.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIUS1 in _itkPyBufferRTKPython:
_itkPyBufferRTKPython.itkPyBufferIUS1_swigregister(itkPyBufferIUS1)
class itkPyBufferIVF52(object):
    r"""Proxy of C++ itkPyBufferIVF52 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def _GetArrayViewFromImage(image):
        r"""
        _GetArrayViewFromImage(image) -> PyObject *

        Parameters
        ----------
        image: itkImageVF52 *

        """
        return _itkPyBufferRTKPython.itkPyBufferIVF52__GetArrayViewFromImage(image)

    @staticmethod
    def _GetImageViewFromArray(arr, shape, numOfComponent):
        r"""
        _GetImageViewFromArray(arr, shape, numOfComponent) -> itkImageVF52_Pointer const

        Parameters
        ----------
        arr: PyObject *
        shape: PyObject *
        numOfComponent: PyObject *

        """
        return _itkPyBufferRTKPython.itkPyBufferIVF52__GetImageViewFromArray(arr, shape, numOfComponent)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferIVF52
        __init__(self, arg0) -> itkPyBufferIVF52

        Parameters
        ----------
        arg0: itkPyBufferIVF52 const &

        """
        _itkPyBufferRTKPython.itkPyBufferIVF52_swiginit(self, _itkPyBufferRTKPython.new_itkPyBufferIVF52(*args))
    __swig_destroy__ = _itkPyBufferRTKPython.delete_itkPyBufferIVF52


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        import itk

        if image.GetBufferPointer() is None:
            return None

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetBufferedRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if image.GetNumberOfComponentsPerPixel() > 1 or isinstance(image, itk.VectorImage):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIVF52._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """
        if image.GetBufferPointer() is None:
            return None

        arrayView = itkPyBufferIVF52.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferIVF52._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferIVF52._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferIVF52._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIVF52.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIVF52 in _itkPyBufferRTKPython:
_itkPyBufferRTKPython.itkPyBufferIVF52_swigregister(itkPyBufferIVF52)
class itkPyBufferIVF53(object):
    r"""Proxy of C++ itkPyBufferIVF53 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def _GetArrayViewFromImage(image):
        r"""
        _GetArrayViewFromImage(image) -> PyObject *

        Parameters
        ----------
        image: itkImageVF53 *

        """
        return _itkPyBufferRTKPython.itkPyBufferIVF53__GetArrayViewFromImage(image)

    @staticmethod
    def _GetImageViewFromArray(arr, shape, numOfComponent):
        r"""
        _GetImageViewFromArray(arr, shape, numOfComponent) -> itkImageVF53_Pointer const

        Parameters
        ----------
        arr: PyObject *
        shape: PyObject *
        numOfComponent: PyObject *

        """
        return _itkPyBufferRTKPython.itkPyBufferIVF53__GetImageViewFromArray(arr, shape, numOfComponent)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferIVF53
        __init__(self, arg0) -> itkPyBufferIVF53

        Parameters
        ----------
        arg0: itkPyBufferIVF53 const &

        """
        _itkPyBufferRTKPython.itkPyBufferIVF53_swiginit(self, _itkPyBufferRTKPython.new_itkPyBufferIVF53(*args))
    __swig_destroy__ = _itkPyBufferRTKPython.delete_itkPyBufferIVF53


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        import itk

        if image.GetBufferPointer() is None:
            return None

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetBufferedRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if image.GetNumberOfComponentsPerPixel() > 1 or isinstance(image, itk.VectorImage):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIVF53._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """
        if image.GetBufferPointer() is None:
            return None

        arrayView = itkPyBufferIVF53.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferIVF53._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferIVF53._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferIVF53._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIVF53.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIVF53 in _itkPyBufferRTKPython:
_itkPyBufferRTKPython.itkPyBufferIVF53_swigregister(itkPyBufferIVF53)
class itkPyBufferIVF54(object):
    r"""Proxy of C++ itkPyBufferIVF54 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def _GetArrayViewFromImage(image):
        r"""
        _GetArrayViewFromImage(image) -> PyObject *

        Parameters
        ----------
        image: itkImageVF54 *

        """
        return _itkPyBufferRTKPython.itkPyBufferIVF54__GetArrayViewFromImage(image)

    @staticmethod
    def _GetImageViewFromArray(arr, shape, numOfComponent):
        r"""
        _GetImageViewFromArray(arr, shape, numOfComponent) -> itkImageVF54_Pointer const

        Parameters
        ----------
        arr: PyObject *
        shape: PyObject *
        numOfComponent: PyObject *

        """
        return _itkPyBufferRTKPython.itkPyBufferIVF54__GetImageViewFromArray(arr, shape, numOfComponent)

    def __init__(self, *args):
        r"""
        __init__(self) -> itkPyBufferIVF54
        __init__(self, arg0) -> itkPyBufferIVF54

        Parameters
        ----------
        arg0: itkPyBufferIVF54 const &

        """
        _itkPyBufferRTKPython.itkPyBufferIVF54_swiginit(self, _itkPyBufferRTKPython.new_itkPyBufferIVF54(*args))
    __swig_destroy__ = _itkPyBufferRTKPython.delete_itkPyBufferIVF54


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """
        import itk

        if image.GetBufferPointer() is None:
            return None

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetBufferedRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if image.GetNumberOfComponentsPerPixel() > 1 or isinstance(image, itk.VectorImage):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIVF54._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """
        if image.GetBufferPointer() is None:
            return None

        arrayView = itkPyBufferIVF54.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False, need_contiguous=True):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.

        By default, a warning is issued if this function is called on a non-contiguous
        array, since a copy is performed and care must be taken to keep a reference
        to the copied array. This warning can be suppressed with need_contiguous=False
        """

        assert ndarr.ndim in (1, 2, 3, 4, 5), \
            "Only arrays of 1, 2, 3, 4 or 5 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)
            if need_contiguous:
                import warnings
                msg = """Because the input array was not contiguous, the returned
                image is not a view of the array passed to this function. Instead,
                it is a view of the member "base" of the returned image! If that
                member is ever garbage collected, this view becomes invalid."""
                warnings.warn(msg)

        if is_vector:
            if ndarr.flags['C_CONTIGUOUS']:
                imgview = itkPyBufferIVF54._GetImageViewFromArray(ndarr, ndarr.shape[-2::-1], ndarr.shape[-1])
            else:
                imgview = itkPyBufferIVF54._GetImageViewFromArray(ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0])
        else:
            imgview = itkPyBufferIVF54._GetImageViewFromArray(ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIVF54.GetImageViewFromArray(ndarr, is_vector, need_contiguous=False)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIVF54 in _itkPyBufferRTKPython:
_itkPyBufferRTKPython.itkPyBufferIVF54_swigregister(itkPyBufferIVF54)

