"""Individual ManagedCredentialType plugin tests."""

import configparser
import json
from dataclasses import dataclass
from pathlib import Path
from types import MappingProxyType
from typing import Generic, TypeVar

import pytest
from pytest_subtests import SubTests

from awx_plugins.interfaces._temporary_private_api import (  # noqa: WPS436
    EnvVarsType,
    ManagedCredentialType,
)
from awx_plugins.interfaces._temporary_private_container_api import (
    CONTAINER_ROOT,
)
from awx_plugins.interfaces._temporary_private_credential_api import (  # noqa: WPS436
    Credential,
    CredentialInputType,
)
from awx_plugins.interfaces._temporary_private_inject_api import (  # noqa: WPS436
    HIDDEN_PASSWORD,
    inject_credential,
)

import yaml

from awx_plugins.credentials.plugins import (  # noqa: WPS235
    aws,
    azure_rm,
    gce,
    kubernetes_bearer_token as k8s,
    net,
    openstack,
    rhv,
    terraform,
    vmware,
)


EXAMPLE_PRIVATE_KEY = 'foo'
HCL_S3_FILE = """
backend "s3" {
    bucket = "s3_sample_bucket"
    key    = "/tf_state/"
    region = "us-east-1"
}
"""
HCL_GCS_FILE = """
backend "gcs" {
    bucket = "gce_storage"
}
"""


def get_gce_creds() -> dict[str, str]:
    """GCE plugin expected backend credentials.

    This is a function instead of a module variable to work around
    WPS407. MappingProxy did not work to fix WPS407 due to the type not
    being json serializable errors during pytest fixture gathering.

    :returns: sample gce backend credential data.
    """
    return {
        'type': 'service_account',
        'project_id': 'sample',
        'private_key_id': 'eeeeeeeeeeeeeeeeeeeeeeeeeee',
        'private_key': """-----BEGIN PRIVATE KEY-----
    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
    -----END PRIVATE KEY-----
    """,
        'client_email': 'sample@sample.iam.gserviceaccount.com',
        'client_id': '6123456789',
        'auth_uri': 'https://accounts.google.com/o/oauth2/auth',
        'token_uri': 'https://oauth2.googleapis.com/token',
        'auth_provider_x509_cert_url': 'https://www.googleapis.com/oauth2/v1/certs',
        'client_x509_cert_url': 'https://www.googleapis.com/robot/v1/metadata/x509/cloud-content-robot%40sample.iam.gserviceaccount.com',  # noqa: B950, WPS323
    }


# pylint: disable=redefined-outer-name
def to_host_path(path: str, private_data_dir: str) -> str:
    """Convert container path to host path.

    Given a path inside of the EE container, this gives the absolute
    path on the host machine within the private_data_dir.

    :param path: container path
    :param private_data_dir: runtime directory
    :return: Absolute path of private_data_dir on the container host
    """
    return path.replace(CONTAINER_ROOT, private_data_dir, 1)


@pytest.fixture
def private_data_dir(tmp_path: Path) -> Path:
    """Simulate ansible-runner directory backed runtime parameters.

    :yield: runtime directory
    """
    private_data_directory = tmp_path / 'aws-private-data-dir'
    (private_data_directory / 'env').mkdir(parents=True)
    (private_data_directory / 'inventory').mkdir()
    return private_data_directory


ExpectedDataType = TypeVar('ExpectedDataType')
IniEntryDataType = dict[str, dict[str, object]]


@dataclass(frozen=True)
class BaseEnvFile(Generic[ExpectedDataType]):
    """Base class for file type."""

    env_key: str
    expected_data: ExpectedDataType

    def check(
        self: 'BaseEnvFile[ExpectedDataType]',
        env: EnvVarsType,
        private_data_dir: str,
    ) -> None:
        """Override to ensure file contains expected data.

        :param env: environment to get the filename from
        :param private_data_dir: directory to read the file from
        :returns: None
        """
        raise NotImplementedError('Define me.')


class JsonEnvFile(BaseEnvFile[dict[str, str] | MappingProxyType[str, str]]):
    """Handle json files generated by credentials."""

    def check(
        self: 'JsonEnvFile',
        env: EnvVarsType,
        private_data_dir: str,
    ) -> None:
        """Ensure the json file contains expected data.

        :param env: environment to get the filename from
        :param private_data_dir: directory to read the file from
        :returns: None
        """
        with open(
            to_host_path(str(env[self.env_key]), private_data_dir),
        ) as fh:
            assert self.expected_data.items() == json.load(fh).items()


class StringEnvFile(BaseEnvFile[str]):
    """Handle basic non-structured files generated by credentials."""

    def check(
        self: 'StringEnvFile',
        env: EnvVarsType,
        private_data_dir: str,
    ) -> None:
        """Ensure file contains expected data.

        :param env: environment to get the filename from
        :param private_data_dir: directory to read the file from
        :returns: None
        """
        with open(
            to_host_path(str(env[self.env_key]), private_data_dir),
        ) as fh:
            assert self.expected_data == fh.read()


class IniEnvFile(BaseEnvFile[dict[str, dict[str, str]]]):
    """Handle ini files generated by credentials."""

    def check(
        self: 'IniEnvFile',
        env: EnvVarsType,
        private_data_dir: str,
    ) -> None:
        """Ensure ini file contains expected data.

        :param env: environment to get the filename from
        :param private_data_dir: directory to read the file from
        :returns: None
        """
        config = configparser.ConfigParser()
        config.read(to_host_path(str(env[self.env_key]), private_data_dir))
        for ini_section, expected_kv in self.expected_data.items():
            for expected_k, expected_v in expected_kv.items():
                assert config.get(ini_section, expected_k) == expected_v


class YamlEnvFile(BaseEnvFile[dict[str, IniEntryDataType]]):
    """Handle yaml files generated by credentials."""

    def check(
        self: 'YamlEnvFile',
        env: EnvVarsType,
        private_data_dir: str,
    ) -> None:
        """Ensure yaml file contains expected data.

        :param env: environment to get the filename from
        :param private_data_dir: directory to read the file from
        :returns: None
        """
        with open(
            to_host_path(str(env[self.env_key]), private_data_dir),
        ) as fh:
            assert self.expected_data.items() == yaml.safe_load(fh).items()


@pytest.mark.parametrize(
    (
        'cred_type',
        'inputs',
        'expected_env',
        'expected_safe_env',
        'expected_data_file',
    ),
    (
        pytest.param(
            aws,
            {
                'username': 'naomi',
                'password': 'naomis-secret',
                'security_token': 'token',
            },
            {
                'AWS_ACCESS_KEY_ID': 'naomi',
                'AWS_SECRET_ACCESS_KEY': 'naomis-secret',
                'AWS_SECURITY_TOKEN': 'token',
            },
            {'AWS_SECRET_ACCESS_KEY': HIDDEN_PASSWORD},
            [],
            id='aws',
        ),
        pytest.param(
            k8s,
            {
                'host': 'https://jill.example.org/',
                'bearer_token': 'jills-token',
            },
            {
                'K8S_AUTH_HOST': 'https://jill.example.org/',
                'K8S_AUTH_API_KEY': 'jills-token',
                'K8S_AUTH_VERIFY_SSL': 'False',
            },
            {'K8S_AUTH_API_KEY': HIDDEN_PASSWORD},
            [],
            id='k8s-verify-ssl-false',
        ),
        pytest.param(
            k8s,
            {
                'host': 'https://wilber.example.org/',
                'bearer_token': 'wilbers-token',
                'verify_ssl': True,
                'ssl_ca_cert': 'CERTDATA',
            },
            {
                'K8S_AUTH_HOST': 'https://wilber.example.org/',
                'K8S_AUTH_API_KEY': 'wilbers-token',
                'K8S_AUTH_VERIFY_SSL': 'True',
            },
            {'K8S_AUTH_API_KEY': HIDDEN_PASSWORD},
            [StringEnvFile('K8S_AUTH_SSL_CA_CERT', 'CERTDATA')],
            id='k8s-verify-ssl-true',
        ),
        pytest.param(
            gce,
            {
                'username': 'tony',
                'project': 'tonys-project',
                'ssh_key_data': EXAMPLE_PRIVATE_KEY,
            },
            {},
            {},
            [
                JsonEnvFile(
                    'GCE_CREDENTIALS_FILE_PATH',
                    {
                        'type': 'service_account',
                        'private_key': EXAMPLE_PRIVATE_KEY,
                        'client_email': 'tony',
                        'project_id': 'tonys-project',
                        'token_uri': 'https://oauth2.googleapis.com/token',
                    },
                ),
            ],
            id='gce',
        ),
        pytest.param(
            azure_rm,
            {
                'client': 'susie-client',
                'secret': 'susies-secret',
                'tenant': 'susies-tenant',
                'subscription': 'susies-subscription',
            },
            {
                'AZURE_CLIENT_ID': 'susie-client',
                'AZURE_SECRET': 'susies-secret',
                'AZURE_TENANT': 'susies-tenant',
                'AZURE_SUBSCRIPTION_ID': 'susies-subscription',
            },
            {'AZURE_SECRET': HIDDEN_PASSWORD},
            [],
            id='azure-tenant',
        ),
        pytest.param(
            azure_rm,
            {
                'subscription': 'bobs-subscription',
                'username': 'bob',
                'password': 'bobs-secret',
                'cloud_environment': 'bobs-cloud',
            },
            {
                'AZURE_AD_USER': 'bob',
                'AZURE_PASSWORD': 'bobs-secret',
                'AZURE_SUBSCRIPTION_ID': 'bobs-subscription',
                'AZURE_CLOUD_ENVIRONMENT': 'bobs-cloud',
            },
            {'AZURE_PASSWORD': HIDDEN_PASSWORD},
            [],
            id='azure-password',
        ),
        pytest.param(
            vmware,
            {
                'username': 'sam',
                'password': 'sams-secret',
                'host': 'https://sam.example.org',
            },
            {
                'VMWARE_USER': 'sam',
                'VMWARE_PASSWORD': 'sams-secret',
                'VMWARE_HOST': 'https://sam.example.org',
                'VMWARE_VALIDATE_CERTS': 'True',
            },
            {'VMWARE_PASSWORD': HIDDEN_PASSWORD},
            [],
            id='vmware',
        ),
        pytest.param(
            openstack,
            {
                'username': 'newman',
                'password': 'newmans-secret',
                'project': 'newmans-project',
                'host': 'https://newman.example.org',
            },
            {},
            {},
            [
                YamlEnvFile(
                    'OS_CLIENT_CONFIG_FILE',
                    {
                        'clouds': {
                            'devstack': {
                                'auth': {
                                    'auth_url': 'https://newman.example.org',
                                    'password': 'newmans-secret',
                                    'project_name': 'newmans-project',
                                    'username': 'newman',
                                },
                                'verify': True,
                            },
                        },
                    },
                ),
            ],
            id='openstack',
        ),
        pytest.param(
            rhv,
            {
                'host': 'rick.example.org',
                'username': 'rick',
                'password': 'ricks-pass',
            },
            {},
            {},
            [
                IniEnvFile(
                    'OVIRT_INI_PATH',
                    {
                        'ovirt': {
                            'ovirt_url': 'rick.example.org',
                            'ovirt_username': 'rick',
                            'ovirt_password': 'ricks-pass',
                        },
                    },
                ),
            ],
            id='rhv',
        ),
        pytest.param(
            rhv,
            {
                'host': 'rick.example.org',
                'username': 'rick',
                'password': 'ricks-pass',
                'ca_file': '/path/to/ricks/ca-file',
            },
            {},
            {},
            [
                IniEnvFile(
                    'OVIRT_INI_PATH',
                    {
                        'ovirt': {
                            'ovirt_url': 'rick.example.org',
                            'ovirt_username': 'rick',
                            'ovirt_password': 'ricks-pass',
                            'ovirt_ca_file': '/path/to/ricks/ca-file',
                        },
                    },
                ),
            ],
            id='rhv-ca-file',
        ),
        pytest.param(
            terraform,
            {'configuration': HCL_S3_FILE},
            {},
            {},
            [StringEnvFile('TF_BACKEND_CONFIG_FILE', HCL_S3_FILE)],
            id='terraform',
        ),
        pytest.param(
            terraform,
            {'configuration': HCL_S3_FILE},
            {},
            {},
            [StringEnvFile('TF_BACKEND_CONFIG_FILE', HCL_S3_FILE)],
            id='terraform-s3',
        ),
        pytest.param(
            terraform,
            {
                'configuration': HCL_GCS_FILE,
                'gce_credentials': json.dumps(get_gce_creds()),
            },
            {},
            {},
            [
                StringEnvFile('TF_BACKEND_CONFIG_FILE', HCL_GCS_FILE),
                JsonEnvFile('GOOGLE_BACKEND_CREDENTIALS', get_gce_creds()),
            ],
            id='terraform-gcs',
        ),
        pytest.param(
            net,
            {
                'username': 'froto',
                'password': 'froto-pass',
                'ssh_key_data': EXAMPLE_PRIVATE_KEY,
                'authorize_password': 'frotos-authorize-pass',
                'authorize': True,
            },
            {
                'ANSIBLE_NET_USERNAME': 'froto',
                'ANSIBLE_NET_PASSWORD': 'froto-pass',
                'ANSIBLE_NET_AUTHORIZE': '1',
                'ANSIBLE_NET_AUTH_PASS': 'frotos-authorize-pass',
            },
            {'ANSIBLE_NET_PASSWORD': HIDDEN_PASSWORD},
            [StringEnvFile('ANSIBLE_NET_SSH_KEYFILE', EXAMPLE_PRIVATE_KEY)],
            id='net-authorize',
            marks=pytest.mark.xfail(reason='net plugin lives in AWX.'),
        ),
        pytest.param(
            net,
            {
                'username': 'shire',
                'password': 'shires-pass',
                'ssh_key_data': EXAMPLE_PRIVATE_KEY,
                'authorize_password': 'shires-authorize-pass',
                'authorize': False,
            },
            {
                'ANSIBLE_NET_USERNAME': 'froto',
                'ANSIBLE_NET_PASSWORD': 'frotos-pass',
                'ANSIBLE_NET_AUTHORIZE': '0',
            },
            {'ANSIBLE_NET_PASSWORD': HIDDEN_PASSWORD},
            [StringEnvFile('ANSIBLE_NET_SSH_KEYFILE', EXAMPLE_PRIVATE_KEY)],
            id='net-authorize-false',
            marks=pytest.mark.xfail(reason='net plugin lives in AWX.'),
        ),
        pytest.param(
            net,
            {
                'username': 'bilbo',
                'password': 'bilbos-pass',
                'ssh_key_data': EXAMPLE_PRIVATE_KEY,
                'authorize_password': 'bilbos-authorize-pass',
                'authorize': None,
            },
            {
                'ANSIBLE_NET_USERNAME': 'bilbo',
                'ANSIBLE_NET_PASSWORD': 'bilbos-pass',
                'ANSIBLE_NET_AUTHORIZE': '0',
            },
            {'ANSIBLE_NET_PASSWORD': HIDDEN_PASSWORD},
            [StringEnvFile('ANSIBLE_NET_SSH_KEYFILE', EXAMPLE_PRIVATE_KEY)],
            id='net-authorize-none',
            marks=pytest.mark.xfail(reason='net plugin lives in AWX.'),
        ),
    ),
)
# FIXME: Type ignore below due to ManagedCredentialType type not found.
# pylint: disable-next=too-many-arguments, too-many-positional-arguments
def test_credential_plugins(  # type: ignore[no-any-unimported]  # noqa: WPS211
    cred_type: ManagedCredentialType,
    inputs: CredentialInputType,
    expected_env: dict[str, str],
    expected_safe_env: dict[str, str],
    expected_data_file: list[BaseEnvFile[ExpectedDataType]],
    private_data_dir: Path,
    subtests: SubTests,
) -> None:
    """Check that the aws sts token credentials are injected."""
    env: EnvVarsType = {}
    safe_env: EnvVarsType = {}
    inject_credential(
        cred_type,
        Credential(inputs=inputs),
        env,
        safe_env,
        [],
        str(private_data_dir),
    )
    assert expected_env.items() <= env.items()
    assert expected_safe_env.items() <= safe_env.items()

    for env_file_type in expected_data_file:
        with subtests.test(env_file_type.__class__.__name__):
            env_file_type.check(env, str(private_data_dir))
