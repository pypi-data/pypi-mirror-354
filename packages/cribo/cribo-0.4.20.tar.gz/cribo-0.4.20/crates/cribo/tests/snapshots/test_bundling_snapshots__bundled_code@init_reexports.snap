---
source: crates/cribo/tests/test_bundling_snapshots.rs
---
#!/usr/bin/env python3
# Generated by Cribo - Python Source Bundler
# https://github.com/ophidiarium/cribo

# Preserved imports
import os

# ─ Module: mypackage.data_processor ─
import types
mypackage = types.ModuleType('mypackage')
mypackage.data_processor = types.ModuleType('mypackage.data_processor')
exec('"""Data processing module."""\ndef process_data(data):\n    """Process the input data."""\n    processed = data.copy()\n    processed["processed"] = True\n    return processed', mypackage.data_processor.__dict__)

# ─ Module: mypackage.formatter ─
import types
mypackage.formatter = types.ModuleType('mypackage.formatter')
exec('"""Data formatting module."""\ndef format_data(data):\n    """Format the processed data."""\n    return f"Formatted: {data}"', mypackage.formatter.__dict__)

# ─ Module: mypackage.config ─
import types
mypackage.config = types.ModuleType('mypackage.config')
exec('"""Configuration module."""\nimport os\nclass Config:\n    """Configuration class."""\n\n    def __init__(self):\n        self.DEBUG = os.environ.get("DEBUG", "false").lower() == "true"\n        self.LOG_LEVEL = os.environ.get("LOG_LEVEL", "INFO")\nconfig = Config()', globals(), mypackage.config.__dict__)

# ─ Module: mypackage.utils.helper ─
import types
mypackage.utils = types.ModuleType('mypackage.utils')
mypackage.utils.helper = types.ModuleType('mypackage.utils.helper')
exec('"""Helper utilities."""\ndef helper_function(data):\n    """Helper function for processing data."""\n    return f"Helped: {data}"', mypackage.utils.helper.__dict__)

# ─ Module: mypackage.utils.constants ─
import types
mypackage.utils.constants = types.ModuleType('mypackage.utils.constants')
exec('"""Constants module."""\nMAX_ITEMS = 100\nDEFAULT_VALUE = "default"', mypackage.utils.constants.__dict__)

# ─ Module: mypackage.utils ─
exec('global helper_function, MAX_ITEMS, DEFAULT_VALUE\nhelper_function = mypackage.utils.helper.helper_function\nMAX_ITEMS = mypackage.utils.constants.MAX_ITEMS\nDEFAULT_VALUE = mypackage.utils.constants.DEFAULT_VALUE\n"""Utils subpackage with re-exports."""\n__all__ = ["helper_function", "MAX_ITEMS", "DEFAULT_VALUE"]\nlocals()[\'helper_function\'] = helper_function\nlocals()[\'MAX_ITEMS\'] = MAX_ITEMS\nlocals()[\'DEFAULT_VALUE\'] = DEFAULT_VALUE', {**globals(), 'mypackage': mypackage}, mypackage.utils.__dict__)

# ─ Module: mypackage ─
exec('global process_data, format_data, config, helper_function, DEBUG_MODE\nprocess_data = mypackage.data_processor.process_data\nformat_data = mypackage.formatter.format_data\nconfig = mypackage.config.config\nhelper_function = mypackage.utils.helper_function\n"""\\nPackage initialization with re-exports.\\n\\nThis __init__.py demonstrates the pattern where imports are made but not directly used\\nwithin this file - they are re-exports for the package interface.\\nThese imports should NOT be stripped as unused, even though they don\'t appear\\nto be used within this file itself.\\n"""\n__version__ = "1.0.0"\n__all__ = ["process_data", "format_data", "config", "helper_function", "__version__"]\nDEBUG_MODE = config.DEBUG\nlocals()[\'process_data\'] = process_data\nlocals()[\'format_data\'] = format_data\nlocals()[\'config\'] = config\nlocals()[\'helper_function\'] = helper_function\nlocals()[\'DEBUG_MODE\'] = DEBUG_MODE', {**globals(), 'mypackage': mypackage}, mypackage.__dict__)

# ─ Entry Module: main ─
format_data = mypackage.format_data
process_data = mypackage.process_data
config = mypackage.config
helper_function = mypackage.utils.helper_function
'''\nTest script demonstrating __init__.py re-export preservation.\n\nThis fixture tests that imports in __init__.py files are preserved even if they\nappear "unused" within that file, as they are typically re-exports for the package interface.\n'''
def main():
    """Main function demonstrating usage of re-exported functions."""
    data = {"name": "test", "value": 42}
    processed = process_data(data)
    formatted = format_data(processed)
    result = helper_function(formatted)
    if config.DEBUG:
        print(f"Debug: {result}")
    else:
        print(result)
if __name__ == "__main__":
    main()
