use std::env;
use std::process::Command;

/// Helper function to get the path to a fixture file
fn get_fixture_path(relative_path: &str) -> String {
    let cwd = env::current_dir().expect("Failed to get current directory");

    // Test execution directory is /workspace/crates/cribo, but fixtures are at /workspace/crates/cribo/tests/fixtures
    let test_fixture_path = cwd.join("tests/fixtures").join(relative_path);

    test_fixture_path.to_string_lossy().to_string()
}

#[test]
fn test_stdout_flag_help() {
    // Test that the help text shows the correct stdout flag description
    let output = Command::new("cargo")
        .args(["run", "--bin", "cribo", "--", "--help"])
        .output()
        .expect("Failed to execute command");

    let stdout = String::from_utf8_lossy(&output.stdout);
    assert!(stdout.contains("--stdout"));
    assert!(stdout.contains("Output bundled code to stdout instead of a file"));
}

#[test]
fn test_stdout_conflicts_with_output() {
    // Test that --stdout and --output are mutually exclusive
    let output = Command::new("cargo")
        .args([
            "run",
            "--bin",
            "cribo",
            "--",
            "--entry",
            "nonexistent.py",
            "--output",
            "output.py",
            "--stdout",
        ])
        .output()
        .expect("Failed to execute command");

    assert!(!output.status.success());
    let stderr = String::from_utf8_lossy(&output.stderr);
    assert!(stderr.contains("cannot be used with"));
}

#[test]
fn test_missing_output_and_stdout_flags() {
    // Test that either --output or --stdout must be specified
    let output = Command::new("cargo")
        .args(["run", "--bin", "cribo", "--", "--entry", "nonexistent.py"])
        .output()
        .expect("Failed to execute command");

    assert!(!output.status.success());
    let stderr = String::from_utf8_lossy(&output.stderr);
    assert!(stderr.contains("Either --output or --stdout must be specified"));
}

#[test]
fn test_stdout_bundling_functionality() {
    // Test actual bundling to stdout with a simple project
    let output = Command::new("cargo")
        .args([
            "run",
            "--bin",
            "cribo",
            "--",
            "--entry",
            &get_fixture_path("simple_project/main.py"),
            "--stdout",
        ])
        .output()
        .expect("Failed to execute command");

    // Should succeed
    assert!(
        output.status.success(),
        "Command failed: {}",
        String::from_utf8_lossy(&output.stderr)
    );

    let stdout = String::from_utf8_lossy(&output.stdout);

    // Check that we got bundled Python code
    assert!(stdout.contains("#!/usr/bin/env python3"));
    assert!(stdout.contains("# Generated by Cribo - Python Source Bundler"));
    assert!(stdout.contains("def main():"));
    assert!(stdout.contains("if __name__ == \"__main__\":"));

    // Ensure log messages went to stderr, not stdout
    let stderr = String::from_utf8_lossy(&output.stderr);
    assert!(stderr.contains("WARN") || stderr.is_empty()); // May have warnings but no errors

    // Stdout should not contain log messages
    assert!(!stdout.contains("INFO"));
    assert!(!stdout.contains("WARN"));
    assert!(!stdout.contains("ERROR"));
}

#[test]
fn test_stdout_with_verbose_separation() {
    // Test that verbose logging goes to stderr while code goes to stdout
    let output = Command::new("cargo")
        .args([
            "run",
            "--bin",
            "cribo",
            "--",
            "--entry",
            &get_fixture_path("simple_project/main.py"),
            "--stdout",
            "-v",
        ])
        .output()
        .expect("Failed to execute command");

    assert!(output.status.success());

    let stdout = String::from_utf8_lossy(&output.stdout);
    let stderr = String::from_utf8_lossy(&output.stderr);

    // Stdout should only contain Python code
    assert!(stdout.contains("#!/usr/bin/env python3"));
    assert!(!stdout.contains("INFO"));
    assert!(!stdout.contains("Starting Cribo"));

    // Stderr should contain log messages
    assert!(stderr.contains("INFO") || stderr.contains("WARN"));
}

#[test]
fn test_stdout_with_requirements() {
    // Test stdout mode with requirements generation
    let output = Command::new("cargo")
        .args([
            "run",
            "--bin",
            "cribo",
            "--",
            "--entry",
            &get_fixture_path("simple_project/main.py"),
            "--stdout",
            "--emit-requirements",
        ])
        .output()
        .expect("Failed to execute command");

    assert!(output.status.success());

    let stdout = String::from_utf8_lossy(&output.stdout);

    // Should still get bundled code on stdout
    assert!(stdout.contains("#!/usr/bin/env python3"));
    assert!(stdout.contains("def main():"));

    // Requirements should be written to current directory (requirements.txt)
    // Verify that requirements generation is acknowledged in stderr
    let stderr = String::from_utf8_lossy(&output.stderr);
    // Should contain some indication of requirements processing
    assert!(
        stderr.contains("requirements") || stderr.contains("Requirements") || stderr.is_empty()
    );
}

#[test]
fn test_stdout_mode_preserves_bundled_structure() {
    // Test that stdout mode produces the same bundled structure as file mode

    // First, get stdout output
    let stdout_output = Command::new("cargo")
        .args([
            "run",
            "--bin",
            "cribo",
            "--",
            "--entry",
            &get_fixture_path("simple_project/main.py"),
            "--stdout",
        ])
        .output()
        .expect("Failed to execute stdout command");

    assert!(stdout_output.status.success());
    let stdout_content = String::from_utf8_lossy(&stdout_output.stdout);

    // Verify it contains expected module structure
    assert!(stdout_content.contains("# ─ Module: utils.helpers ─"));
    assert!(stdout_content.contains("# ─ Module: models.user ─"));
    assert!(stdout_content.contains("# ─ Entry Module: main ─"));

    // Verify it contains the actual implementation
    assert!(stdout_content.contains("def greet(name: str)"));
    assert!(stdout_content.contains("class User:"));
    assert!(stdout_content.contains("user = User(\"Alice\", 30)"));
}

#[test]
fn test_stdout_error_handling() {
    // Test that errors are properly reported to stderr when using stdout mode
    let output = Command::new("cargo")
        .args([
            "run",
            "--bin",
            "cribo",
            "--",
            "--entry",
            "nonexistent_file.py",
            "--stdout",
        ])
        .output()
        .expect("Failed to execute command");

    // Should fail
    assert!(!output.status.success());

    let stderr = String::from_utf8_lossy(&output.stderr);
    let stdout = String::from_utf8_lossy(&output.stdout);

    // Error should go to stderr
    assert!(stderr.contains("Error") || stderr.contains("Failed"));

    // Stdout should be empty or minimal
    assert!(stdout.is_empty() || stdout.len() < 100);
}
