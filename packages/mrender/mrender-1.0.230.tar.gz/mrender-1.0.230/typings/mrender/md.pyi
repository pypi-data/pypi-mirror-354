from _typeshed import Incomplete
from lxml.etree import ElementBase as ElementBase, HTML as HTML
from lxml.html import document_fromstring as document_fromstring
from markdownify import markdownify as markdownify
from pathlib import Path
from rich.live import Live
from rich.markdown import Markdown as RichMarkdown
from rich.text import Text
from types import ModuleType
from typing_extensions import Any, Self, TypeVar

logger: Incomplete

def html(html: str, ensure_head_body: bool = True, **kw) -> ElementBase: ...

class MarkdownStream:
    live: Live | None
    when: int
    min_delay: float
    live_window: int
    printed: Incomplete
    mdargs: Incomplete
    def __init__(self, mdargs: Incomplete | None = None) -> None: ...
    def __del__(self) -> None: ...
    def update(self, text, final: bool = False) -> None: ...

def link_fp(line: str, fn: str | Path, lineno: int, render: bool = True) -> Text | str: ...

class Markdown:
    data: Incomplete
    mdargs: Incomplete
    style: Incomplete
    console: Incomplete
    min_delay: Incomplete
    live_window: Incomplete
    last_update_time: Incomplete
    printed_lines: Incomplete
    def __init__(self, data: Incomplete | None = None, mdargs: Incomplete | None = None, style: str = 'default', save: Incomplete | None = None, min_delay: float = 0.05, live_window: int = 6) -> None: ...
    @classmethod
    def from_json(cls, json_data: dict[str, Any]) -> Self: ...
    @classmethod
    def from_web(cls, url: str | ElementBase) -> Self: ...
    @classmethod
    def show_pytype(cls, type_: TypeVar) -> None: ...
    @classmethod
    def from_docs(cls, module_or_path: str | ModuleType | object) -> Self: ...
    lines: Incomplete
    def getlines(self, data: Incomplete | None = None, depth: int = 0): ...
    def format_value(self, key: str, value: Any) -> str: ...
    def rich(self, data: Incomplete | None = None, mdargs: Incomplete | None = None) -> RichMarkdown: ...
    def save(self, data: Incomplete | None = None, outfile: str | None = None) -> Self: ...
    def stream(self, speed_factor: int = 40000, outfile: str | None = None) -> None: ...

def recursive_read(file, include: Incomplete | None = None, depth: int = 0, max_depth: int = 5) -> dict[str, str]: ...
def cli(file: Incomplete | None = None, depth: int = -1, save: Incomplete | None = None) -> None: ...
def example() -> None: ...
