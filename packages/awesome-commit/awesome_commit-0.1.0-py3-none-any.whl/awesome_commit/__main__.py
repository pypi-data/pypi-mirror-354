import argparse
import sys
from enum import Enum
import importlib.resources
from pathlib import Path

from colored import Fore, Style
from loguru import logger
from questionary import select

from awesome_commit.editor import edit_text
from awesome_commit.git import (
    commit_changes,
    get_git_changes,
    get_last_commit_messages,
    show_diff,
    git_has_staged_changes,
    is_git_repository,
)
from awesome_commit.pre_commit import run_pre_commit
from awesome_commit.config import AppConfig as config


def get_embedded_prompt_template(name: str) -> str:
    """Get the embedded Jinja template for the commit message prompt."""
    full_name = f"{name}.txt.jinja2"
    logger.debug(f"Loading embedded prompt template: {full_name}")
    with (
        importlib.resources.files("awesome_commit.prompts")
        .joinpath(full_name)
        .open("r")
    ) as f:
        return f.read()


def get_prompt(context: dict) -> str:
    """Generate a prompt using a Jinja template.

    Args:
        context (dict): The context to render the template with.
    """
    jinja_template = config.PROMPT_TEMPLATE

    if jinja_template:
        template_path = Path(jinja_template).expanduser().resolve()
        logger.debug(f"Using Jinja template: {template_path}")
        if not template_path.exists():
            raise FileNotFoundError(f"Prompt template not found: {template_path}")
        with open(template_path, "r") as f:
            template_text = f.read()
    else:
        logger.debug("Using embedded Jinja template for commit message generation.")
        template_text = get_embedded_prompt_template("generate_commit_message")

    # Late import to avoid slow startup time
    import jinja2

    template = jinja2.Template(template_text)

    prompt = template.render(**context)

    return prompt


def get_commit_message():
    """Generate a commit message using the Gemini API."""
    print(f"{Fore.blue}Creating Gemini API client{Style.reset}")

    # Late import to avoid slow startup time
    from google import genai
    from google.genai import types

    client = genai.Client(api_key=config.GEMINI_API_KEY)

    git_unified_diff = get_git_changes()
    commit_messages = get_last_commit_messages(config.NUM_PREVIOUS_COMMITS)

    context = {
        "commit_messages": commit_messages,
        "num_previous_commits": config.NUM_PREVIOUS_COMMITS,
        "git_unified_diff": git_unified_diff,
    }

    print(f"{Fore.blue}Generating prompt...{Style.reset}")
    prompt = get_prompt(context=context)

    logger.debug("Prompt:")
    for line in prompt.splitlines():
        logger.debug(line)

    print(f"{Fore.blue}Submitting prompt to Gemini API{Style.reset}")
    response = client.models.generate_content(
        model=config.AI_MODEL,
        config=types.GenerateContentConfig(
            system_instruction=(
                "You are a technical writer for a software company "
                "and write succinctly."
            ),
        ),
        contents=prompt,
    )

    logger.debug("Generated commit message:")
    for line in response.text.splitlines():
        logger.debug(line)

    return response.text


def parse_args() -> argparse.Namespace:
    """Parse command-line arguments."""
    parser = argparse.ArgumentParser(
        description="Commit changes with a message generated by the Gemini API."
    )
    parser.add_argument("--logging", action="store_true", help="Enable logging.")
    parser.add_argument("--debug", action="store_true", help="Enable debug logging.")
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Print the commit message without committing the changes.",
    )
    return parser.parse_args()


class UserChoice(Enum):
    """Choices for the user to accept, edit, or regenerate the commit message."""

    YES = "Yes (Commit)"
    NO = "No (Regenerate)"
    EDIT = "Edit"
    SHOW_DIFF = "Show diff"
    QUIT = "Quit"


def init_logging(enable_logging: bool = False, enable_debug: bool = False) -> None:
    """Initialize logging configuration."""
    if enable_logging or enable_debug:
        if enable_debug:
            logger.remove()
            logger.add(sys.stderr, level="DEBUG")
    else:
        logger.remove()
    logger.info("Logging initialized.")


def assert_is_git_repository():
    """Assert that the current directory is a git repository."""
    logger.debug("Checking if current directory is a git repository.")
    if not is_git_repository():
        print(f"{Fore.red}Not a git repository. Exiting.{Style.reset}")
        sys.exit(1)
    logger.debug("Current directory is a git repository.")


def assert_staged_changes():
    """Assert that there are staged changes in the git repository."""
    logger.debug("Checking for staged changes.")
    if not git_has_staged_changes():
        print(f"{Fore.red}No staged changes found. Exiting.{Style.reset}")
        sys.exit(0)
    logger.debug("Staged changes found.")


def generate_commit_message_loop(dry_run: bool = False):
    """Loop to generate and handle the commit message."""
    message_accepted = False
    generate_message = True

    while not message_accepted:
        if generate_message:
            commit_message = get_commit_message()
        if not commit_message:
            print(f"{Fore.red}No commit message generated. Exiting.{Style.reset}")
            sys.exit(1)
        for line in commit_message.splitlines():
            print(f"{Fore.yellow}{line}{Style.reset}")
        if dry_run:
            print(
                f"{Fore.red}NOTE: You are in dry-run mode. This commit message will not be used.{Style.reset}"
            )
        value = select(
            "Do you want to use this commit message?",
            choices=[choice.value for choice in UserChoice],
            default=UserChoice.YES.value,
        ).ask()
        if value is None:
            print(f"{Fore.blue}Exiting without committing changes.{Style.reset}")
            sys.exit(0)
        elif value == UserChoice.YES.value:
            message_accepted = True
        elif value == UserChoice.NO.value:
            generate_message = True
        elif value == UserChoice.EDIT.value:
            print(
                f"{Fore.blue}Opening commit message in your default text editor.{Style.reset}"
            )
            commit_message = edit_text(commit_message)
            generate_message = False
        elif value == UserChoice.SHOW_DIFF.value:
            show_diff()
            generate_message = False
        elif value == UserChoice.QUIT.value:
            print(f"{Fore.blue}Exiting without committing changes.{Style.reset}")
            sys.exit(0)

    return commit_message


def commit_changes_to_git(commit_message: str, dry_run: bool = False):
    """Commit changes to git with the generated commit message."""
    if dry_run:
        print(f"{Fore.blue}Dry run enabled. Skipping commit.{Style.reset}")
    else:
        print(f"{Fore.blue}Committing changes with the generated message:{Style.reset}")
        commit_changes(commit_message)
        print(f"{Fore.blue}Changes committed.{Style.reset}")


def main():
    """Main function."""

    args = parse_args()
    init_logging(enable_logging=args.logging, enable_debug=args.debug)
    dry_run = args.dry_run

    print(f"{Fore.blue}Git AI{Style.reset}")

    assert_is_git_repository()
    assert_staged_changes()

    if config.RUN_PRE_COMMIT:
        logger.debug("Running pre-commit hooks.")
        run_pre_commit()

    commit_message = generate_commit_message_loop(dry_run=dry_run)
    commit_changes_to_git(commit_message, dry_run=dry_run)


if __name__ == "__main__":
    main()
