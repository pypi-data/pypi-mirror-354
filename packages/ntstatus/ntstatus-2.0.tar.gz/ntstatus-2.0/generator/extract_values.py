import re
import sys
from collections.abc import Callable, Generator
from enum import Enum
from pathlib import Path

class MacState(Enum):
    Before = 0
    If = 1
    Else = 2
    After = 3

def parse_ntstatus_values(lines: list[str]) -> Generator[tuple[str, int]]:
    for line in lines:
        # Typical NTSTATUS definition lines look like this:
        # #define STATUS_PENDING                   ((NTSTATUS)0x00000103L)    // winnt
        # The regex will miss a couple STATUS_* values by design:
        # - STATUS_SEVERITY_* (they are not real NTSTATUS values)
        # - STATUS_FLT_DISALLOW_FSFILTER_IO (which is an alias for STATUS_FLT_DISALLOW_FAST_IO)
        m = re.fullmatch(r'\s*#define\s+(STATUS_\w+)\s+\(\(NTSTATUS\)(0x[0-9A-F]+)L\)\s*(//.*)?', line)
        if not m:
            continue

        name = m.group(1)
        value = int(m.group(2), 16)

        # We should remove STATUS_WAIT_num, but not STATUS_WAIT_* (because of STATUS_WAIT_FOR_OPLOCK)
        if re.fullmatch(r'STATUS_WAIT_\d+', name):
            continue

        # We should remove STATUS_ABANDONED_WAIT_num, but not STATUS_ABANDONED_WAIT
        if re.fullmatch(r'STATUS_ABANDONED_WAIT_\d+', name):
            continue

        yield name, value

def parse_hresult_values(lines: list[str]) -> Generator[tuple[str, int]]:
    mac = MacState.Before

    for line in lines:
        # Update Mac State
        if mac==MacState.Before and line=='#if defined(_WIN32) && !defined(_MAC)':
            mac = MacState.If
        if mac==MacState.If and line.startswith('#else'):
            mac = MacState.Else
        if mac==MacState.Else and line.startswith('#endif'):
            mac = MacState.After

        if mac==MacState.Else:
            continue

        # Typical HRESULT definition lines look like this:
        # #define E_FAIL                           _HRESULT_TYPEDEF_(0x80004005L)
        m = re.fullmatch(r'\s*#define\s+(\w+)\s+_HRESULT_TYPEDEF_\((0x[0-9A-F]+)L\)\s*(//.*)?', line)
        if not m:
            continue

        name = m.group(1)
        value = int(m.group(2), 16)

        yield name, value

    assert mac==MacState.After

def parse_win32_values(lines: list[str]) -> Generator[tuple[str, int]]:
    marker_found = False
    for line in lines:
        if line.rstrip()=='//':
            marker_found = True
            continue

        if not marker_found:
            continue

        marker_found = False

        m = re.fullmatch(r'\s*#define\s+(\w+)\s+([0-9]+)L\s*(//.*)?', line)
        if not m:
            continue

        name = m.group(1)
        value = int(m.group(2), 10)
        if value < 0 or value > 16000:
            print(f'ERROR: {value} out of range [0, 16000)')
            sys.exit(2)

        yield name, value

def parse_header(header: Path, parse_values: Callable[[list[str]], Generator[tuple[str, int]]]) -> dict[str, int]:
    if not header.is_file():
        print(f'ERROR: {header} is not a file')
        sys.exit(2)

    values_to_names: dict[int,str] = dict()
    names_to_values: dict[str,int] = dict()

    lines = header.read_text().splitlines()

    for (name, value) in parse_values(lines):
        if value in values_to_names:
            print(f'ERROR: duplicated value: {name}=0x{value:08X}, previously seen as {values_to_names[value]}')
            sys.exit(2)

        if name in names_to_values:
            print(f'ERROR: duplicated name: {name}=0x{value:08X}, previously seen as {name}=0x{names_to_values[name]:08X}')
            sys.exit(2)

        values_to_names[value] = name
        names_to_values[name] = value

    return names_to_values

def read_script(script: Path) -> tuple[list[str],str]:
    if not script.is_file():
        print(f'ERROR: {script} is not a file')
        sys.exit(2)

    autogen_line = '# AUTOGENERATED FROM HERE, DO NOT TOUCH'
    lines = script.read_text().splitlines()
    for index, line in enumerate(lines):
        if m := re.fullmatch(r'^(\s+)' + autogen_line, line):
            return lines[0:index+1] + [''], m.group(1)

    print(f'ERROR: {script} does not contain the line "{autogen_line}" (with indentation)')
    sys.exit(2)

def edit_ntstatus_py(ntstatus_py: Path, ntstatus_values: dict[str, int]) -> None:
    lines, indent = read_script(ntstatus_py)

    for name, value in sorted(ntstatus_values.items(), key=lambda x: (x[1], x[0])):
        lines.append(f'{indent}{name}: Final[ThirtyTwoBits] = cached_ntstatus(0x{value:08X}, \'{name}\')')

    ntstatus_py.write_text('\n'.join(lines) + '\n')

def edit_win32error_py(win32error_py: Path, win32_values: dict[str, int]) -> None:
    lines, indent = read_script(win32error_py)

    for name, value in sorted(win32_values.items(), key=lambda x: (x[1], x[0])):
        lines.append(f'{indent}{name}: Final[ThirtyTwoBits] = cached_win32error(0x{value:04X}, \'{name}\') # WinError {value} (0x{value:X})')

    win32error_py.write_text('\n'.join(lines) + '\n')

def edit_hresult_py(hresult_py: Path, hresult_values: dict[str, int], win32_values: dict[str, int], ntstatus_values: dict[str, int]) -> None:
    lines, indent = read_script(hresult_py)

    # Regular constants
    for name, value in sorted(hresult_values.items(), key=lambda x: (x[1] & 0x0FFFFFFF, x[1] & 0xF0000000, x[0])):
        lines.append(f'{indent}{name}: Final[ThirtyTwoBits] = cached_hresult(0x{value:08X}, \'{name}\')')

    # Win32 Error Codes
    lines.append('')
    lines.append(f'{indent}# WIN32 Error Codes converted to HRESULT')
    for name, value in sorted(win32_values.items(), key=lambda x: (x[1], x[0])):
        hresult_name = f'HRESULT_FROM_WIN32({name})'
        if value > 0:
            hresult_value = (value & 0xFFFF) | 0x80070000
        else:
            hresult_value = 0

        lines.append(f'{indent}WIN32__{name}: Final[ThirtyTwoBits] = cached_hresult(0x{hresult_value:08X}, \'{hresult_name}\')')

    # NtStatus values
    lines.append('')
    lines.append(f'{indent}# NTSTATUS values converted to HRESULT')
    for name, value in sorted(ntstatus_values.items(), key=lambda x: (x[1], x[0])):
        hresult_name = f'HRESULT_FROM_NT({name})'
        hresult_value = value | 0x10000000

        lines.append(f'{indent}NTSTATUS__{name}: Final[ThirtyTwoBits] = cached_hresult(0x{hresult_value:08X}, \'{hresult_name}\')')

    hresult_py.write_text('\n'.join(lines) + '\n')

def main() -> None:
    if len(sys.argv) != 2:
        print(f'Usage: {Path(__file__).name} path/to/winsdk')
        sys.exit(1)

    sdk_path = Path(sys.argv[1])
    ntstatus_h = sdk_path / 'shared' / 'ntstatus.h'
    winerror_h = sdk_path / 'shared' / 'winerror.h'

    ntstatus_values = parse_header(ntstatus_h, parse_ntstatus_values)
    win32_values = parse_header(winerror_h, parse_win32_values)
    hresult_values = parse_header(winerror_h, parse_hresult_values)

    ntstatus_py = Path(__file__).parent.parent / 'ntstatus' / '_ntstatus.py'
    edit_ntstatus_py(ntstatus_py, ntstatus_values)

    win32error_py = Path(__file__).parent.parent / 'ntstatus' / '_win32error.py'
    edit_win32error_py(win32error_py, win32_values)

    hresult_py = Path(__file__).parent.parent / 'ntstatus' / '_hresult.py'
    edit_hresult_py(hresult_py, hresult_values, win32_values, ntstatus_values)

if __name__ == '__main__':
    main()
