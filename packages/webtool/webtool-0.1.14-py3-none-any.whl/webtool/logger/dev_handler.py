import io
import logging
import os
import re
import time
from abc import ABC, abstractmethod
from logging.handlers import BaseRotatingHandler

_MIDNIGHT = 24 * 60 * 60  # number of seconds in a day


class LogHandler(ABC):
    """Abstract base class for log handlers following Open/Closed Principle"""

    @abstractmethod
    def get_handler(self) -> logging.Handler:
        pass


class ConsoleHandler(LogHandler):
    """Concrete console handler implementation"""

    def get_handler(self) -> logging.Handler:
        return logging.StreamHandler()


class TimedRotatingFileHandler(BaseRotatingHandler):
    """
    Handler for logging to a file, rotating the log file at certain timed
    intervals.

    If backupCount is > 0, when rollover is done, no more than backupCount
    files are kept - the oldest ones are deleted.
    """

    def __init__(
        self,
        filename,
        interval=60 * 60 * 24,
        max_bytes=1024 * 512,
        backup_count=0,
        encoding=None,
        delay=False,
        errors=None,
    ):
        encoding = io.text_encoding(encoding)
        BaseRotatingHandler.__init__(self, filename, "a", encoding=encoding, delay=delay, errors=errors)
        self.backupCount = backup_count
        self.interval = interval
        self.suffix = "%Y-%m-%d"
        self.maxBytes = max_bytes
        self.basePath = os.path.dirname(os.path.abspath(filename))
        self.filePattern = r"(?<!\d)\d{4}-\d{2}-\d{2}(?!\d)"
        self.extMatch = re.compile(self.filePattern, re.ASCII)

        filename = self.baseFilename

        if os.path.exists(filename):
            t = int(os.stat(filename).st_mtime)
        else:
            t = int(time.time())

        self.rolloverAt = self.computeRollover(t)

    def computeRollover(self, currentTime):
        """
        Work out the rollover time based on the specified time.
        """
        t = time.gmtime(currentTime)
        r = _MIDNIGHT - ((t[3] * 60 + t[4]) * 60 + t[5])

        if r <= 0:
            r += _MIDNIGHT

        result = currentTime + r
        return result

    def shouldRollover(self, record):
        """
        Determine if rollover should occur.

        record is not used, as we are just comparing times, but it is needed so
        the method signatures are the same
        """
        t = int(time.time())
        is_not_file = os.path.exists(self.baseFilename) and not os.path.isfile(self.baseFilename)
        if self.stream is None:
            self.stream = self._open()

        if t >= self.rolloverAt:
            if is_not_file:
                self.rolloverAt = self.computeRollover(t)
                return False
            return True

        if self.maxBytes > 0:
            pos = self.stream.tell()
            if not pos:
                return False
            msg = "%s\n" % self.format(record)
            if pos + len(msg) >= self.maxBytes:
                if is_not_file:
                    return False
                return True
        return False

    def getFilesToDelete(self):
        """
        Determine the files to delete when rolling over.

        More specific than the earlier method, which just used glob.glob().
        """
        dirName, baseName = os.path.split(self.baseFilename)
        fileNames = os.listdir(dirName)
        result = []
        if self.namer is None:
            prefix = baseName + "."
            plen = len(prefix)
            for fileName in fileNames:
                if fileName[:plen] == prefix:
                    suffix = fileName[plen:]
                    if self.extMatch.fullmatch(suffix):
                        result.append(os.path.join(dirName, fileName))
        else:
            for fileName in fileNames:
                # Our files could be just about anything after custom naming,
                # but they should contain the datetime suffix.
                # Try to find the datetime suffix in the file name and verify
                # that the file name can be generated by this handler.
                m = self.extMatch.search(fileName)
                while m:
                    dfn = self.namer(self.baseFilename + "." + m[0])
                    if os.path.basename(dfn) == fileName:
                        result.append(os.path.join(dirName, fileName))
                        break
                    m = self.extMatch.search(fileName, m.start() + 1)

        if len(result) < self.backupCount:
            result = []
        else:
            result.sort()
            result = result[: len(result) - self.backupCount]
        return result

    def doRollover(self):
        """
        do a rollover; in this case, a date/time stamp is appended to the filename
        when the rollover happens.  However, you want the file to be named for the
        start of the interval, not the current time.  If there is a backup count,
        then we have to get a list of matching filenames, sort them and remove
        the one with the oldest suffix.
        """
        # get the time that this sequence started at and make it a TimeTuple
        currentTime = int(time.time())
        t = self.rolloverAt - self.interval
        timeTuple = time.gmtime(t)

        dfn = self.rotation_filename(self.baseFilename + "." + time.strftime(self.suffix, timeTuple))

        if os.path.exists(dfn):
            return

        if self.stream:
            self.stream.close()
            self.stream = None
        self.rotate(self.baseFilename, dfn)
        if self.backupCount > 0:
            for s in self.getFilesToDelete():
                os.remove(s)
        if not self.delay:
            self.stream = self._open()
        self.rolloverAt = self.computeRollover(currentTime)
