"""
Validator functions for Component Configuration data that are generated by agents.
"""

import json
import logging
from enum import Enum
from importlib import resources
from typing import Callable, Optional, cast

import jsonschema
import jsonschema.validators
from jsonschema import TypeChecker
from jsonschema.validators import extend

from keboola_mcp_server.client import JsonDict, JsonPrimitive, JsonStruct

LOG = logging.getLogger(__name__)

ValidateFunction = Callable[[JsonDict, JsonDict], None]

RESOURCES = 'keboola_mcp_server.resources'


class ConfigurationSchemaResources(str, Enum):
    STORAGE = 'storage-schema.json'
    FLOW = 'flow-schema.json'


class RecoverableValidationError(jsonschema.ValidationError):
    """
    An instance was invalid under a provided schema using a recoverable message for the Agent.
    """

    _RECOVERY_INSTRUCTIONS = (
        'Recovery instructions:\n'
        '- Please check the json schema.\n'
        '- Fix the errors in your input data to follow the schema.\n'
    )

    def __init__(self, *args, invalid_json: Optional[JsonDict] = None, initial_message: Optional[str] = None, **kwargs):
        super().__init__(*args, **kwargs)
        self.invalid_json = invalid_json
        self.initial_message = initial_message

    @classmethod
    def create_from_values(
        cls,
        other: jsonschema.ValidationError,
        invalid_json: Optional[JsonDict] = None,
        initial_message: Optional[str] = None,
    ):
        return cls(**other._contents(), invalid_json=invalid_json, initial_message=initial_message)

    def __str__(self) -> str:
        """
        Builds a string representation of the error with recovery instructions.
        Following points describe the order of the error message:
        - message = super().__str__() represents the original error message, so it starts with the error message.
        - message += initial_message if provided, it adds the initial message to the error message.
        - message += recovery instructions from _RECOVERY_INSTRUCTIONS
        - message += invalid_json if provided, it adds the invalid json input data to the error message.

        Example output (init_message="The provided storage configuration is not valid."):
            RecoverableValidationError: 'destination' is a required property
            ...parent error message (containing the violated part of the json schema)...

            The provided storage configuration is not valid.
            Recovery instructions:
            - Please check the json schema.
            - Fix the errors in your input data to follow the schema.

            Invalid input data:
            {
                "storage": {...}
            }
        """
        str_repr = f'{super().__str__()}\n'
        if self.initial_message:
            str_repr += f'{self.initial_message}\n'
        str_repr += f'{self._RECOVERY_INSTRUCTIONS}\n'
        if self.invalid_json:
            str_repr += f'\nInvalid input data:\n{json.dumps(self.invalid_json, indent=2)}\n'
        return str_repr.rstrip()


class KeboolaParametersValidator:
    """
    A custom JSON Schema validator that handles UI elements and schema normalization:
    1. Ignores 'button' type (UI-only construct)
    2. Normalizes schema by:
       - Converting boolean 'required' flags to proper list format (propagating the required flag up)
       - Ensuring 'properties' is a dictionary if it is an empty list
    """

    @classmethod
    def validate(cls, instance: JsonDict, schema: JsonDict) -> None:
        """
        Validate the instance against the schema.
        """
        sanitized_schema = cls.sanitize_schema(schema)
        base_validator = jsonschema.validators.validator_for(sanitized_schema)
        keboola_validator = extend(
            base_validator, type_checker=base_validator.TYPE_CHECKER.redefine('button', cls.check_button_type)
        )
        return keboola_validator(sanitized_schema).validate(instance)

    @staticmethod
    def check_button_type(checker: TypeChecker, instance: object) -> bool:
        """
        Dummy button type checker.
        We accept button as a type since it is a UI construct and not a data type.
        :returns: True if instance is a dict with a type field with value 'button', False otherwise
        """
        # TODO: We can add a custom pydantic model or json schema for validating button type instances.
        return isinstance(instance, dict) and 'button' == instance.get('type', None)

    @staticmethod
    def sanitize_schema(schema: JsonDict) -> JsonDict:
        """Normalize schema by converting required fields to lists and ensuring properties is a dict"""

        def _sanitize_required_and_properties(
            schema: JsonStruct | JsonPrimitive,
        ) -> tuple[JsonStruct | JsonPrimitive, Optional[bool]]:

            # default returns the element of a schema if we are at the bottom of the tree (not a dict)
            if not isinstance(schema, dict):
                return schema, False

            is_current_required = None
            required = schema.get('required', [])
            if not isinstance(required, list):
                # Convert required field to empty list, and set is_current_required to True/False if the required
                # field is set to true/false and propagate the required flag up to the parent's required list
                is_current_required = str(required).lower() == 'true'
                required = []

            if (properties := schema.get('properties')) is not None:
                if properties == []:
                    properties = {}  # convert empty list to empty dict to avoid AttributeError in jsonschema
                elif not isinstance(properties, dict):
                    # Invalid schema - properties must be a dictionary. SchemaError will be caught and logged
                    # in _validate_json_against_schema but the validation will succeed since we cant use invalid schema
                    raise jsonschema.SchemaError(f'properties must be a dictionary, got {type(properties)}')

                for property_name, subschema in properties.items():
                    # we recursively sanitize the subschemas within the properties
                    properties[property_name], is_child_required = _sanitize_required_and_properties(subschema)
                    # if is_child_required is None, do not propagate - the child has required field correctly set
                    if is_child_required is True and property_name not in required:
                        required.append(property_name)
                    elif is_child_required is False and property_name in required:
                        required.remove(property_name)
                schema['properties'] = properties

            if required:
                schema['required'] = list(required)
            else:
                schema.pop('required', None)

            return schema, is_current_required

        sanitized_schema = cast(JsonDict, _sanitize_required_and_properties(schema)[0])
        return sanitized_schema


def validate_storage(storage: JsonDict, initial_message: Optional[str] = None) -> JsonDict:
    """Validate the storage configuration using jsonschema.
    :param storage: The storage configuration to validate
    :param initial_message: The initial message to include in the error message
    :returns: The validated storage configuration normalized to {"storage" : {...}}
    """
    schema = _load_schema(ConfigurationSchemaResources.STORAGE)
    # we expect the storage to be a dictionary of storage configurations with the "storage" key
    normalized_storage_data = {'storage': storage.get('storage', storage)}
    _validate_json_against_schema(
        json_data=normalized_storage_data,
        schema=schema,
        initial_message=initial_message,
    )
    return normalized_storage_data


def validate_parameters(parameters: JsonDict, schema: JsonDict, initial_message: Optional[str] = None) -> JsonDict:
    """
    Validate the parameters configuration using jsonschema.
    :parameters: json data to validate
    :schema: json schema to validate against (root or row parameter configuration schema)
    :initial_message: initial message to include in the error message
    :returns: The validated parameters configuration normalized to {"parameters" : {...}}
    """
    expected_input = cast(JsonDict, parameters.get('parameters', parameters))
    _validate_json_against_schema(expected_input, schema, initial_message, KeboolaParametersValidator.validate)
    return {'parameters': expected_input}  # normalized to {"parameters" : {...}}


def validate_flow_configuration_against_schema(flow: JsonDict, initial_message: Optional[str] = None) -> JsonDict:
    """
    Validate the flow configuration using jsonschema.
    :flow: json data to validate
    :initial_message: initial message to include in the error message
    :returns: The validated flow configuration
    """
    schema = _load_schema(ConfigurationSchemaResources.FLOW)
    _validate_json_against_schema(
        json_data=flow,
        schema=schema,
        initial_message=initial_message,
    )
    return flow


def _validate_json_against_schema(
    json_data: JsonDict,
    schema: JsonDict,
    initial_message: Optional[str] = None,
    validate_fn: Optional[ValidateFunction] = None,
):
    """Validate JSON data against the provided schema."""
    try:
        validate_fn = validate_fn or jsonschema.validate
        validate_fn(json_data, schema)
    except jsonschema.ValidationError as e:
        raise RecoverableValidationError.create_from_values(e, invalid_json=json_data, initial_message=initial_message)
    except jsonschema.SchemaError as e:
        LOG.exception(
            f'The validation schema is not valid: {e}\n'
            f'initial_message: {initial_message}\n'
            f'schema: {schema}\n'
            f'json_data: {json_data}'
        )
        # this is not an Agent error, the schema is not valid and we are unable to validate the json
        # hence we continue with as if it was valid
        return


def _load_schema(json_schema_name: ConfigurationSchemaResources) -> JsonDict:
    with resources.open_text(RESOURCES, json_schema_name.value, encoding='utf-8') as f:
        return json.load(f)
