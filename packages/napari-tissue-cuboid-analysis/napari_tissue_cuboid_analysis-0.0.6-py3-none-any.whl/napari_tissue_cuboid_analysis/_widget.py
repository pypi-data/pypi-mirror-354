"""
This module contains four napari widgets declared in
different ways:

- a pure Python function flagged with `autogenerate: true`
    in the plugin manifest. Type annotations are used by
    magicgui to generate widgets for each parameter. Best
    suited for simple processing tasks - usually taking
    in and/or returning a layer.
- a `magic_factory` decorated function. The `magic_factory`
    decorator allows us to customize aspects of the resulting
    GUI, including the widgets associated with each parameter.
    Best used when you have a very simple processing task,
    but want some control over the autogenerated widgets. If you
    find yourself needing to define lots of nested functions to achieve
    your functionality, maybe look at the `Container` widget!
- a `magicgui.widgets.Container` subclass. This provides lots
    of flexibility and customization options while still supporting
    `magicgui` widgets and convenience methods for creating widgets
    from type annotations. If you want to customize your widgets and
    connect callbacks, this is the best widget option for you.
- a `QWidget` subclass. This provides maximal flexibility but requires
    full specification of widget layouts, callbacks, events, etc.

References:
- Widget specification: https://napari.org/stable/plugins/building_a_plugin/guides.html#widgets
- magicgui docs: https://pyapp-kit.github.io/magicgui/

Replace code below according to your needs.
"""

import napari
import napari.layers
import numpy as np
from magicgui.widgets import Button, CheckBox, create_widget
from qtpy.QtWidgets import (
    QGridLayout,
    QGroupBox,
    QLabel,
    QPushButton,
    QScrollArea,
    QSizePolicy,
    QVBoxLayout,
    QWidget,
)

from ._utils import (
    apply_threshold,
    bin_closing,
    bin_median,
    bin_opening,
    generate_multiple_cuboids_simple,
    generate_single_cuboid,
    global_threshold_gmm,
    local_threshold_gmm_simple,
    merge_labels,
    pipette_mask_manual,
    split_labels,
    watershed_auto_fix,
)


class BinGB(QGroupBox):
    def __init__(
        self,
        viewer,
        name,
    ):

        super().__init__(name)
        self.viewer = viewer
        self.layout = QGridLayout()
        self.setLayout(self.layout)

        self.input_img_combo = create_widget(annotation=napari.layers.Image)
        self.bin_size_spinbox = create_widget(
            annotation=int, options={"min": 1, "value": 2}
        )
        self.run_button = Button(label="Run")

        self.viewer.layers.events.inserted.connect(
            self.input_img_combo.reset_choices
        )
        self.viewer.layers.events.removed.connect(
            self.input_img_combo.reset_choices
        )

        self.layout.addWidget(QLabel("Input"), 0, 0)
        self.layout.addWidget(self.input_img_combo.native, 0, 1, 1, 2)
        self.layout.addWidget(QLabel("Bin kernel"), 1, 0)
        self.layout.addWidget(self.bin_size_spinbox.native, 1, 1, 1, 2)
        self.layout.addWidget(self.run_button.native, 2, 0, 1, 3)

        self.run_button.clicked.connect(self._run_bin)

    def _run_bin(self):
        img_layer = self.input_img_combo.value
        img = img_layer.data
        kernel_size = self.bin_size_spinbox.value

        binned = bin_median(img=img, kernel_size=kernel_size)
        self.viewer.add_image(binned, name="Binned")


class PipetteGB(QGroupBox):
    def __init__(
        self,
        viewer,
        name,
    ):

        super().__init__(name)
        self.viewer = viewer
        self.layout = QGridLayout()
        self.setLayout(self.layout)

        self.input_img_combo = create_widget(annotation=napari.layers.Image)
        self.input_points_combo = create_widget(
            annotation=napari.layers.Points
        )

        self.run_button = Button(label="Run")

        self.viewer.layers.events.inserted.connect(
            self.input_img_combo.reset_choices
        )
        self.viewer.layers.events.removed.connect(
            self.input_img_combo.reset_choices
        )
        self.viewer.layers.events.inserted.connect(
            self.input_points_combo.reset_choices
        )
        self.viewer.layers.events.removed.connect(
            self.input_points_combo.reset_choices
        )

        self.layout.addWidget(QLabel("Input"), 0, 0)
        self.layout.addWidget(self.input_img_combo.native, 0, 1)
        self.layout.addWidget(QLabel("Points"), 1, 0)
        self.layout.addWidget(self.input_points_combo.native, 1, 1)

        self.layout.addWidget(self.run_button.native, 3, 0, 1, 2)

        self.run_button.clicked.connect(self._run_pipette_detect)

    def _run_pipette_detect(self):
        img_layer = self.input_img_combo.value
        img = img_layer.data
        points_layer = self.input_points_combo.value
        points = points_layer.data
        mask = pipette_mask_manual(img, points)

        self.viewer.add_labels(mask, name="Pipette mask")


class ThresholdGB(QGroupBox):
    def __init__(
        self,
        viewer,
        name,
    ):

        super().__init__(name)
        self.viewer = viewer
        self.layout = QGridLayout()
        self.setLayout(self.layout)

        self.input_img_combo = create_widget(annotation=napari.layers.Image)
        self.mask_combo = create_widget(annotation=napari.layers.Labels)

        self.local_button = QPushButton("Local")
        self.local_button.setCheckable(True)
        self.local_button.setChecked(True)

        self.spacing_spinbox = create_widget(
            annotation=int, options={"min": 1, "value": 52}
        )
        self.win_size_spinbox = create_widget(
            annotation=float,
            options={"min": 0.1, "max": 2, "value": 0.6, "step": 0.1},
        )
        self.min_std_spinbox = create_widget(
            annotation=float, options={"value": 0.7}
        )

        self.plot_thresh_cb = CheckBox(value=False, text="Plot thresh.")
        self.run_button = Button(label="Run")

        self.viewer.layers.events.inserted.connect(
            self.input_img_combo.reset_choices
        )
        self.viewer.layers.events.removed.connect(
            self.input_img_combo.reset_choices
        )
        self.viewer.layers.events.inserted.connect(
            self.mask_combo.reset_choices
        )
        self.viewer.layers.events.removed.connect(
            self.mask_combo.reset_choices
        )

        self.layout.addWidget(QLabel("Input"), 0, 0)
        self.layout.addWidget(self.local_button, 0, 2)
        self.layout.addWidget(self.input_img_combo.native, 0, 1)

        self.layout.addWidget(QLabel("Mask"), 1, 0)
        self.layout.addWidget(self.mask_combo.native, 1, 1, 1, 2)

        self.layout.addWidget(QLabel("Spacing"), 2, 0)
        self.layout.addWidget(self.spacing_spinbox.native, 2, 1, 1, 2)
        self.layout.addWidget(QLabel("Win. size"), 3, 0)
        self.layout.addWidget(self.win_size_spinbox.native, 3, 1, 1, 2)
        self.layout.addWidget(QLabel("Min. std"), 4, 0)
        self.layout.addWidget(self.min_std_spinbox.native, 4, 1, 1, 2)

        self.layout.addWidget(self.plot_thresh_cb.native, 5, 0)
        self.layout.addWidget(self.run_button.native, 5, 1, 1, 2)

        self.run_button.clicked.connect(self._run_threshold)

    def _run_threshold(self):
        img_layer = self.input_img_combo.value
        img = img_layer.data
        local = self.local_button.isChecked()

        mask_layer = self.mask_combo.value
        mask = mask_layer.data
        mask = mask.astype(bool)

        spacing = self.spacing_spinbox.value
        win_size = self.win_size_spinbox.value
        min_std = self.min_std_spinbox.value
        plot = self.plot_thresh_cb.value
        if local:
            thresh_map, thresh_grid = local_threshold_gmm_simple(
                img, mask, spacing, win_size, min_std
            )
            binary = apply_threshold(img, thresh_map, mask)

            if plot:
                contrast = [
                    np.min(thresh_map[mask]),
                    np.max(thresh_map[mask]),
                ]
                self.viewer.add_image(
                    thresh_map,
                    name="Threshold map",
                    visible=False,
                    contrast_limits=contrast,
                )
                self.viewer.add_points(
                    thresh_grid,
                    name="Local window centers",
                    visible=False,
                )
        else:
            binary, global_thresh = global_threshold_gmm(img, mask)
            print(f"Global threshold: {global_thresh:.0f}")

        self.viewer.add_labels(binary, name="Binary")


class MorphologyGB(QGroupBox):
    def __init__(
        self,
        viewer,
        name,
    ):

        super().__init__(name)
        self.viewer = viewer
        self.layout = QGridLayout()
        self.setLayout(self.layout)

        self.input_labels_combo = create_widget(
            annotation=napari.layers.Labels
        )

        self.d_spinbox = create_widget(
            annotation=int, options={"min": 1, "value": 3, "step": 2}
        )
        self.single_cb = CheckBox(text="Single", value=False)
        self.single_spinbox = create_widget(
            annotation=int, options={"min": 1, "value": 1}
        )
        self.open_button = Button(label="Open")
        self.close_button = Button(label="Close")

        self.viewer.layers.events.inserted.connect(
            self.input_labels_combo.reset_choices
        )
        self.viewer.layers.events.removed.connect(
            self.input_labels_combo.reset_choices
        )

        self.layout.addWidget(QLabel("Input"), 0, 0)
        self.layout.addWidget(self.input_labels_combo.native, 0, 1)

        self.layout.addWidget(QLabel("Diameter"), 2, 0)
        self.layout.addWidget(self.d_spinbox.native, 2, 1)

        self.layout.addWidget(self.single_cb.native, 3, 0)
        self.layout.addWidget(self.single_spinbox.native, 3, 1)

        self.layout.addWidget(self.open_button.native, 4, 0)
        self.layout.addWidget(self.close_button.native, 4, 1)

        self.open_button.clicked.connect(self._run_opening)
        self.close_button.clicked.connect(self._run_closing)

    def _run_opening(self):
        labels_layer = self.input_labels_combo.value
        labels = labels_layer.data
        name = labels_layer.name
        diameter = self.d_spinbox.value

        single = self.single_spinbox.value if self.single_cb.value else None

        closed = bin_opening(labels, diameter, single)

        self.viewer.add_labels(closed, name=name + "Filtered")

    def _run_closing(self):
        labels_layer = self.input_labels_combo.value
        labels = labels_layer.data
        name = labels_layer.name
        diameter = self.d_spinbox.value

        single = self.single_spinbox.value if self.single_cb.value else None

        closed = bin_closing(labels, diameter, single)

        self.viewer.add_labels(closed, name=name + "Filtered")


class LabelGB(QGroupBox):
    def __init__(
        self,
        viewer,
        name,
    ):

        super().__init__(name)
        self.viewer = viewer
        self.layout = QGridLayout()
        self.setLayout(self.layout)

        self.input_binary_combo = create_widget(
            annotation=napari.layers.Labels
        )

        self.watershed_lvl_spinbox = create_widget(
            annotation=int, options={"min": 1, "value": 3}
        )
        self.overseg_thresh_spinbox = create_widget(
            annotation=float,
            options={"min": 0, "max": 1, "value": 0.3, "step": 0.1},
        )
        self.plot_interm_cb = CheckBox(value=False, text="Plot interm.")
        self.run_button = Button(label="Run")

        self.labels_img_combo = create_widget(annotation=napari.layers.Labels)
        self.manual_input = create_widget(annotation=str, value="1,2,3")
        self.merge_button = Button(label="Merge")
        self.split_button = Button(label="Split")

        self.viewer.layers.events.inserted.connect(
            self.input_binary_combo.reset_choices
        )
        self.viewer.layers.events.removed.connect(
            self.input_binary_combo.reset_choices
        )
        self.viewer.layers.events.inserted.connect(
            self.labels_img_combo.reset_choices
        )
        self.viewer.layers.events.removed.connect(
            self.labels_img_combo.reset_choices
        )

        self.layout.addWidget(QLabel("Input"), 0, 0)
        self.layout.addWidget(self.input_binary_combo.native, 0, 1)
        self.layout.addWidget(
            QLabel("Watershed lvl"),
            1,
            0,
        )
        self.layout.addWidget(self.watershed_lvl_spinbox.native, 1, 1)
        self.layout.addWidget(QLabel("Merge thr."), 2, 0)
        self.layout.addWidget(self.overseg_thresh_spinbox.native, 2, 1)
        self.layout.addWidget(self.plot_interm_cb.native, 3, 0)
        self.layout.addWidget(self.run_button.native, 3, 1)

        self.layout.addWidget(QLabel("Fix manually (opt.):"), 4, 0, 1, 2)
        self.layout.addWidget(QLabel("Labels layer"), 5, 0)
        self.layout.addWidget(self.labels_img_combo.native, 5, 1)
        self.layout.addWidget(QLabel("Target labels"), 6, 0)
        self.layout.addWidget(self.manual_input.native, 6, 1)
        self.layout.addWidget(self.merge_button.native, 7, 0)
        self.layout.addWidget(self.split_button.native, 7, 1)

        self.run_button.clicked.connect(self._run_labelling)
        self.merge_button.clicked.connect(self._run_manual_merge)
        self.split_button.clicked.connect(self._run_manual_split)

    def _run_labelling(self):
        binary_layer = self.input_binary_combo.value
        binary = binary_layer.data

        if np.any((binary != 0) & (binary != 1)):
            print("Selected layer is not binary")
            return

        watershed_lvl = self.watershed_lvl_spinbox.value
        overseg_threshold = self.overseg_thresh_spinbox.value

        image_iterations = watershed_auto_fix(
            binary=binary.astype(bool),
            watershed_lvl=watershed_lvl,
            overseg_threshold=overseg_threshold,
        )

        if self.plot_interm_cb.value and len(image_iterations) >= 2:
            for i in range(len(image_iterations) - 1):
                self.viewer.add_labels(
                    image_iterations[i],
                    name=f"Interm. labels {i}",
                    visible=False,
                )

        self.viewer.add_labels(image_iterations[-1], name="Labels")

    def _run_manual_merge(self):
        labels_layer = self.labels_img_combo.value
        labels = labels_layer.data

        target_str = self.manual_input.value
        targets = [int(x.strip()) for x in target_str.split(",") if x.strip()]

        merged = merge_labels(labels, targets)

        self.viewer.add_labels(merged, name="Merged labels")

    def _run_manual_split(self):
        binary_layer = self.input_binary_combo.value
        binary = binary_layer.data

        labels_layer = self.labels_img_combo.value
        labels = labels_layer.data

        target_str = self.manual_input.value
        targets = [int(x.strip()) for x in target_str.split(",") if x.strip()]

        watershed_lvl = self.watershed_lvl_spinbox.value

        split = split_labels(labels, binary, targets, watershed_lvl)

        self.viewer.add_labels(split, name="Split labels")


class MeshGB(QGroupBox):
    def __init__(
        self,
        viewer,
        name,
    ):

        super().__init__(name)
        self.viewer = viewer
        self.layout = QGridLayout()
        self.setLayout(self.layout)

        self.labels_img_combo = create_widget(annotation=napari.layers.Labels)
        self.dirpath_str = create_widget(annotation=str, value="CuboidData")
        self.smooth_spinbox = create_widget(
            annotation=int, options={"min": 0, "value": 10}
        )
        self.voxel_spinbox = create_widget(
            annotation=float, options={"value": 6}
        )
        self.sample_cb = CheckBox(value=True, text="Single label:")
        self.sample_spinbox = create_widget(
            annotation=int, options={"min": 1, "value": 1}
        )
        self.gen_button = Button(label="Generate")

        self.viewer.layers.events.inserted.connect(
            self.labels_img_combo.reset_choices
        )
        self.viewer.layers.events.removed.connect(
            self.labels_img_combo.reset_choices
        )

        self.layout.addWidget(QLabel("Input"), 0, 0)
        self.layout.addWidget(self.labels_img_combo.native, 0, 1, 1, 2)
        self.layout.addWidget(
            QLabel("Directory"),
            1,
            0,
        )
        self.layout.addWidget(self.dirpath_str.native, 1, 1, 1, 2)
        self.layout.addWidget(QLabel("Voxel size [\u03bcm]"), 2, 0, 1, 2)
        self.layout.addWidget(self.voxel_spinbox.native, 2, 2)
        self.layout.addWidget(QLabel("Smooting iterations"), 3, 0, 1, 2)
        self.layout.addWidget(self.smooth_spinbox.native, 3, 2)
        self.layout.addWidget(self.sample_cb.native, 4, 0, 1, 2)
        self.layout.addWidget(self.sample_spinbox.native, 4, 2)
        self.layout.addWidget(self.gen_button.native, 5, 0, 1, 3)

        self.gen_button.clicked.connect(self._run_generation)

    def _run_generation(self):
        labels_layer = self.labels_img_combo.value
        labels = labels_layer.data

        dirpath_str = self.dirpath_str.value

        vsize = self.voxel_spinbox.value
        smooth_iter = self.smooth_spinbox.value

        single = self.sample_cb.value

        if single:
            label = self.sample_spinbox.value
            vertices, faces, metrics = generate_single_cuboid(
                labels, label, vsize, smooth_iter
            )

            if vertices is None:
                print(f"Could not build mesh for cuboid {label}")
                return

            for layer in self.viewer.layers:
                layer.visible = False

            self.viewer.dims.ndisplay = 3

            self.viewer.add_surface((vertices, faces), name=f"Cuboid{label}")

            self.viewer.camera.center = tuple(vertices.mean(axis=0))

            if metrics is not None:
                print(f"Cuboid{label}")
                print(
                    f"volume:{metrics[0]:.2e} [mm³]  compactness: {metrics[1]:.3f}   convexity: {metrics[2]:.3f}"
                )
                print(
                    f"IoU: {metrics[3]:.3f}   inertia ratio:{metrics[4]:.3f}"
                )

        else:
            generate_multiple_cuboids_simple(
                labels, vsize, smooth_iter, dir_path=dirpath_str
            )


class TissueCuboidAnalysisQWidget(QWidget):
    def __init__(self, napari_viewer):
        super().__init__()
        self.viewer = napari_viewer

        self.bin_groupbox = BinGB(viewer=self.viewer, name="1:Median binning")
        self.pipette_groupbox = PipetteGB(
            viewer=self.viewer, name="2: Pipette mask extraction"
        )
        self.threshold_groupbox = ThresholdGB(
            viewer=self.viewer, name="3. Thresholding"
        )
        self.morphology_groupbox = MorphologyGB(
            viewer=self.viewer, name="4: Morphology"
        )
        self.label_groupbox = LabelGB(viewer=self.viewer, name="5: Labelling")
        self.mesh_groupbox = MeshGB(
            viewer=self.viewer, name="6: Mesh and metrics generation"
        )

        # Set plugin layout
        self.layout = QVBoxLayout()
        self.setLayout(self.layout)

        # Make plugin scrollable
        self.scroll = QScrollArea(self)
        self.layout.addWidget(self.scroll)
        self.scroll.setWidgetResizable(True)
        self.scroll_content = QWidget(self.scroll)
        self.scroll_layout = QVBoxLayout(self.scroll_content)
        self.scroll_content.setLayout(self.scroll_layout)
        self.scroll_content.setSizePolicy(
            QSizePolicy.Preferred, QSizePolicy.Maximum
        )

        # Add individual widgets to plugin
        self.scroll_layout.addWidget(self.bin_groupbox)
        self.scroll_layout.addWidget(self.pipette_groupbox)
        self.scroll_layout.addWidget(self.threshold_groupbox)
        self.scroll_layout.addWidget(self.morphology_groupbox)
        self.scroll_layout.addWidget(self.label_groupbox)
        self.scroll_layout.addWidget(self.mesh_groupbox)

        self.scroll.setWidget(self.scroll_content)

        self.parameters = {}
