"use strict";(self.webpackChunkfirebird=self.webpackChunkfirebird||[]).push([[4392],{4392:(P,g,p)=>{p.r(g),p.d(g,{TSplinePainter:()=>u});var x=p(467),c=p(6998),d=p(9041),y=p(675),M=p(1516);class u extends y.JW{updateObject(t,i){const e=this.getObject();return e._typename===t._typename&&(e!==t&&Object.assign(e,t),void 0!==i&&this.decodeOptions(i),!0)}eval(t,i){const e=i-t.fX;return"TSplinePoly3"===t._typename?t.fY+e*(t.fB+e*(t.fC+e*t.fD)):"TSplinePoly5"===t._typename?t.fY+e*(t.fB+e*(t.fC+e*(t.fD+e*(t.fE+e*t.fF)))):t.fY+e}findX(t){const i=this.getObject();let e=0,n=i.fNp-1;if(t<=i.fXmin)return 0;if(t>=i.fXmax)return n;if(i.fKstep)e=Math.round((t-i.fXmin)/i.fDelta),t<i.fPoly[e].fX?e=Math.max(e-1,0):e<n&&t>i.fPoly[e+1].fX&&++e;else for(;n-e>1;){const a=Math.round((e+n)/2);t>i.fPoly[a].fX?e=a:n=a}return e}createDummyHisto(){const t=this.getObject();let i=0,e=1,n=0,a=1;t.fPoly&&(i=e=t.fPoly[0].fX,n=a=t.fPoly[0].fY,t.fPoly.forEach(s=>{i=Math.min(s.fX,i),e=Math.max(s.fX,e),n=Math.min(s.fY,n),a=Math.max(s.fY,a)}),a>0&&(a*=1+c.gStyle.fHistTopMargin),n<0&&(n*=1+c.gStyle.fHistTopMargin));const r=(0,c.createHistogram)(c.clTH1I,10);return r.fName=t.fName+"_hist",r.fTitle=t.fTitle,r.fBits|=c.kNoStats,r.fXaxis.fXmin=i,r.fXaxis.fXmax=e,r.fYaxis.fXmin=n,r.fYaxis.fXmax=a,r.fMinimum=n,r.fMaximum=a,r}processTooltipEvent(t){const i=this.getObject(),e=this.getFramePainter()?.getGrFuncs(this.options.second_x,this.options.second_y);let a,r,n=!1,s=null,o=0;null!==t&&i&&e?(a=e.revertAxis("x",t.x),o=this.findX(a),s=i.fPoly[o],r=this.eval(s,a),o<i.fN-1&&Math.abs(i.fPoly[o+1].fX-a)<Math.abs(a-s.fX)&&(s=i.fPoly[++o]),Math.abs(e.grx(s.fX)-t.x)<.5*this.knot_size?(a=s.fX,r=s.fY):(s=null,(a<i.fXmin||a>i.fXmax)&&(n=!0))):n=!0;let l=this.draw_g?.selectChild(".tooltip_bin");const h=this.lineatt.width+3;if(n||!this.draw_g)return l?.remove(),null;l.empty()&&(l=this.draw_g.append("svg:circle").attr("class","tooltip_bin").style("pointer-events","none").attr("r",h).style("fill","none").call(this.lineatt.func));const f={name:this.getObject().fName,title:this.getObject().fTitle,x:e.grx(a),y:e.gry(r),color1:this.lineatt.color,lines:[],exact:null!==s||Math.abs(e.gry(r)-t.y)<h};f.changed=l.property("current_xx")!==a,f.menu=f.exact,f.menu_dist=Math.sqrt((f.x-t.x)**2+(f.y-t.y)**2),f.changed&&l.attr("cx",Math.round(f.x)).attr("cy",Math.round(f.y)).property("current_xx",a);const m=this.getObjectHint();return m&&f.lines.push(m),f.lines.push(`x = ${e.axisAsText("x",a)}`,`y = ${e.axisAsText("y",r)}`),null!==s&&(f.lines.push(`knot = ${o}`,`B = ${(0,d.lg)(s.fB,c.gStyle.fStatFormat)}`,`C = ${(0,d.lg)(s.fC,c.gStyle.fStatFormat)}`,`D = ${(0,d.lg)(s.fD,c.gStyle.fStatFormat)}`),void 0!==s.fE&&void 0!==s.fF&&f.lines.push(`E = ${(0,d.lg)(s.fE,c.gStyle.fStatFormat)}`,`F = ${(0,d.lg)(s.fF,c.gStyle.fStatFormat)}`)),f}redraw(){const t=this.getObject(),i=this.getFramePainter(),e=i.getGrFuncs(this.options.second_x,this.options.second_y),n=i.getFrameWidth(),a=i.getFrameHeight();if(this.createG(!0),this.knot_size=5,this.createAttLine({attr:t}),this.options.Line||this.options.Curve){const r=Math.max(10,t.fNpx),s=[];let o=Math.max(e.scale_xmin,t.fXmin),l=Math.min(e.scale_xmax,t.fXmax),h=this.findX(o);i.logx&&(o=Math.log(o),l=Math.log(l));for(let f=0;f<r;++f){let m=o+(l-o)/r*(f-1);for(i.logx&&(m=Math.exp(m));h<t.fNp-1&&m>t.fPoly[h+1].fX;)++h;const _=this.eval(t.fPoly[h],m);s.push({x:m,y:_,grx:e.grx(m),gry:e.gry(_)})}this.draw_g.append("svg:path").attr("class","line").attr("d",(0,d.Mw)(s)).style("fill","none").call(this.lineatt.func)}if(this.options.Mark){let r="";this.createAttMarker({attr:t}),this.markeratt.resetPos(),this.knot_size=this.markeratt.getFullSize();for(let s=0;s<t.fPoly.length;s++){const o=t.fPoly[s],l=e.grx(o.fX);if(l>-this.knot_size&&l<n+this.knot_size){const h=e.gry(o.fY);h>-this.knot_size&&h<a+this.knot_size&&(r+=this.markeratt.create(l,h))}}r&&this.draw_g.append("svg:path").attr("d",r).call(this.markeratt.func)}}canZoomInside(t){return"x"===t&&!!this.getObject()}decodeOptions(t){const i=new d.nC(t);this.options||(this.options={});const e=!!this.getMainPainter();Object.assign(this.options,{Same:i.check("SAME"),Line:i.check("L"),Curve:i.check("C"),Mark:i.check("P"),Hopt:"",second_x:!1,second_y:!1}),!this.options.Line&&!this.options.Curve&&!this.options.Mark&&(this.options.Curve=!0),i.check("X+")&&(this.options.Hopt+="X+",this.options.second_x=e),i.check("Y+")&&(this.options.Hopt+="Y+",this.options.second_y=e),this.storeDrawOpt(t)}static draw(t,i,e){return(0,x.A)(function*(){const n=new u(t,i);n.decodeOptions(e);const a=!n.getMainPainter();let r=Promise.resolve();if(a||n.options.second_x||n.options.second_y){if(n.options.Same&&a)return console.warn("TSpline painter requires histogram to be drawn"),null;const s=n.createDummyHisto();r=M.TH1Painter.draw(t,s,n.options.Hopt)}return r.then(()=>(n.addToPadPrimitives(),n.redraw(),n))})()}}}}]);