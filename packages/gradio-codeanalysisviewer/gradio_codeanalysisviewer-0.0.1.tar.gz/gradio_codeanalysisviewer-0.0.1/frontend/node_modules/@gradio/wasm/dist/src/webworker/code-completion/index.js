import code_completion_py from "./code_completion.py?raw";
export class CodeCompleter {
    pyodide;
    setupPromise;
    constructor(pyodide) {
        this.pyodide = pyodide;
        // NOTE: obviously this constructor has a side effect on the Pyodide instance.
        this.setupPromise = this.setup().catch((err) => {
            console.error("Error while setting up code completion", err);
            return null;
        });
    }
    async setup() {
        const micropip = this.pyodide.pyimport("micropip");
        await micropip.install.callKwargs(["jedi"], {
            keep_going: true
        });
        this.pyodide.runPython(code_completion_py);
        return this.pyodide.globals.get("get_code_completions");
    }
    async getCodeCompletions(request) {
        const getCodeCompletionsPyFn = await this.setupPromise;
        if (!getCodeCompletionsPyFn) {
            // Setting up failed, return empty response
            console.debug("Code completion setup failed, returning empty response");
            return [];
        }
        const { code, line, column } = request;
        const completionsPy = getCodeCompletionsPyFn(code, line, column);
        const completions = completionsPy.toJs({
            dict_converter: Object.fromEntries // dict -> object
        });
        // > ... If the return value is a PyProxy, you must explicitly destroy it or else it will be leaked.
        // https://pyodide.org/en/stable/usage/type-conversions.html#calling-python-objects-from-javascript
        completionsPy.destroy();
        return completions;
    }
}
