var U=Object.defineProperty;var x=(n,e,t)=>e in n?U(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t;var v=(n,e,t)=>(x(n,typeof e!="symbol"?e+"":e,t),t);function z(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}function y(n){if(typeof n!="string")throw new TypeError("Path must be a string. Received "+JSON.stringify(n))}function C(n,e){for(var t="",i=0,o=-1,a=0,s,r=0;r<=n.length;++r){if(r<n.length)s=n.charCodeAt(r);else{if(s===47)break;s=47}if(s===47){if(!(o===r-1||a===1))if(o!==r-1&&a===2){if(t.length<2||i!==2||t.charCodeAt(t.length-1)!==46||t.charCodeAt(t.length-2)!==46){if(t.length>2){var l=t.lastIndexOf("/");if(l!==t.length-1){l===-1?(t="",i=0):(t=t.slice(0,l),i=t.length-1-t.lastIndexOf("/")),o=r,a=0;continue}}else if(t.length===2||t.length===1){t="",i=0,o=r,a=0;continue}}e&&(t.length>0?t+="/..":t="..",i=2)}else t.length>0?t+="/"+n.slice(o+1,r):t=n.slice(o+1,r),i=r-o-1;o=r,a=0}else s===46&&a!==-1?++a:a=-1}return t}function W(n,e){var t=e.dir||e.root,i=e.base||(e.name||"")+(e.ext||"");return t?t===e.root?t+i:t+n+i:i}var b={resolve:function(){for(var e="",t=!1,i,o=arguments.length-1;o>=-1&&!t;o--){var a;o>=0?a=arguments[o]:(i===void 0&&(i=process.cwd()),a=i),y(a),a.length!==0&&(e=a+"/"+e,t=a.charCodeAt(0)===47)}return e=C(e,!t),t?e.length>0?"/"+e:"/":e.length>0?e:"."},normalize:function(e){if(y(e),e.length===0)return".";var t=e.charCodeAt(0)===47,i=e.charCodeAt(e.length-1)===47;return e=C(e,!t),e.length===0&&!t&&(e="."),e.length>0&&i&&(e+="/"),t?"/"+e:e},isAbsolute:function(e){return y(e),e.length>0&&e.charCodeAt(0)===47},join:function(){if(arguments.length===0)return".";for(var e,t=0;t<arguments.length;++t){var i=arguments[t];y(i),i.length>0&&(e===void 0?e=i:e+="/"+i)}return e===void 0?".":b.normalize(e)},relative:function(e,t){if(y(e),y(t),e===t||(e=b.resolve(e),t=b.resolve(t),e===t))return"";for(var i=1;i<e.length&&e.charCodeAt(i)===47;++i);for(var o=e.length,a=o-i,s=1;s<t.length&&t.charCodeAt(s)===47;++s);for(var r=t.length,l=r-s,d=a<l?a:l,p=-1,c=0;c<=d;++c){if(c===d){if(l>d){if(t.charCodeAt(s+c)===47)return t.slice(s+c+1);if(c===0)return t.slice(s+c)}else a>d&&(e.charCodeAt(i+c)===47?p=c:c===0&&(p=0));break}var h=e.charCodeAt(i+c),g=t.charCodeAt(s+c);if(h!==g)break;h===47&&(p=c)}var m="";for(c=i+p+1;c<=o;++c)(c===o||e.charCodeAt(c)===47)&&(m.length===0?m+="..":m+="/..");return m.length>0?m+t.slice(s+p):(s+=p,t.charCodeAt(s)===47&&++s,t.slice(s))},_makeLong:function(e){return e},dirname:function(e){if(y(e),e.length===0)return".";for(var t=e.charCodeAt(0),i=t===47,o=-1,a=!0,s=e.length-1;s>=1;--s)if(t=e.charCodeAt(s),t===47){if(!a){o=s;break}}else a=!1;return o===-1?i?"/":".":i&&o===1?"//":e.slice(0,o)},basename:function(e,t){if(t!==void 0&&typeof t!="string")throw new TypeError('"ext" argument must be a string');y(e);var i=0,o=-1,a=!0,s;if(t!==void 0&&t.length>0&&t.length<=e.length){if(t.length===e.length&&t===e)return"";var r=t.length-1,l=-1;for(s=e.length-1;s>=0;--s){var d=e.charCodeAt(s);if(d===47){if(!a){i=s+1;break}}else l===-1&&(a=!1,l=s+1),r>=0&&(d===t.charCodeAt(r)?--r===-1&&(o=s):(r=-1,o=l))}return i===o?o=l:o===-1&&(o=e.length),e.slice(i,o)}else{for(s=e.length-1;s>=0;--s)if(e.charCodeAt(s)===47){if(!a){i=s+1;break}}else o===-1&&(a=!1,o=s+1);return o===-1?"":e.slice(i,o)}},extname:function(e){y(e);for(var t=-1,i=0,o=-1,a=!0,s=0,r=e.length-1;r>=0;--r){var l=e.charCodeAt(r);if(l===47){if(!a){i=r+1;break}continue}o===-1&&(a=!1,o=r+1),l===46?t===-1?t=r:s!==1&&(s=1):t!==-1&&(s=-1)}return t===-1||o===-1||s===0||s===1&&t===o-1&&t===i+1?"":e.slice(t,o)},format:function(e){if(e===null||typeof e!="object")throw new TypeError('The "pathObject" argument must be of type Object. Received type '+typeof e);return W("/",e)},parse:function(e){y(e);var t={root:"",dir:"",base:"",ext:"",name:""};if(e.length===0)return t;var i=e.charCodeAt(0),o=i===47,a;o?(t.root="/",a=1):a=0;for(var s=-1,r=0,l=-1,d=!0,p=e.length-1,c=0;p>=a;--p){if(i=e.charCodeAt(p),i===47){if(!d){r=p+1;break}continue}l===-1&&(d=!1,l=p+1),i===46?s===-1?s=p:c!==1&&(c=1):s!==-1&&(c=-1)}return s===-1||l===-1||c===0||c===1&&s===l-1&&s===r+1?l!==-1&&(r===0&&o?t.base=t.name=e.slice(1,l):t.base=t.name=e.slice(r,l)):(r===0&&o?(t.name=e.slice(1,s),t.base=e.slice(1,l)):(t.name=e.slice(r,s),t.base=e.slice(r,l)),t.ext=e.slice(s,l)),r>0?t.dir=e.slice(0,r-1):o&&(t.dir="/"),t},sep:"/",delimiter:":",win32:null,posix:null};b.posix=b;var G=b;const O=z(G),Y="/home/pyodide",I=n=>`${Y}/${n}`,S=(n,e)=>O.resolve(I(n),e);function M(n,e){const t=O.normalize(e),o=O.dirname(t).split("/"),a=[];for(const s of o){a.push(s);const r=a.join("/");if(n.FS.analyzePath(r).exists){if(n.FS.isDir(r))throw new Error(`"${r}" already exists and is not a directory.`);continue}try{n.FS.mkdir(r)}catch(l){throw console.error(`Failed to create a directory "${r}"`),l}}}function D(n,e,t,i){M(n,e),n.FS.writeFile(e,t,i)}function j(n,e,t){M(n,t),n.FS.rename(e,t)}function B(n){n.forEach(e=>{let t;try{t=new URL(e)}catch{return}if(t.protocol==="emfs:"||t.protocol==="file:")throw new Error(`"emfs:" and "file:" protocols are not allowed for the requirement (${e})`)})}function $(n,e){const t=n.pyimport("packaging.requirements.Requirement");try{const i=t(e);return i.name==="plotly"&&i.specifier.contains("6")}catch{return!1}}function V(n,e){const t=n.pyimport("packaging.requirements.Requirement");try{return t(e).name==="altair"}catch{return!1}}function J(n,e){return e.some(t=>V(n,t))?e.map(t=>$(n,t)?"plotly==5.*":t):e}class K{constructor(){v(this,"_buffer",[]);v(this,"_promise");v(this,"_resolve");this._resolve=null,this._promise=null,this._notifyAll()}async _wait(){await this._promise}_notifyAll(){this._resolve&&this._resolve(),this._promise=new Promise(e=>this._resolve=e)}async dequeue(){for(;this._buffer.length===0;)await this._wait();return this._buffer.shift()}enqueue(e){this._buffer.push(e),this._notifyAll()}}function Q(n,e,t){const i=new K;t.addEventListener("message",s=>{i.enqueue(s.data)}),t.start();async function o(){return await i.dequeue()}async function a(s){const r=Object.fromEntries(s.toJs());t.postMessage(r)}return n(e,o,a)}const L="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";function X(n){return Array.from(Array(n)).map(()=>L[Math.floor(Math.random()*L.length)]).join("")}const Z=`import jedi


def get_code_completions(code: str, line: int, column: int):
    script = jedi.Script(code)
    completions = script.complete(line, column)
    serializable_completions = [
        {
            "label": completion.name,
            "type": completion.type,
            "docstring": completion.docstring(raw=True),
            "completion_prefix_length": completion.get_completion_prefix_length(),
        }
        for completion in completions
    ]
    return serializable_completions
`;class ee{constructor(e){v(this,"setupPromise");this.pyodide=e,this.setupPromise=this.setup().catch(t=>(console.error("Error while setting up code completion",t),null))}async setup(){return await this.pyodide.pyimport("micropip").install.callKwargs(["jedi"],{keep_going:!0}),this.pyodide.runPython(Z),this.pyodide.globals.get("get_code_completions")}async getCodeCompletions(e){const t=await this.setupPromise;if(!t)return console.debug("Code completion setup failed, returning empty response"),[];const{code:i,line:o,column:a}=e,s=t(i,o,a),r=s.toJs({dict_converter:Object.fromEntries});return s.destroy(),r}}const te=`import ast
import os
import sys
import tokenize
import types
from inspect import CO_COROUTINE

from gradio.wasm_utils import app_id_context

# BSD 3-Clause License
#
# - Copyright (c) 2008-Present, IPython Development Team
# - Copyright (c) 2001-2007, Fernando Perez <fernando.perez@colorado.edu>
# - Copyright (c) 2001, Janko Hauser <jhauser@zscout.de>
# - Copyright (c) 2001, Nathaniel Gray <n8gray@caltech.edu>
#
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# * Redistributions of source code must retain the above copyright notice, this
#   list of conditions and the following disclaimer.

# * Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.

# * Neither the name of the copyright holder nor the names of its
#   contributors may be used to endorse or promote products derived from
#   this software without specific prior written permission.

# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

# Code modified from IPython (BSD license)
# Source: https://github.com/ipython/ipython/blob/master/IPython/utils/syspathcontext.py#L42
class modified_sys_path:  # noqa: N801
    """A context for prepending a directory to sys.path for a second."""

    def __init__(self, script_path: str):
        self._script_path = script_path
        self._added_path = False

    def __enter__(self):
        if self._script_path not in sys.path:
            sys.path.insert(0, self._script_path)
            self._added_path = True

    def __exit__(self, type, value, traceback):
        if self._added_path:
            try:
                sys.path.remove(self._script_path)
            except ValueError:
                # It's already removed.
                pass

        # Returning False causes any exceptions to be re-raised.
        return False


# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022)
# Copyright (c) Yuichiro Tachibana (2023)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
def _new_module(name: str) -> types.ModuleType:
    """Create a new module with the given name."""
    return types.ModuleType(name)


def set_home_dir(home_dir: str) -> None:
    os.environ["HOME"] = home_dir
    os.chdir(home_dir)


async def _run_script(app_id: str, home_dir: str, script_path: str) -> None:
    # This function is based on the following code from Streamlit:
    # https://github.com/streamlit/streamlit/blob/1.24.0/lib/streamlit/runtime/scriptrunner/script_runner.py#L519-L554
    # with modifications to support top-level await.
    set_home_dir(home_dir)

    with tokenize.open(script_path) as f:
        filebody = f.read()

    await _run_code(app_id, home_dir, filebody, script_path)


async def _run_code(
        app_id: str,
        home_dir: str,
        filebody: str,
        script_path: str = '<string>'  # This default value follows the convention. Ref: https://docs.python.org/3/library/functions.html#compile
    ) -> None:
    set_home_dir(home_dir)

    # NOTE: In Streamlit, the bytecode caching mechanism has been introduced.
    # However, we skipped it here for simplicity and because Gradio doesn't need to rerun the script so frequently,
    # while we may do it in the future.
    bytecode = compile(  # type: ignore
        filebody,
        # Pass in the file path so it can show up in exceptions.
        script_path,
        # We're compiling entire blocks of Python, so we need "exec"
        # mode (as opposed to "eval" or "single").
        mode="exec",
        # Don't inherit any flags or "future" statements.
        flags=ast.PyCF_ALLOW_TOP_LEVEL_AWAIT, # Allow top-level await. Ref: https://github.com/whitphx/streamlit/commit/277dc580efb315a3e9296c9a0078c602a0904384
        dont_inherit=1,
        # Use the default optimization options.
        optimize=-1,
    )

    module = _new_module("__main__")

    # Install the fake module as the __main__ module. This allows
    # the pickle module to work inside the user's code, since it now
    # can know the module where the pickled objects stem from.
    # IMPORTANT: This means we can't use "if __name__ == '__main__'" in
    # our code, as it will point to the wrong module!!!
    sys.modules["__main__"] = module

    # Add special variables to the module's globals dict.
    module.__dict__["__file__"] = script_path

    with modified_sys_path(script_path), modified_sys_path(home_dir), app_id_context(app_id):
        # Allow top-level await. Ref: https://github.com/whitphx/streamlit/commit/277dc580efb315a3e9296c9a0078c602a0904384
        if bytecode.co_flags & CO_COROUTINE:
            # The source code includes top-level awaits, so the compiled code object is a coroutine.
            await eval(bytecode, module.__dict__)
        else:
            exec(bytecode, module.__dict__)
`,ne=`# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022)
# Copyright (c) Yuichiro Tachibana (2023)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import fnmatch
import logging
import os
import sys
import types
from typing import Optional, Set

LOGGER = logging.getLogger(__name__)

#
# Copied from https://github.com/streamlit/streamlit/blob/1.24.0/lib/streamlit/file_util.py
#

def file_is_in_folder_glob(filepath, folderpath_glob) -> bool:
    """Test whether a file is in some folder with globbing support.

    Parameters
    ----------
    filepath : str
        A file path.
    folderpath_glob: str
        A path to a folder that may include globbing.

    """
    # Make the glob always end with "/*" so we match files inside subfolders of
    # folderpath_glob.
    if not folderpath_glob.endswith("*"):
        if folderpath_glob.endswith("/"):
            folderpath_glob += "*"
        else:
            folderpath_glob += "/*"

    file_dir = os.path.dirname(filepath) + "/"
    return fnmatch.fnmatch(file_dir, folderpath_glob)


def get_directory_size(directory: str) -> int:
    """Return the size of a directory in bytes."""
    total_size = 0
    for dirpath, _, filenames in os.walk(directory):
        for f in filenames:
            fp = os.path.join(dirpath, f)
            total_size += os.path.getsize(fp)
    return total_size


def file_in_pythonpath(filepath) -> bool:
    """Test whether a filepath is in the same folder of a path specified in the PYTHONPATH env variable.


    Parameters
    ----------
    filepath : str
        An absolute file path.

    Returns
    -------
    boolean
        True if contained in PYTHONPATH, False otherwise. False if PYTHONPATH is not defined or empty.

    """
    pythonpath = os.environ.get("PYTHONPATH", "")
    if len(pythonpath) == 0:
        return False

    absolute_paths = [os.path.abspath(path) for path in pythonpath.split(os.pathsep)]
    return any(
        file_is_in_folder_glob(os.path.normpath(filepath), path)
        for path in absolute_paths
    )

#
# Copied from https://github.com/streamlit/streamlit/blob/1.24.0/lib/streamlit/watcher/local_sources_watcher.py
#

def get_module_paths(module: types.ModuleType) -> Set[str]:
    paths_extractors = [
        # https://docs.python.org/3/reference/datamodel.html
        # __file__ is the pathname of the file from which the module was loaded
        # if it was loaded from a file.
        # The __file__ attribute may be missing for certain types of modules
        lambda m: [m.__file__],
        # https://docs.python.org/3/reference/import.html#__spec__
        # The __spec__ attribute is set to the module spec that was used
        # when importing the module. one exception is __main__,
        # where __spec__ is set to None in some cases.
        # https://www.python.org/dev/peps/pep-0451/#id16
        # "origin" in an import context means the system
        # (or resource within a system) from which a module originates
        # ... It is up to the loader to decide on how to interpret
        # and use a module's origin, if at all.
        lambda m: [m.__spec__.origin],
        # https://www.python.org/dev/peps/pep-0420/
        # Handling of "namespace packages" in which the __path__ attribute
        # is a _NamespacePath object with a _path attribute containing
        # the various paths of the package.
        lambda m: list(m.__path__._path),
    ]

    all_paths = set()
    for extract_paths in paths_extractors:
        potential_paths = []
        try:
            potential_paths = extract_paths(module)
        except AttributeError:
            # Some modules might not have __file__ or __spec__ attributes.
            pass
        except Exception as e:
            LOGGER.warning(f"Examining the path of {module.__name__} raised: {e}")

        all_paths.update(
            [os.path.abspath(str(p)) for p in potential_paths if _is_valid_path(p)]
        )
    return all_paths


def _is_valid_path(path: Optional[str]) -> bool:
    return isinstance(path, str) and (os.path.isfile(path) or os.path.isdir(path))


#
# Original code
#

def unload_local_modules(target_dir_path: str = "."):
    """ Unload all modules that are in the target directory or in a subdirectory of it.
    It is necessary to unload modules before re-executing a script that imports the modules,
    so that the new version of the modules is loaded.
    The module unloading feature is extracted from Streamlit's LocalSourcesWatcher (https://github.com/streamlit/streamlit/blob/1.24.0/lib/streamlit/watcher/local_sources_watcher.py)
    and packaged as a standalone function.
    """
    target_dir_path = os.path.abspath(target_dir_path)
    loaded_modules = {} # filepath -> module_name

    # Copied from \`LocalSourcesWatcher.update_watched_modules()\`
    module_paths = {
        name: get_module_paths(module)
        for name, module in dict(sys.modules).items()
    }

    # Copied from \`LocalSourcesWatcher._register_necessary_watchers()\`
    for name, paths in module_paths.items():
        for path in paths:
            if file_is_in_folder_glob(path, target_dir_path) or file_in_pythonpath(path):
                loaded_modules[path] = name

    # Copied from \`LocalSourcesWatcher.on_file_changed()\`
    for module_name in loaded_modules.values():
        if module_name is not None and module_name in sys.modules:
            del sys.modules[module_name]
`;importScripts("https://cdn.jsdelivr.net/pyodide/v0.27.3/full/pyodide.js");let F,H,q,R;async function k(n,e,t,i=3){const o=J(n,t);for(let a=0;a<i;a++){const s=a===i-1;try{return e.install.callKwargs(o,{keep_going:!0})}catch(r){if(s)throw r;console.error("Failed to install packages. Retrying...",r)}}}async function oe(n,e,t,i){console.debug("Loading Pyodide."),e("Loading Pyodide");const o=await loadPyodide({stdout:t,stderr:i});console.debug("Pyodide is loaded."),console.debug("Loading micropip"),e("Loading micropip"),await o.loadPackage("micropip");const a=o.pyimport("micropip");console.debug("micropip is loaded.");const s=[n.gradioWheelUrl,n.gradioClientWheelUrl];console.debug("Loading Gradio wheels.",s),e("Loading Gradio wheels"),await o.loadPackage(["ssl","setuptools"]),await a.add_mock_package("ffmpy","0.3.0"),await k(o,a,s),console.debug("Gradio wheels are loaded."),console.debug("Mocking os module methods."),e("Mock os module methods"),await o.runPythonAsync(`
import os

os.link = lambda src, dst: None
`),console.debug("os module methods are mocked."),console.debug("Importing gradio package."),e("Importing gradio package"),await o.runPythonAsync("import gradio"),console.debug("gradio package is imported."),console.debug("Defining a ASGI wrapper function."),e("Defining a ASGI wrapper function"),await o.runPythonAsync(`
# Based on Shiny's App.call_pyodide().
# https://github.com/rstudio/py-shiny/blob/v0.3.3/shiny/_app.py#L224-L258
async def _call_asgi_app_from_js(app_id, scope, receive, send):
	# TODO: Pretty sure there are objects that need to be destroy()'d here?
	scope = scope.to_py()

	# ASGI requires some values to be byte strings, not character strings. Those are
	# not that easy to create in JavaScript, so we let the JS side pass us strings
	# and we convert them to bytes here.
	if "headers" in scope:
			# JS doesn't have \`bytes\` so we pass as strings and convert here
			scope["headers"] = [
					[value.encode("latin-1") for value in header]
					for header in scope["headers"]
			]
	if "query_string" in scope and scope["query_string"]:
			scope["query_string"] = scope["query_string"].encode("latin-1")
	if "raw_path" in scope and scope["raw_path"]:
			scope["raw_path"] = scope["raw_path"].encode("latin-1")

	async def rcv():
			event = await receive()
			py_event = event.to_py()
			if "body" in py_event:
					if isinstance(py_event["body"], memoryview):
							py_event["body"] = py_event["body"].tobytes()
			return py_event

	async def snd(event):
			await send(event)

	app = gradio.wasm_utils.get_registered_app(app_id)
	if app is None:
		raise RuntimeError("Gradio app has not been launched.")

	await app(scope, rcv, snd)
`),F=o.globals.get("_call_asgi_app_from_js"),console.debug("The ASGI wrapper function is defined."),console.debug("Mocking async libraries."),e("Mocking async libraries"),await o.runPythonAsync(`
async def mocked_anyio_to_thread_run_sync(func, *args, cancellable=False, limiter=None):
	return func(*args)

import anyio.to_thread
anyio.to_thread.run_sync = mocked_anyio_to_thread_run_sync
	`),console.debug("Async libraries are mocked."),console.debug("Setting up Python utility functions."),e("Setting up Python utility functions"),await o.runPythonAsync(te),H=o.globals.get("_run_code"),q=o.globals.get("_run_script"),await o.runPythonAsync(ne),R=o.globals.get("unload_local_modules"),console.debug("Python utility functions are set up."),e("Initialization completed");const r=new ee(o);return{pyodide:o,micropip:a,codeCompleter:r}}async function ie(n,e,t,i,o,a){const s=I(t);console.debug("Creating a home directory for the app.",{appId:t,appHomeDir:s}),n.FS.mkdir(s),console.debug("Mounting files.",i.files),o("Mounting files");const r=[];await Promise.all(Object.keys(i.files).map(async h=>{const g=i.files[h];let m;"url"in g?(console.debug(`Fetch a file from ${g.url}`),m=await fetch(g.url).then(_=>_.arrayBuffer()).then(_=>new Uint8Array(_))):m=g.data;const{opts:u}=i.files[h],f=S(t,h);console.debug(`Write a file "${f}"`),D(n,f,m,u),typeof m=="string"&&h.endsWith(".py")&&r.push(m)})),console.debug("Files are mounted."),console.debug("Installing packages.",i.requirements),o("Installing packages"),await k(n,e,i.requirements),console.debug("Packages are installed."),console.debug("Auto-loading modules.");const l=await Promise.all(r.map(h=>n.loadPackagesFromImports(h))),d=new Set(l.flat()),p=Array.from(d);p.length>0&&a(p);const c=p.map(h=>h.name);console.debug("Modules are auto-loaded.",p),(i.requirements.includes("matplotlib")||c.includes("matplotlib"))&&(console.debug("Setting matplotlib backend."),o("Setting matplotlib backend"),await n.runPythonAsync(`
try:
	import matplotlib
	matplotlib.use("agg")
except ImportError:
	pass
`),console.debug("matplotlib backend is set.")),o("App is now loaded")}const P=self;"postMessage"in P?N(P):P.onconnect=n=>{const e=n.ports[0];N(e),e.start()};let A;function N(n){const e=X(8);console.debug("Set up a new app.",{appId:e});const t=l=>{n.postMessage({type:"progress-update",data:{log:l}})},i=l=>{console.log(l),n.postMessage({type:"stdout",data:{output:l}})},o=l=>{console.error(l),n.postMessage({type:"stderr",data:{output:l}})},a=l=>{console.error("Python error:",l),n.postMessage({type:"python-error",data:{traceback:l}})},s=l=>{const d={type:"modules-auto-loaded",data:{packages:l}};n.postMessage(d)};let r;n.onmessage=async function(l){const d=l.data;console.debug("worker.onmessage",d);const p=l.ports[0];try{if(d.type==="init-env"){A==null?A=oe(d.data,t,i,o):t("Pyodide environment initialization is ongoing in another session"),A.then(()=>{const u={type:"reply:success",data:null};p.postMessage(u)}).catch(u=>{const f={type:"reply:error",error:u};p.postMessage(f)});return}if(A==null)throw new Error("Pyodide Initialization is not started.");const{pyodide:c,micropip:h,codeCompleter:g}=await A;if(c.pyimport("gradio").wasm_utils.register_error_traceback_callback(e,a),d.type==="init-app"){r=ie(c,h,e,d.data,t,s);const u={type:"reply:success",data:null};p.postMessage(u);return}if(r==null)throw new Error("App initialization is not started.");switch(await r,d.type){case"echo":{const u={type:"reply:success",data:d.data};p.postMessage(u);break}case"run-python-code":{R(),console.debug("Auto install the requirements");const u=await c.loadPackagesFromImports(d.data.code);u.length>0&&s(u),console.debug("Modules are auto-loaded.",u),await H(e,I(e),d.data.code);const f={type:"reply:success",data:null};p.postMessage(f);break}case"run-python-file":{R(),await q(e,I(e),d.data.path);const u={type:"reply:success",data:null};p.postMessage(u);break}case"asgi-request":{console.debug("ASGI request",d.data),Q(F.bind(null,e),d.data.scope,p);break}case"file:write":{const{path:u,data:f,opts:_}=d.data;if(typeof f=="string"&&u.endsWith(".py")){console.debug(`Auto install the requirements in ${u}`);const E=await c.loadPackagesFromImports(f);E.length>0&&s(E),console.debug("Modules are auto-loaded.",E)}const w=S(e,u);console.debug(`Write a file "${w}"`),D(c,w,f,_);const T={type:"reply:success",data:null};p.postMessage(T);break}case"file:rename":{const{oldPath:u,newPath:f}=d.data,_=S(e,u),w=S(e,f);console.debug(`Rename "${_}" to ${w}`),j(c,_,w);const T={type:"reply:success",data:null};p.postMessage(T);break}case"file:unlink":{const{path:u}=d.data,f=S(e,u);console.debug(`Remove "${f}`),c.FS.unlink(f);const _={type:"reply:success",data:null};p.postMessage(_);break}case"install":{const{requirements:u}=d.data;console.debug("Install the requirements:",u),B(u),await k(c,h,u).then(()=>{if(u.includes("matplotlib"))return c.runPythonAsync(`
try:
	import matplotlib
	matplotlib.use("agg")
except ImportError:
	pass
`)}).then(()=>{console.debug("Successfully installed");const f={type:"reply:success",data:null};p.postMessage(f)});break}case"code-completion":{const u=d.data,_={type:"reply:success",data:await g.getCodeCompletions(u)};p.postMessage(_);break}}}catch(c){if(console.error(c),!(c instanceof Error))throw c;const h=new Error(c.message);h.name=c.name,h.stack=c.stack;const g={type:"reply:error",error:h};p.postMessage(g)}}}
