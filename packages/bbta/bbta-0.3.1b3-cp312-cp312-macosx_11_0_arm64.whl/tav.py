"""
Package tav provides a gopy-compatible wrapper for the github.com/banbox/banta/tav library.
It modifies functions with multiple return values to return a single array of slices,
making them suitable for Python bindings generation.

"""
# python wrapper for package github.com/banbox/banta/python/tav within overall package bbta
# This is what you import to use the package.
# File is generated by gopy. Do not edit.
# gopy build -no-make -dynamic-link=True -output build/lib.macosx-11.0-arm64-cpython-312 -name bbta -vm /private/var/folders/vk/nx37ffx50hv5djclhltc26vw0000gn/T/cibw-run-4bsh9hli/cp312-macosx_arm64/build/venv/bin/python -rename=true github.com/banbox/banta/python/ta github.com/banbox/banta/python/tav

# the following is required to enable dlopen to open the _go.so file
import os,sys,inspect,collections
try:
	import collections.abc as _collections_abc
except ImportError:
	_collections_abc = collections

cwd = os.getcwd()
currentdir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
os.chdir(currentdir)
from . import _bbta
from . import go

os.chdir(cwd)

# to use this code in your end-user python file, import it as follows:
# from bbta import tav
# and then refer to everything using tav. prefix
# packages imported by this package listed below:




# ---- Types ---

# Python type for slice [2][]float64
class Array_2_Slice_float64(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_bbta.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_bbta.IncRef(self.handle)
	def __del__(self):
		_bbta.DecRef(self.handle)
	def __str__(self):
		s = 'tav.Array_2_Slice_float64 len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'tav.Array_2_Slice_float64([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _bbta.Array_2_Slice_float64_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.Slice_float64(handle=_bbta.Array_2_Slice_float64_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_bbta.Array_2_Slice_float64_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.Slice_float64(handle=_bbta.Array_2_Slice_float64_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration

# Python type for slice [3][]float64
class Array_3_Slice_float64(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_bbta.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_bbta.IncRef(self.handle)
	def __del__(self):
		_bbta.DecRef(self.handle)
	def __str__(self):
		s = 'tav.Array_3_Slice_float64 len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'tav.Array_3_Slice_float64([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _bbta.Array_3_Slice_float64_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.Slice_float64(handle=_bbta.Array_3_Slice_float64_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_bbta.Array_3_Slice_float64_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.Slice_float64(handle=_bbta.Array_3_Slice_float64_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration

# Python type for slice [4][]float64
class Array_4_Slice_float64(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_bbta.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_bbta.IncRef(self.handle)
	def __del__(self):
		_bbta.DecRef(self.handle)
	def __str__(self):
		s = 'tav.Array_4_Slice_float64 len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'tav.Array_4_Slice_float64([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _bbta.Array_4_Slice_float64_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.Slice_float64(handle=_bbta.Array_4_Slice_float64_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_bbta.Array_4_Slice_float64_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.Slice_float64(handle=_bbta.Array_4_Slice_float64_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration


#---- Enums from Go (collections of consts with same type) ---


#---- Constants from Go: Python can only ask that you please don't change these! ---


# ---- Global Variables: can only use functions to access ---


# ---- Interfaces ---


# ---- Structs ---

# Python type for struct tav.TJson
class TJson(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_bbta.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_bbta.IncRef(self.handle)
		else:
			self.handle = _bbta.tav_TJson_CTor()
			_bbta.IncRef(self.handle)
			if  0 < len(args):
				self.Name = args[0]
			if "Name" in kwargs:
				self.Name = kwargs["Name"]
	def __del__(self):
		_bbta.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'tav.TJson{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'tav.TJson ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def name(self):
		return _bbta.tav_TJson_Name_Get(self.handle)
	@name.setter
	def name(self, value):
		if isinstance(value, go.GoClass):
			_bbta.tav_TJson_Name_Set(self.handle, value.handle)
		else:
			_bbta.tav_TJson_Name_Set(self.handle, value)


# ---- Slices ---


# ---- Maps ---


# ---- Constructors ---


# ---- Functions ---
def macd_by(data, fast, slow, smooth, initType):
	"""MACDBy([]float data, int fast, int slow, int smooth, int initType) [][]float
	
	MACDBy calculates the MACD with a specified initialization type.
	Returns [2][]float64{macd, signal}.
	"""
	return Array_2_Slice_float64(handle=_bbta.tav_MACDBy(data.handle, fast, slow, smooth, initType))
def plu_min_dm(high, low, cls, period):
	"""PluMinDM([]float high, []float low, []float cls, int period) [][]float
	
	PluMinDM calculates the Plus Directional Movement (+DM) and Minus Directional Movement (-DM).
	Returns [2][]float64{plusDM, minusDM}.
	"""
	return Array_2_Slice_float64(handle=_bbta.tav_PluMinDM(high.handle, low.handle, cls.handle, period))
def rsi_by(data, period, subVal):
	"""RSIBy([]float data, int period, float subVal) []float
	
	RSIBy calculates the Relative Strength Index with a subtraction value.
	"""
	return go.Slice_float64(handle=_bbta.tav_RSIBy(data.handle, period, subVal))
def adx_by(high, low, close, period, smoothing, method):
	"""ADXBy([]float high, []float low, []float close, int period, int smoothing, int method) []float
	
	ADXBy calculates the ADX with specified smoothing and method.
	"""
	return go.Slice_float64(handle=_bbta.tav_ADXBy(high.handle, low.handle, close.handle, period, smoothing, method))
def alma(data, period, sigma, distOff):
	"""ALMA([]float data, int period, float sigma, float distOff) []float
	
	ALMA calculates the Arnaud Legoux Moving Average.
	"""
	return go.Slice_float64(handle=_bbta.tav_ALMA(data.handle, period, sigma, distOff))
def hlc3(a, b, c):
	"""HLC3([]float a, []float b, []float c) []float
	
	HLC3 calculates the average of three series (e.g., high, low, and close).
	"""
	return go.Slice_float64(handle=_bbta.tav_HLC3(a.handle, b.handle, c.handle))
def kama(data, period):
	"""KAMA([]float data, int period) []float
	
	KAMA calculates the Kaufman's Adaptive Moving Average.
	"""
	return go.Slice_float64(handle=_bbta.tav_KAMA(data.handle, period))
def macd(data, fast, slow, smooth):
	"""MACD([]float data, int fast, int slow, int smooth) [][]float
	
	MACD calculates the Moving Average Convergence Divergence.
	Returns [2][]float64{macd, signal}.
	"""
	return Array_2_Slice_float64(handle=_bbta.tav_MACD(data.handle, fast, slow, smooth))
def sum(data, period):
	"""Sum([]float data, int period) []float
	
	Sum calculates the rolling sum of a series over a given period.
	"""
	return go.Slice_float64(handle=_bbta.tav_Sum(data.handle, period))
def cmo(data, period):
	"""CMO([]float data, int period) []float
	
	CMO calculates the Chande Momentum Oscillator.
	"""
	return go.Slice_float64(handle=_bbta.tav_CMO(data.handle, period))
def cti(data, period):
	"""CTI([]float data, int period) []float
	
	CTI calculates the Correlation Trend Indicator.
	"""
	return go.Slice_float64(handle=_bbta.tav_CTI(data.handle, period))
def hl2(a, b):
	"""HL2([]float a, []float b) []float
	
	HL2 calculates the average of two series (e.g., high and low).
	"""
	return go.Slice_float64(handle=_bbta.tav_HL2(a.handle, b.handle))
def will_r(high, low, close, period):
	"""WillR([]float high, []float low, []float close, int period) []float
	
	WillR calculates the Williams %R.
	"""
	return go.Slice_float64(handle=_bbta.tav_WillR(high.handle, low.handle, close.handle, period))
def ema_by(data, period, initType):
	"""EMABy([]float data, int period, int initType) []float
	
	EMABy calculates the Exponential Moving Average with a specified initialization type.
	"""
	return go.Slice_float64(handle=_bbta.tav_EMABy(data.handle, period, initType))
def heikin_ashi(open, high, low, close):
	"""HeikinAshi([]float open, []float high, []float low, []float close) [][]float
	
	HeikinAshi calculates Heikin-Ashi candlesticks.
	Returns [4][]float64{haOpen, haHigh, haLow, haClose}.
	"""
	return Array_4_Slice_float64(handle=_bbta.tav_HeikinAshi(open.handle, high.handle, low.handle, close.handle))
def lin_reg(data, period):
	"""LinReg([]float data, int period) []float
	
	LinReg calculates the Linear Regression.
	"""
	return go.Slice_float64(handle=_bbta.tav_LinReg(data.handle, period))
def stoch_rsi(obj, rsiLen, stochLen, maK, maD):
	"""StochRSI([]float obj, int rsiLen, int stochLen, int maK, int maD) [][]float
	
	StochRSI calculates the Stochastic RSI.
	Returns [2][]float64{k, d}.
	"""
	return Array_2_Slice_float64(handle=_bbta.tav_StochRSI(obj.handle, rsiLen, stochLen, maK, maD))
def vwma(price, volume, period):
	"""VWMA([]float price, []float volume, int period) []float
	
	VWMA calculates the Volume Weighted Moving Average.
	"""
	return go.Slice_float64(handle=_bbta.tav_VWMA(price.handle, volume.handle, period))
def tr(high, low, close):
	"""TR([]float high, []float low, []float close) []float
	
	TR calculates the True Range.
	"""
	return go.Slice_float64(handle=_bbta.tav_TR(high.handle, low.handle, close.handle))
def wma(data, period):
	"""WMA([]float data, int period) []float
	
	WMA calculates the Weighted Moving Average.
	"""
	return go.Slice_float64(handle=_bbta.tav_WMA(data.handle, period))
def crsi(data, period, upDn, rocVal):
	"""CRSI([]float data, int period, int upDn, int rocVal) []float
	
	CRSI calculates the Connors RSI.
	"""
	return go.Slice_float64(handle=_bbta.tav_CRSI(data.handle, period, upDn, rocVal))
def highest(data, period):
	"""Highest([]float data, int period) []float
	
	Highest finds the highest value over a specified period.
	"""
	return go.Slice_float64(handle=_bbta.tav_Highest(data.handle, period))
def rmi(data, period, montLen):
	"""RMI([]float data, int period, int montLen) []float
	
	RMI calculates the Relative Momentum Index.
	"""
	return go.Slice_float64(handle=_bbta.tav_RMI(data.handle, period, montLen))
def rsi(data, period):
	"""RSI([]float data, int period) []float
	
	RSI calculates the Relative Strength Index.
	"""
	return go.Slice_float64(handle=_bbta.tav_RSI(data.handle, period))
def stc(data, period, fast, slow, alpha):
	"""STC([]float data, int period, int fast, int slow, float alpha) []float
	
	STC calculates the Schaff Trend Cycle.
	"""
	return go.Slice_float64(handle=_bbta.tav_STC(data.handle, period, fast, slow, alpha))
def adx(high, low, close, period):
	"""ADX([]float high, []float low, []float close, int period) []float
	
	ADX calculates the Average Directional Index.
	"""
	return go.Slice_float64(handle=_bbta.tav_ADX(high.handle, low.handle, close.handle, period))
def lin_reg_adv(data, period, angle, intercept, degrees, r, slope, tsf):
	"""LinRegAdv([]float data, int period, bool angle, bool intercept, bool degrees, bool r, bool slope, bool tsf) []float
	
	LinRegAdv calculates advanced Linear Regression values.
	"""
	return go.Slice_float64(handle=_bbta.tav_LinRegAdv(data.handle, period, angle, intercept, degrees, r, slope, tsf))
def percent_rank(data, period):
	"""PercentRank([]float data, int period) []float
	
	PercentRank calculates the percentile rank of the current value over a period.
	"""
	return go.Slice_float64(handle=_bbta.tav_PercentRank(data.handle, period))
def stiffness(data, maLen, stiffLen, stiffMa):
	"""Stiffness([]float data, int maLen, int stiffLen, int stiffMa) []float
	
	Stiffness calculates the Stiffness indicator.
	"""
	return go.Slice_float64(handle=_bbta.tav_Stiffness(data.handle, maLen, stiffLen, stiffMa))
def atr(high, low, close, period):
	"""ATR([]float high, []float low, []float close, int period) []float
	
	ATR calculates the Average True Range.
	"""
	return go.Slice_float64(handle=_bbta.tav_ATR(high.handle, low.handle, close.handle, period))
def aroon(high, low, period):
	"""Aroon([]float high, []float low, int period) [][]float
	
	Aroon calculates the Aroon Indicator.
	Returns [3][]float64{aroonUp, aroonDown, aroonOscillator}.
	"""
	return Array_3_Slice_float64(handle=_bbta.tav_Aroon(high.handle, low.handle, period))
def bbands(data, period, stdUp, stdDn):
	"""BBANDS([]float data, int period, float stdUp, float stdDn) [][]float
	
	BBANDS calculates Bollinger Bands.
	Returns [3][]float64{upperBand, middleBand, lowerBand}.
	"""
	return Array_3_Slice_float64(handle=_bbta.tav_BBANDS(data.handle, period, stdUp, stdDn))
def avg_dev(data, period):
	"""AvgDev([]float data, int period) []float
	
	AvgDev calculates the Average Deviation.
	"""
	return go.Slice_float64(handle=_bbta.tav_AvgDev(data.handle, period))
def roc(data, period):
	"""ROC([]float data, int period) []float
	
	ROC calculates the Rate of Change.
	"""
	return go.Slice_float64(handle=_bbta.tav_ROC(data.handle, period))
def td(data):
	"""TD([]float data) []float
	
	TD calculates the Tom DeMark Sequential.
	"""
	return go.Slice_float64(handle=_bbta.tav_TD(data.handle))
def up_down(data, vtype):
	"""UpDown([]float data, int vtype) []float
	
	UpDown classifies price movement as up, down, or flat.
	"""
	return go.Slice_float64(handle=_bbta.tav_UpDown(data.handle, vtype))
def plu_min_di(high, low, close, period):
	"""PluMinDI([]float high, []float low, []float close, int period) [][]float
	
	PluMinDI calculates the Plus Directional Indicator (+DI) and Minus Directional Indicator (-DI).
	Returns [2][]float64{plusDI, minusDI}.
	"""
	return Array_2_Slice_float64(handle=_bbta.tav_PluMinDI(high.handle, low.handle, close.handle, period))
def ut_bot(c, atr, rate):
	"""UTBot([]float c, []float atr, float rate) []float
	
	UTBot calculates the UT Bot indicator.
	"""
	return go.Slice_float64(handle=_bbta.tav_UTBot(c.handle, atr.handle, rate))
def json_exp(goRun=False):
	"""JsonExp() """
	_bbta.tav_JsonExp(goRun)
def kama_by(data, period, fast, slow):
	"""KAMABy([]float data, int period, int fast, int slow) []float
	
	KAMABy calculates the KAMA with fast and slow periods.
	"""
	return go.Slice_float64(handle=_bbta.tav_KAMABy(data.handle, period, fast, slow))
def cmf(high, low, close, volume, period):
	"""CMF([]float high, []float low, []float close, []float volume, int period) []float
	
	CMF calculates the Chaikin Money Flow.
	"""
	return go.Slice_float64(handle=_bbta.tav_CMF(high.handle, low.handle, close.handle, volume.handle, period))
def lowest_bar(data, period):
	"""LowestBar([]float data, int period) []float
	
	LowestBar finds the offset to the lowest value bar over a specified period.
	"""
	return go.Slice_float64(handle=_bbta.tav_LowestBar(data.handle, period))
def cross(data1, data2):
	"""Cross([]float data1, []float data2) []int
	
	Cross detects crossovers between two data series.
	"""
	return go.Slice_int(handle=_bbta.tav_Cross(data1.handle, data2.handle))
def dv2(h, l, c, period, maLen):
	"""DV2([]float h, []float l, []float c, int period, int maLen) []float
	
	DV2 calculates the DV2 indicator.
	"""
	return go.Slice_float64(handle=_bbta.tav_DV2(h.handle, l.handle, c.handle, period, maLen))
def hma(data, period):
	"""HMA([]float data, int period) []float
	
	HMA calculates the Hull Moving Average.
	"""
	return go.Slice_float64(handle=_bbta.tav_HMA(data.handle, period))
def mfi(high, low, close, volume, period):
	"""MFI([]float high, []float low, []float close, []float volume, int period) []float
	
	MFI calculates the Money Flow Index.
	"""
	return go.Slice_float64(handle=_bbta.tav_MFI(high.handle, low.handle, close.handle, volume.handle, period))
def cmo_by(data, period, maType):
	"""CMOBy([]float data, int period, int maType) []float
	
	CMOBy calculates the CMO with a specified MA type.
	"""
	return go.Slice_float64(handle=_bbta.tav_CMOBy(data.handle, period, maType))
def std_dev_by(data, period, ddof):
	"""StdDevBy([]float data, int period, int ddof) [][]float
	
	StdDevBy calculates the Standard Deviation with a specified delta degrees of freedom (ddof).
	Returns [2][]float64{stddev, mean}.
	"""
	return Array_2_Slice_float64(handle=_bbta.tav_StdDevBy(data.handle, period, ddof))
def chop(high, low, close, period):
	"""CHOP([]float high, []float low, []float close, int period) []float
	
	CHOP calculates the Choppiness Index.
	"""
	return go.Slice_float64(handle=_bbta.tav_CHOP(high.handle, low.handle, close.handle, period))
def crsi_by(data, period, upDn, rocVal, vtype):
	"""CRSIBy([]float data, int period, int upDn, int rocVal, int vtype) []float
	
	CRSIBy calculates the Connors RSI with a specified type.
	"""
	return go.Slice_float64(handle=_bbta.tav_CRSIBy(data.handle, period, upDn, rocVal, vtype))
def kdj_by(high, low, close, period, sm1, sm2, maBy):
	"""KDJBy([]float high, []float low, []float close, int period, int sm1, int sm2, str maBy) [][]float
	
	KDJBy calculates the KDJ indicator with a specified MA type.
	Returns [3][]float64{k, d, rsv}.
	"""
	return Array_3_Slice_float64(handle=_bbta.tav_KDJBy(high.handle, low.handle, close.handle, period, sm1, sm2, maBy))
def sma(data, period):
	"""SMA([]float data, int period) []float
	
	SMA calculates the Simple Moving Average.
	"""
	return go.Slice_float64(handle=_bbta.tav_SMA(data.handle, period))
def stoch(high, low, close, period):
	"""Stoch([]float high, []float low, []float close, int period) []float
	
	Stoch calculates the Stochastic Oscillator.
	"""
	return go.Slice_float64(handle=_bbta.tav_Stoch(high.handle, low.handle, close.handle, period))
def er(data, period):
	"""ER([]float data, int period) []float
	
	ER calculates the Efficiency Ratio (Kaufman).
	"""
	return go.Slice_float64(handle=_bbta.tav_ER(data.handle, period))
def highest_bar(data, period):
	"""HighestBar([]float data, int period) []float
	
	HighestBar finds the offset to the highest value bar over a specified period.
	"""
	return go.Slice_float64(handle=_bbta.tav_HighestBar(data.handle, period))
def kdj(high, low, close, period, sm1, sm2):
	"""KDJ([]float high, []float low, []float close, int period, int sm1, int sm2) [][]float
	
	KDJ calculates the KDJ indicator.
	Returns [3][]float64{k, d, j}.
	"""
	return Array_3_Slice_float64(handle=_bbta.tav_KDJ(high.handle, low.handle, close.handle, period, sm1, sm2))
def rma(data, period):
	"""RMA([]float data, int period) []float
	
	RMA calculates the Wilder's Smoothing Average (Relative Moving Average).
	"""
	return go.Slice_float64(handle=_bbta.tav_RMA(data.handle, period))
def std_dev(data, period):
	"""StdDev([]float data, int period) []float
	
	StdDev calculates the Standard Deviation.
	"""
	return go.Slice_float64(handle=_bbta.tav_StdDev(data.handle, period))
def cci(data, period):
	"""CCI([]float data, int period) []float
	
	CCI calculates the Commodity Channel Index.
	"""
	return go.Slice_float64(handle=_bbta.tav_CCI(data.handle, period))
def ema(data, period):
	"""EMA([]float data, int period) []float
	
	EMA calculates the Exponential Moving Average.
	"""
	return go.Slice_float64(handle=_bbta.tav_EMA(data.handle, period))
def lowest(data, period):
	"""Lowest([]float data, int period) []float
	
	Lowest finds the lowest value over a specified period.
	"""
	return go.Slice_float64(handle=_bbta.tav_Lowest(data.handle, period))
def rma_by(data, period, initType, initVal):
	"""RMABy([]float data, int period, int initType, float initVal) []float
	
	RMABy calculates the Wilder's Smoothing Average with specified initialization.
	"""
	return go.Slice_float64(handle=_bbta.tav_RMABy(data.handle, period, initType, initVal))


