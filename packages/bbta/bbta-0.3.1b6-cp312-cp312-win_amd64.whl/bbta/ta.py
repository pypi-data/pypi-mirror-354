
# python wrapper for package github.com/banbox/banta/python/ta within overall package bbta
# This is what you import to use the package.
# File is generated by gopy. Do not edit.
# gopy build -no-make -output build\lib.win-amd64-cpython-312\bbta -name bbta -vm C:\Users\runneradmin\AppData\Local\Temp\cibw-run-0ep9is9o\cp312-win_amd64\build\venv\Scripts\python.exe github.com/banbox/banta/python/ta github.com/banbox/banta/python/tav

# the following is required to enable dlopen to open the _go.so file
import os,sys,inspect,collections
try:
	import collections.abc as _collections_abc
except ImportError:
	_collections_abc = collections

cwd = os.getcwd()
currentdir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
os.chdir(currentdir)
from . import _bbta
from . import go

os.chdir(cwd)

# to use this code in your end-user python file, import it as follows:
# from bbta import ta
# and then refer to everything using ta. prefix
# packages imported by this package listed below:




# ---- Types ---

# Python type for slice [2]*banta.Series
class Array_2_Ptr_banta_Series(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_bbta.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_bbta.IncRef(self.handle)
	def __del__(self):
		_bbta.DecRef(self.handle)
	def __str__(self):
		s = 'ta.Array_2_Ptr_banta_Series len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'ta.Array_2_Ptr_banta_Series([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _bbta.Array_2_Ptr_banta_Series_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.Ptr_banta_Series(handle=_bbta.Array_2_Ptr_banta_Series_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_bbta.Array_2_Ptr_banta_Series_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.Ptr_banta_Series(handle=_bbta.Array_2_Ptr_banta_Series_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration

# Python type for slice [3]*banta.Series
class Array_3_Ptr_banta_Series(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_bbta.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_bbta.IncRef(self.handle)
	def __del__(self):
		_bbta.DecRef(self.handle)
	def __str__(self):
		s = 'ta.Array_3_Ptr_banta_Series len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'ta.Array_3_Ptr_banta_Series([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _bbta.Array_3_Ptr_banta_Series_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.Ptr_banta_Series(handle=_bbta.Array_3_Ptr_banta_Series_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_bbta.Array_3_Ptr_banta_Series_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.Ptr_banta_Series(handle=_bbta.Array_3_Ptr_banta_Series_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration

# Python type for slice [4]*banta.Series
class Array_4_Ptr_banta_Series(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_bbta.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_bbta.IncRef(self.handle)
	def __del__(self):
		_bbta.DecRef(self.handle)
	def __str__(self):
		s = 'ta.Array_4_Ptr_banta_Series len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'ta.Array_4_Ptr_banta_Series([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _bbta.Array_4_Ptr_banta_Series_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.Ptr_banta_Series(handle=_bbta.Array_4_Ptr_banta_Series_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_bbta.Array_4_Ptr_banta_Series_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.Ptr_banta_Series(handle=_bbta.Array_4_Ptr_banta_Series_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration

# Python type for slice []*banta.Series
class Slice_Ptr_banta_Series(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_bbta.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_bbta.IncRef(self.handle)
		else:
			self.handle = _bbta.Slice_Ptr_banta_Series_CTor()
			_bbta.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_Ptr_banta_Series.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_bbta.DecRef(self.handle)
	def __str__(self):
		s = 'ta.Slice_Ptr_banta_Series len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'ta.Slice_Ptr_banta_Series([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _bbta.Slice_Ptr_banta_Series_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _bbta.Slice_Ptr_banta_Series_len(self.handle)
				return Slice_Ptr_banta_Series(handle=_bbta.Slice_Ptr_banta_Series_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.Ptr_banta_Series(handle=_bbta.Slice_Ptr_banta_Series_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_bbta.Slice_Ptr_banta_Series_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_Ptr_banta_Series.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.Ptr_banta_Series(handle=_bbta.Slice_Ptr_banta_Series_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_bbta.Slice_Ptr_banta_Series_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []*banta.XState
class Slice_Ptr_banta_XState(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_bbta.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_bbta.IncRef(self.handle)
		else:
			self.handle = _bbta.Slice_Ptr_banta_XState_CTor()
			_bbta.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_Ptr_banta_XState.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_bbta.DecRef(self.handle)
	def __str__(self):
		s = 'ta.Slice_Ptr_banta_XState len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'ta.Slice_Ptr_banta_XState([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _bbta.Slice_Ptr_banta_XState_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _bbta.Slice_Ptr_banta_XState_len(self.handle)
				return Slice_Ptr_banta_XState(handle=_bbta.Slice_Ptr_banta_XState_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.Ptr_banta_XState(handle=_bbta.Slice_Ptr_banta_XState_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_bbta.Slice_Ptr_banta_XState_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_Ptr_banta_XState.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.Ptr_banta_XState(handle=_bbta.Slice_Ptr_banta_XState_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_bbta.Slice_Ptr_banta_XState_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for map map[int]*banta.CrossLog
class Map_int_Ptr_banta_CrossLog(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_bbta.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_bbta.IncRef(self.handle)
		else:
			self.handle = _bbta.Map_int_Ptr_banta_CrossLog_CTor()
			_bbta.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_int_Ptr_banta_CrossLog.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_bbta.Map_int_Ptr_banta_CrossLog_set(self.handle, k, v)
	def __del__(self):
		_bbta.DecRef(self.handle)
	def __str__(self):
		s = 'bbta.Map_int_Ptr_banta_CrossLog len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'bbta.Map_int_Ptr_banta_CrossLog({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _bbta.Map_int_Ptr_banta_CrossLog_len(self.handle)
	def __getitem__(self, key):
		return go.Ptr_banta_CrossLog(handle=_bbta.Map_int_Ptr_banta_CrossLog_elem(self.handle, key))
	def __setitem__(self, key, value):
		_bbta.Map_int_Ptr_banta_CrossLog_set(self.handle, key, value.handle)
	def __delitem__(self, key):
		return _bbta.Map_int_Ptr_banta_CrossLog_delete(self.handle, key)
	def keys(self):
		return go.Slice_int(handle=_bbta.Map_int_Ptr_banta_CrossLog_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _bbta.Map_int_Ptr_banta_CrossLog_contains(self.handle, key)

# Python type for map map[int]*banta.Series
class Map_int_Ptr_banta_Series(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_bbta.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_bbta.IncRef(self.handle)
		else:
			self.handle = _bbta.Map_int_Ptr_banta_Series_CTor()
			_bbta.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_int_Ptr_banta_Series.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_bbta.Map_int_Ptr_banta_Series_set(self.handle, k, v)
	def __del__(self):
		_bbta.DecRef(self.handle)
	def __str__(self):
		s = 'bbta.Map_int_Ptr_banta_Series len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'bbta.Map_int_Ptr_banta_Series({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _bbta.Map_int_Ptr_banta_Series_len(self.handle)
	def __getitem__(self, key):
		return go.Ptr_banta_Series(handle=_bbta.Map_int_Ptr_banta_Series_elem(self.handle, key))
	def __setitem__(self, key, value):
		_bbta.Map_int_Ptr_banta_Series_set(self.handle, key, value.handle)
	def __delitem__(self, key):
		return _bbta.Map_int_Ptr_banta_Series_delete(self.handle, key)
	def keys(self):
		return go.Slice_int(handle=_bbta.Map_int_Ptr_banta_Series_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _bbta.Map_int_Ptr_banta_Series_contains(self.handle, key)

# Python type for map map[string]interface{}
class Map_string_interface_(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_bbta.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_bbta.IncRef(self.handle)
		else:
			self.handle = _bbta.Map_string_interface__CTor()
			_bbta.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_string_interface_.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_bbta.Map_string_interface__set(self.handle, k, v)
	def __del__(self):
		_bbta.DecRef(self.handle)
	def __str__(self):
		s = 'bbta.Map_string_interface_ len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'bbta.Map_string_interface_({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _bbta.Map_string_interface__len(self.handle)
	def __getitem__(self, key):
		return _bbta.Map_string_interface__elem(self.handle, key)
	def __setitem__(self, key, value):
		_bbta.Map_string_interface__set(self.handle, key, value)
	def __delitem__(self, key):
		return _bbta.Map_string_interface__delete(self.handle, key)
	def keys(self):
		return go.Slice_string(handle=_bbta.Map_string_interface__keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _bbta.Map_string_interface__contains(self.handle, key)

# Python type for map map[string]map[int]*banta.Series
class Map_string_Map_int_Ptr_banta_Series(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_bbta.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_bbta.IncRef(self.handle)
		else:
			self.handle = _bbta.Map_string_Map_int_Ptr_banta_Series_CTor()
			_bbta.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_string_Map_int_Ptr_banta_Series.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_bbta.Map_string_Map_int_Ptr_banta_Series_set(self.handle, k, v)
	def __del__(self):
		_bbta.DecRef(self.handle)
	def __str__(self):
		s = 'bbta.Map_string_Map_int_Ptr_banta_Series len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'bbta.Map_string_Map_int_Ptr_banta_Series({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _bbta.Map_string_Map_int_Ptr_banta_Series_len(self.handle)
	def __getitem__(self, key):
		return Map_int_Ptr_banta_Series(handle=_bbta.Map_string_Map_int_Ptr_banta_Series_elem(self.handle, key))
	def __setitem__(self, key, value):
		_bbta.Map_string_Map_int_Ptr_banta_Series_set(self.handle, key, value.handle)
	def __delitem__(self, key):
		return _bbta.Map_string_Map_int_Ptr_banta_Series_delete(self.handle, key)
	def keys(self):
		return go.Slice_string(handle=_bbta.Map_string_Map_int_Ptr_banta_Series_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _bbta.Map_string_Map_int_Ptr_banta_Series_contains(self.handle, key)


#---- Enums from Go (collections of consts with same type) ---


#---- Constants from Go: Python can only ask that you please don't change these! ---


# ---- Global Variables: can only use functions to access ---


# ---- Interfaces ---


# ---- Structs ---

# Python type for struct banta.BarEnv
class BarEnv(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_bbta.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_bbta.IncRef(self.handle)
		else:
			self.handle = _bbta.banta_BarEnv_CTor()
			_bbta.IncRef(self.handle)
			if  0 < len(args):
				self.TimeStart = args[0]
			if "TimeStart" in kwargs:
				self.TimeStart = kwargs["TimeStart"]
			if  1 < len(args):
				self.TimeStop = args[1]
			if "TimeStop" in kwargs:
				self.TimeStop = kwargs["TimeStop"]
			if  2 < len(args):
				self.Exchange = args[2]
			if "Exchange" in kwargs:
				self.Exchange = kwargs["Exchange"]
			if  3 < len(args):
				self.MarketType = args[3]
			if "MarketType" in kwargs:
				self.MarketType = kwargs["MarketType"]
			if  4 < len(args):
				self.Symbol = args[4]
			if "Symbol" in kwargs:
				self.Symbol = kwargs["Symbol"]
			if  5 < len(args):
				self.TimeFrame = args[5]
			if "TimeFrame" in kwargs:
				self.TimeFrame = kwargs["TimeFrame"]
			if  6 < len(args):
				self.TFMSecs = args[6]
			if "TFMSecs" in kwargs:
				self.TFMSecs = kwargs["TFMSecs"]
			if  7 < len(args):
				self.BarNum = args[7]
			if "BarNum" in kwargs:
				self.BarNum = kwargs["BarNum"]
			if  8 < len(args):
				self.MaxCache = args[8]
			if "MaxCache" in kwargs:
				self.MaxCache = kwargs["MaxCache"]
			if  9 < len(args):
				self.VNum = args[9]
			if "VNum" in kwargs:
				self.VNum = kwargs["VNum"]
			if  10 < len(args):
				self.Open = args[10]
			if "Open" in kwargs:
				self.Open = kwargs["Open"]
			if  11 < len(args):
				self.High = args[11]
			if "High" in kwargs:
				self.High = kwargs["High"]
			if  12 < len(args):
				self.Low = args[12]
			if "Low" in kwargs:
				self.Low = kwargs["Low"]
			if  13 < len(args):
				self.Close = args[13]
			if "Close" in kwargs:
				self.Close = kwargs["Close"]
			if  14 < len(args):
				self.Volume = args[14]
			if "Volume" in kwargs:
				self.Volume = kwargs["Volume"]
			if  15 < len(args):
				self.Info = args[15]
			if "Info" in kwargs:
				self.Info = kwargs["Info"]
			if  16 < len(args):
				self.Data = args[16]
			if "Data" in kwargs:
				self.Data = kwargs["Data"]
	def __del__(self):
		_bbta.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'banta.BarEnv{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'banta.BarEnv ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def TimeStart(self):
		return _bbta.banta_BarEnv_TimeStart_Get(self.handle)
	@TimeStart.setter
	def TimeStart(self, value):
		if isinstance(value, go.GoClass):
			_bbta.banta_BarEnv_TimeStart_Set(self.handle, value.handle)
		else:
			_bbta.banta_BarEnv_TimeStart_Set(self.handle, value)
	@property
	def TimeStop(self):
		return _bbta.banta_BarEnv_TimeStop_Get(self.handle)
	@TimeStop.setter
	def TimeStop(self, value):
		if isinstance(value, go.GoClass):
			_bbta.banta_BarEnv_TimeStop_Set(self.handle, value.handle)
		else:
			_bbta.banta_BarEnv_TimeStop_Set(self.handle, value)
	@property
	def Exchange(self):
		return _bbta.banta_BarEnv_Exchange_Get(self.handle)
	@Exchange.setter
	def Exchange(self, value):
		if isinstance(value, go.GoClass):
			_bbta.banta_BarEnv_Exchange_Set(self.handle, value.handle)
		else:
			_bbta.banta_BarEnv_Exchange_Set(self.handle, value)
	@property
	def MarketType(self):
		return _bbta.banta_BarEnv_MarketType_Get(self.handle)
	@MarketType.setter
	def MarketType(self, value):
		if isinstance(value, go.GoClass):
			_bbta.banta_BarEnv_MarketType_Set(self.handle, value.handle)
		else:
			_bbta.banta_BarEnv_MarketType_Set(self.handle, value)
	@property
	def Symbol(self):
		return _bbta.banta_BarEnv_Symbol_Get(self.handle)
	@Symbol.setter
	def Symbol(self, value):
		if isinstance(value, go.GoClass):
			_bbta.banta_BarEnv_Symbol_Set(self.handle, value.handle)
		else:
			_bbta.banta_BarEnv_Symbol_Set(self.handle, value)
	@property
	def TimeFrame(self):
		return _bbta.banta_BarEnv_TimeFrame_Get(self.handle)
	@TimeFrame.setter
	def TimeFrame(self, value):
		if isinstance(value, go.GoClass):
			_bbta.banta_BarEnv_TimeFrame_Set(self.handle, value.handle)
		else:
			_bbta.banta_BarEnv_TimeFrame_Set(self.handle, value)
	@property
	def TFMSecs(self):
		return _bbta.banta_BarEnv_TFMSecs_Get(self.handle)
	@TFMSecs.setter
	def TFMSecs(self, value):
		if isinstance(value, go.GoClass):
			_bbta.banta_BarEnv_TFMSecs_Set(self.handle, value.handle)
		else:
			_bbta.banta_BarEnv_TFMSecs_Set(self.handle, value)
	@property
	def BarNum(self):
		return _bbta.banta_BarEnv_BarNum_Get(self.handle)
	@BarNum.setter
	def BarNum(self, value):
		if isinstance(value, go.GoClass):
			_bbta.banta_BarEnv_BarNum_Set(self.handle, value.handle)
		else:
			_bbta.banta_BarEnv_BarNum_Set(self.handle, value)
	@property
	def MaxCache(self):
		return _bbta.banta_BarEnv_MaxCache_Get(self.handle)
	@MaxCache.setter
	def MaxCache(self, value):
		if isinstance(value, go.GoClass):
			_bbta.banta_BarEnv_MaxCache_Set(self.handle, value.handle)
		else:
			_bbta.banta_BarEnv_MaxCache_Set(self.handle, value)
	@property
	def VNum(self):
		return _bbta.banta_BarEnv_VNum_Get(self.handle)
	@VNum.setter
	def VNum(self, value):
		if isinstance(value, go.GoClass):
			_bbta.banta_BarEnv_VNum_Set(self.handle, value.handle)
		else:
			_bbta.banta_BarEnv_VNum_Set(self.handle, value)
	@property
	def Open(self):
		return go.Ptr_banta_Series(handle=_bbta.banta_BarEnv_Open_Get(self.handle))
	@Open.setter
	def Open(self, value):
		if isinstance(value, go.GoClass):
			_bbta.banta_BarEnv_Open_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def High(self):
		return go.Ptr_banta_Series(handle=_bbta.banta_BarEnv_High_Get(self.handle))
	@High.setter
	def High(self, value):
		if isinstance(value, go.GoClass):
			_bbta.banta_BarEnv_High_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Low(self):
		return go.Ptr_banta_Series(handle=_bbta.banta_BarEnv_Low_Get(self.handle))
	@Low.setter
	def Low(self, value):
		if isinstance(value, go.GoClass):
			_bbta.banta_BarEnv_Low_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Close(self):
		return go.Ptr_banta_Series(handle=_bbta.banta_BarEnv_Close_Get(self.handle))
	@Close.setter
	def Close(self, value):
		if isinstance(value, go.GoClass):
			_bbta.banta_BarEnv_Close_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Volume(self):
		return go.Ptr_banta_Series(handle=_bbta.banta_BarEnv_Volume_Get(self.handle))
	@Volume.setter
	def Volume(self, value):
		if isinstance(value, go.GoClass):
			_bbta.banta_BarEnv_Volume_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Info(self):
		return go.Ptr_banta_Series(handle=_bbta.banta_BarEnv_Info_Get(self.handle))
	@Info.setter
	def Info(self, value):
		if isinstance(value, go.GoClass):
			_bbta.banta_BarEnv_Info_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Data(self):
		return Map_string_interface_(handle=_bbta.banta_BarEnv_Data_Get(self.handle))
	@Data.setter
	def Data(self, value):
		if isinstance(value, go.GoClass):
			_bbta.banta_BarEnv_Data_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def OnBar(self, barMs, open, high, low, close, volume, info):
		"""OnBar(long barMs, float open, float high, float low, float close, float volume, float info) str"""
		return _bbta.banta_BarEnv_OnBar(self.handle, barMs, open, high, low, close, volume, info)
	def Reset(self, goRun=False):
		"""Reset() """
		_bbta.banta_BarEnv_Reset(self.handle, goRun)
	def TrimOverflow(self, goRun=False):
		"""TrimOverflow() """
		_bbta.banta_BarEnv_TrimOverflow(self.handle, goRun)
	def NewSeries(self, data):
		"""NewSeries([]float data) object"""
		return go.Ptr_banta_Series(handle=_bbta.banta_BarEnv_NewSeries(self.handle, data.handle))
	def BarCount(self, start):
		"""BarCount(long start) float"""
		return _bbta.banta_BarEnv_BarCount(self.handle, start)

# Python type for struct banta.Series
class Series(go.GoClass):
	"""为方便起见，定义类型别名，以便我们可以使用与原始包中相同的类型名称。\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_bbta.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_bbta.IncRef(self.handle)
		else:
			self.handle = _bbta.banta_Series_CTor()
			_bbta.IncRef(self.handle)
			if  0 < len(args):
				self.ID = args[0]
			if "ID" in kwargs:
				self.ID = kwargs["ID"]
			if  1 < len(args):
				self.Env = args[1]
			if "Env" in kwargs:
				self.Env = kwargs["Env"]
			if  2 < len(args):
				self.Data = args[2]
			if "Data" in kwargs:
				self.Data = kwargs["Data"]
			if  3 < len(args):
				self.Cols = args[3]
			if "Cols" in kwargs:
				self.Cols = kwargs["Cols"]
			if  4 < len(args):
				self.Time = args[4]
			if "Time" in kwargs:
				self.Time = kwargs["Time"]
			if  6 < len(args):
				self.Subs = args[6]
			if "Subs" in kwargs:
				self.Subs = kwargs["Subs"]
			if  7 < len(args):
				self.XLogs = args[7]
			if "XLogs" in kwargs:
				self.XLogs = kwargs["XLogs"]
	def __del__(self):
		_bbta.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'banta.Series{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'banta.Series ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def ID(self):
		return _bbta.banta_Series_ID_Get(self.handle)
	@ID.setter
	def ID(self, value):
		if isinstance(value, go.GoClass):
			_bbta.banta_Series_ID_Set(self.handle, value.handle)
		else:
			_bbta.banta_Series_ID_Set(self.handle, value)
	@property
	def Env(self):
		return go.Ptr_banta_BarEnv(handle=_bbta.banta_Series_Env_Get(self.handle))
	@Env.setter
	def Env(self, value):
		if isinstance(value, go.GoClass):
			_bbta.banta_Series_Env_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Data(self):
		return go.Slice_float64(handle=_bbta.banta_Series_Data_Get(self.handle))
	@Data.setter
	def Data(self, value):
		if isinstance(value, go.GoClass):
			_bbta.banta_Series_Data_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Cols(self):
		return Slice_Ptr_banta_Series(handle=_bbta.banta_Series_Cols_Get(self.handle))
	@Cols.setter
	def Cols(self, value):
		if isinstance(value, go.GoClass):
			_bbta.banta_Series_Cols_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Time(self):
		return _bbta.banta_Series_Time_Get(self.handle)
	@Time.setter
	def Time(self, value):
		if isinstance(value, go.GoClass):
			_bbta.banta_Series_Time_Set(self.handle, value.handle)
		else:
			_bbta.banta_Series_Time_Set(self.handle, value)
	@property
	def Subs(self):
		return Map_string_Map_int_Ptr_banta_Series(handle=_bbta.banta_Series_Subs_Get(self.handle))
	@Subs.setter
	def Subs(self, value):
		if isinstance(value, go.GoClass):
			_bbta.banta_Series_Subs_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def XLogs(self):
		return Map_int_Ptr_banta_CrossLog(handle=_bbta.banta_Series_XLogs_Get(self.handle))
	@XLogs.setter
	def XLogs(self, value):
		if isinstance(value, go.GoClass):
			_bbta.banta_Series_XLogs_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def Set(self, obj):
		"""Set(str obj) object"""
		return go.Ptr_banta_Series(handle=_bbta.banta_Series_Set(self.handle, obj))
	def Append(self, obj):
		"""Append(str obj) object"""
		return go.Ptr_banta_Series(handle=_bbta.banta_Series_Append(self.handle, obj))
	def Cached(self):
		"""Cached() bool"""
		return _bbta.banta_Series_Cached(self.handle)
	def Get(self, i):
		"""Get(int i) float"""
		return _bbta.banta_Series_Get(self.handle, i)
	def Range(self, start, stop):
		"""Range(int start, int stop) []float"""
		return go.Slice_float64(handle=_bbta.banta_Series_Range(self.handle, start, stop))
	def Add(self, obj):
		"""Add(str obj) object"""
		return go.Ptr_banta_Series(handle=_bbta.banta_Series_Add(self.handle, obj))
	def Sub(self, obj):
		"""Sub(str obj) object"""
		return go.Ptr_banta_Series(handle=_bbta.banta_Series_Sub(self.handle, obj))
	def Mul(self, obj):
		"""Mul(str obj) object"""
		return go.Ptr_banta_Series(handle=_bbta.banta_Series_Mul(self.handle, obj))
	def Div(self, obj):
		"""Div(str obj) object"""
		return go.Ptr_banta_Series(handle=_bbta.banta_Series_Div(self.handle, obj))
	def Min(self, obj):
		"""Min(str obj) object"""
		return go.Ptr_banta_Series(handle=_bbta.banta_Series_Min(self.handle, obj))
	def Max(self, obj):
		"""Max(str obj) object"""
		return go.Ptr_banta_Series(handle=_bbta.banta_Series_Max(self.handle, obj))
	def Abs(self):
		"""Abs() object"""
		return go.Ptr_banta_Series(handle=_bbta.banta_Series_Abs(self.handle))
	def Len(self):
		"""Len() int"""
		return _bbta.banta_Series_Len(self.handle)
	def Cut(self, keepNum, goRun=False):
		"""Cut(int keepNum) """
		_bbta.banta_Series_Cut(self.handle, keepNum, goRun)
	def Back(self, num):
		"""Back(int num) object"""
		return go.Ptr_banta_Series(handle=_bbta.banta_Series_Back(self.handle, num))
	def To(self, k, v):
		"""To(str k, int v) object"""
		return go.Ptr_banta_Series(handle=_bbta.banta_Series_To(self.handle, k, v))


# ---- Slices ---


# ---- Maps ---


# ---- Constructors ---
def RSI(obj, period):
	"""RSI(object obj, int period) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_RSI(obj.handle, period))
def CHOP(e, period):
	"""CHOP(object e, int period) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_CHOP(e.handle, period))
def KAMABy(obj, period, fast, slow):
	"""KAMABy(object obj, int period, int fast, int slow) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_KAMABy(obj.handle, period, fast, slow))
def Highest(obj, period):
	"""Highest(object obj, int period) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_Highest(obj.handle, period))
def Sum(obj, period):
	"""Sum(object obj, int period) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_Sum(obj.handle, period))
def EMA(obj, period):
	"""EMA(object obj, int period) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_EMA(obj.handle, period))
def HLC3(h, l, c):
	"""HLC3(object h, object l, object c) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_HLC3(h.handle, l.handle, c.handle))
def CMOBy(obj, period, maType):
	"""CMOBy(object obj, int period, int maType) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_CMOBy(obj.handle, period, maType))
def LinRegAdv(obj, period, angle, intercept, degrees, r, slope, tsf):
	"""LinRegAdv(object obj, int period, bool angle, bool intercept, bool degrees, bool r, bool slope, bool tsf) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_LinRegAdv(obj.handle, period, angle, intercept, degrees, r, slope, tsf))
def HL2(h, l):
	"""HL2(object h, object l) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_HL2(h.handle, l.handle))
def KAMA(obj, period):
	"""KAMA(object obj, int period) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_KAMA(obj.handle, period))
def LinReg(obj, period):
	"""LinReg(object obj, int period) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_LinReg(obj.handle, period))
def CMF(env, period):
	"""CMF(object env, int period) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_CMF(env.handle, period))
def VWMA(price, vol, period):
	"""VWMA(object price, object vol, int period) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_VWMA(price.handle, vol.handle, period))
def MFI(e, period):
	"""MFI(object e, int period) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_MFI(e.handle, period))
def RMA(obj, period):
	"""RMA(object obj, int period) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_RMA(obj.handle, period))
def ChaikinOsc(env, sml, big):
	"""ChaikinOsc(object env, int sml, int big) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_ChaikinOsc(env.handle, sml, big))
def HighestBar(obj, period):
	"""HighestBar(object obj, int period) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_HighestBar(obj.handle, period))
def CTI(obj, period):
	"""CTI(object obj, int period) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_CTI(obj.handle, period))
def LowestBar(obj, period):
	"""LowestBar(object obj, int period) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_LowestBar(obj.handle, period))
def RMABy(obj, period, initType, initVal):
	"""RMABy(object obj, int period, int initType, float initVal) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_RMABy(obj.handle, period, initType, initVal))
def ROC(obj, period):
	"""ROC(object obj, int period) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_ROC(obj.handle, period))
def RSI50(obj, period):
	"""RSI50(object obj, int period) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_RSI50(obj.handle, period))
def AvgDev(obj, period):
	"""AvgDev(object obj, int period) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_AvgDev(obj.handle, period))
def AvgPrice(e):
	"""AvgPrice(object e) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_AvgPrice(e.handle))
def Stiffness(obj, maLen, stiffLen, stiffMa):
	"""Stiffness(object obj, int maLen, int stiffLen, int stiffMa) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_Stiffness(obj.handle, maLen, stiffLen, stiffMa))
def Stoch(high, low, close, period):
	"""Stoch(object high, object low, object close, int period) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_Stoch(high.handle, low.handle, close.handle, period))
def PercentRank(obj, period):
	"""PercentRank(object obj, int period) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_PercentRank(obj.handle, period))
def SMA(obj, period):
	"""SMA(object obj, int period) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_SMA(obj.handle, period))
def TR(high, low, close):
	"""TR(object high, object low, object close) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_TR(high.handle, low.handle, close.handle))
def UTBot(c, atr, rate):
	"""UTBot(object c, object atr, float rate) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_UTBot(c.handle, atr.handle, rate))
def ER(obj, period):
	"""ER(object obj, int period) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_ER(obj.handle, period))
def CMO(obj, period):
	"""CMO(object obj, int period) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_CMO(obj.handle, period))
def DV2(h, l, c, period, maLen):
	"""DV2(object h, object l, object c, int period, int maLen) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_DV2(h.handle, l.handle, c.handle, period, maLen))
def Lowest(obj, period):
	"""Lowest(object obj, int period) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_Lowest(obj.handle, period))
def RMI(obj, period, montLen):
	"""RMI(object obj, int period, int montLen) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_RMI(obj.handle, period, montLen))
def STC(obj, period, fast, slow, alpha):
	"""STC(object obj, int period, int fast, int slow, float alpha) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_STC(obj.handle, period, fast, slow, alpha))
def CRSI(obj, period, upDn, roc):
	"""CRSI(object obj, int period, int upDn, int roc) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_CRSI(obj.handle, period, upDn, roc))
def HMA(obj, period):
	"""HMA(object obj, int period) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_HMA(obj.handle, period))
def WMA(obj, period):
	"""WMA(object obj, int period) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_WMA(obj.handle, period))
def ADL(env):
	"""ADL(object env) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_ADL(env.handle))
def CCI(obj, period):
	"""CCI(object obj, int period) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_CCI(obj.handle, period))
def ATR(high, low, close, period):
	"""ATR(object high, object low, object close, int period) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_ATR(high.handle, low.handle, close.handle, period))
def CRSIBy(obj, period, upDn, roc, vtype):
	"""CRSIBy(object obj, int period, int upDn, int roc, int vtype) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_CRSIBy(obj.handle, period, upDn, roc, vtype))
def StdDev(obj, period):
	"""StdDev(object obj, int period) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_StdDev(obj.handle, period))
def TD(obj):
	"""TD(object obj) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_TD(obj.handle))
def WillR(e, period):
	"""WillR(object e, int period) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_WillR(e.handle, period))
def ADX(high, low, close, period):
	"""ADX(object high, object low, object close, int period) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_ADX(high.handle, low.handle, close.handle, period))
def ALMA(obj, period, sigma, distOff):
	"""ALMA(object obj, int period, float sigma, float distOff) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_ALMA(obj.handle, period, sigma, distOff))
def UpDown(obj, vtype):
	"""UpDown(object obj, int vtype) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_UpDown(obj.handle, vtype))
def ADXBy(high, low, close, period, smoothing, method):
	"""ADXBy(object high, object low, object close, int period, int smoothing, int method) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_ADXBy(high.handle, low.handle, close.handle, period, smoothing, method))
def EMABy(obj, period, initType):
	"""EMABy(object obj, int period, int initType) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_EMABy(obj.handle, period, initType))


# ---- Functions ---
def PluMinDI(high, low, close, period):
	"""PluMinDI(object high, object low, object close, int period) []object"""
	return Array_2_Ptr_banta_Series(handle=_bbta.ta_PluMinDI(high.handle, low.handle, close.handle, period))
def KDJBy(high, low, close, period, sm1, sm2, maBy):
	"""KDJBy(object high, object low, object close, int period, int sm1, int sm2, str maBy) []object"""
	return Array_3_Ptr_banta_Series(handle=_bbta.ta_KDJBy(high.handle, low.handle, close.handle, period, sm1, sm2, maBy))
def KDJ(high, low, close, period, sm1, sm2):
	"""KDJ(object high, object low, object close, int period, int sm1, int sm2) []object"""
	return Array_3_Ptr_banta_Series(handle=_bbta.ta_KDJ(high.handle, low.handle, close.handle, period, sm1, sm2))
def WrapFloatArr(res, period, inVal):
	"""WrapFloatArr(object res, int period, float inVal) []float"""
	return go.Slice_float64(handle=_bbta.ta_WrapFloatArr(res.handle, period, inVal))
def MACD(obj, fast, slow, smooth):
	"""MACD(object obj, int fast, int slow, int smooth) []object"""
	return Array_2_Ptr_banta_Series(handle=_bbta.ta_MACD(obj.handle, fast, slow, smooth))
def StochRSI(obj, rsiLen, stochLen, maK, maD):
	"""StochRSI(object obj, int rsiLen, int stochLen, int maK, int maD) []object"""
	return Array_2_Ptr_banta_Series(handle=_bbta.ta_StochRSI(obj.handle, rsiLen, stochLen, maK, maD))
def Aroon(high, low, period):
	"""Aroon(object high, object low, int period) []object"""
	return Array_3_Ptr_banta_Series(handle=_bbta.ta_Aroon(high.handle, low.handle, period))
def MACDBy(obj, fast, slow, smooth, initType):
	"""MACDBy(object obj, int fast, int slow, int smooth, int initType) []object"""
	return Array_2_Ptr_banta_Series(handle=_bbta.ta_MACDBy(obj.handle, fast, slow, smooth, initType))
def StdDevBy(obj, period, ddof):
	"""StdDevBy(object obj, int period, int ddof) []object"""
	return Array_2_Ptr_banta_Series(handle=_bbta.ta_StdDevBy(obj.handle, period, ddof))
def PluMinDM(high, low, close, period):
	"""PluMinDM(object high, object low, object close, int period) []object"""
	return Array_2_Ptr_banta_Series(handle=_bbta.ta_PluMinDM(high.handle, low.handle, close.handle, period))
def HeikinAshi(e):
	"""HeikinAshi(object e) []object"""
	return Array_4_Ptr_banta_Series(handle=_bbta.ta_HeikinAshi(e.handle))
def BBANDS(obj, period, stdUp, stdDn):
	"""BBANDS(object obj, int period, float stdUp, float stdDn) []object"""
	return Array_3_Ptr_banta_Series(handle=_bbta.ta_BBANDS(obj.handle, period, stdUp, stdDn))


