/*
cgo stubs for package bbta.
File is generated by gopy. Do not edit.
gopy build -no-make -dynamic-link=True -output build/lib.linux-x86_64-cpython-313 -name bbta -vm /opt/python/cp313-cp313/bin/python -rename=true github.com/banbox/banta/python/ta github.com/banbox/banta/python/tav
*/

package main

/*

#cgo CFLAGS: "-I/opt/python/cp313-cp313/include/python3.13" -Wno-error -Wno-implicit-function-declaration -Wno-int-conversion
#cgo LDFLAGS: -shared

// #define Py_LIMITED_API // need full API for PyRun*
#include <Python.h>
typedef uint8_t bool;
// static inline is trick for avoiding need for extra .c file
// the following are used for build value -- switch on reflect.Kind
// or the types equivalent
static inline PyObject* gopy_build_bool(uint8_t val) {
	return Py_BuildValue("b", val);
}
static inline PyObject* gopy_build_int64(int64_t val) {
	return Py_BuildValue("k", val);
}
static inline PyObject* gopy_build_uint64(uint64_t val) {
	return Py_BuildValue("K", val);
}
static inline PyObject* gopy_build_float64(double val) {
	return Py_BuildValue("d", val);
}
static inline PyObject* gopy_build_string(const char* val) {
	return Py_BuildValue("s", val);
}
static inline void gopy_decref(PyObject* obj) { // macro
	Py_XDECREF(obj);
}
static inline void gopy_incref(PyObject* obj) { // macro
	Py_XINCREF(obj);
}
static inline int gopy_method_check(PyObject* obj) { // macro
	return PyMethod_Check(obj);
}
static inline void gopy_err_handle() {
	if(PyErr_Occurred() != NULL) {
		PyErr_Print();
	}
}

*/
import "C"
import (
	"errors"
	"fmt"
	"reflect"
	"unsafe"

	"github.com/go-python/gopy/gopyh" // handler

	"github.com/banbox/banta"
	"github.com/banbox/banta/python/ta"
	"github.com/banbox/banta/python/tav"
)

// main doesn't do anything in lib / pkg mode, but is essential for exe mode
func main() {

}

// initialization functions -- can be called from python after library is loaded
// GoPyInitRunFile runs a separate python file -- call in GoPyInit if it
// steals the main thread e.g., for GUI event loop, as in GoGi startup.

//export GoPyInit
func GoPyInit() {

}

// type for the handle -- int64 for speed (can switch to string)
type GoHandle int64
type CGoHandle C.longlong

// DecRef decrements the reference count for the specified handle
// and deletes it it goes to zero.
//
//export DecRef
func DecRef(handle CGoHandle) {
	gopyh.DecRef(gopyh.CGoHandle(handle))
}

// IncRef increments the reference count for the specified handle.
//
//export IncRef
func IncRef(handle CGoHandle) {
	gopyh.IncRef(gopyh.CGoHandle(handle))
}

// NumHandles returns the number of handles currently in use.
//
//export NumHandles
func NumHandles() int {
	return gopyh.NumHandles()
}

// boolGoToPy converts a Go bool to python-compatible C.char
func boolGoToPy(b bool) C.char {
	if b {
		return 1
	}
	return 0
}

// boolPyToGo converts a python-compatible C.Char to Go bool
func boolPyToGo(b C.char) bool {
	if b != 0 {
		return true
	}
	return false
}

func complex64GoToPy(c complex64) *C.PyObject {
	return C.PyComplex_FromDoubles(C.double(real(c)), C.double(imag(c)))
}

func complex64PyToGo(o *C.PyObject) complex64 {
	v := C.PyComplex_AsCComplex(o)
	return complex(float32(v.real), float32(v.imag))
}

func complex128GoToPy(c complex128) *C.PyObject {
	return C.PyComplex_FromDoubles(C.double(real(c)), C.double(imag(c)))
}

func complex128PyToGo(o *C.PyObject) complex128 {
	v := C.PyComplex_AsCComplex(o)
	return complex(float64(v.real), float64(v.imag))
}

// errorGoToPy converts a Go error to python-compatible C.CString
func errorGoToPy(e error) *C.char {
	if e != nil {
		return C.CString(e.Error())
	}
	return C.CString("")
}

// --- generated code for package: bbta below: ---

// ---- External Types Outside of Targeted Packages ---

// Converters for pointer handles for type: *banta.BarEnv
func ptrFromHandle_Ptr_banta_BarEnv(h CGoHandle) *banta.BarEnv {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*banta.BarEnv")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(banta.BarEnv{})).(*banta.BarEnv)
}
func handleFromPtr_Ptr_banta_BarEnv(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*banta.BarEnv", p))
}

// Converters for pointer handles for type: *banta.CrossLog
func ptrFromHandle_Ptr_banta_CrossLog(h CGoHandle) *banta.CrossLog {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*banta.CrossLog")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(banta.CrossLog{})).(*banta.CrossLog)
}
func handleFromPtr_Ptr_banta_CrossLog(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*banta.CrossLog", p))
}

// Converters for pointer handles for type: *banta.Series
func ptrFromHandle_Ptr_banta_Series(h CGoHandle) *banta.Series {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*banta.Series")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(banta.Series{})).(*banta.Series)
}
func handleFromPtr_Ptr_banta_Series(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*banta.Series", p))
}

// Converters for pointer handles for type: *banta.XState
func ptrFromHandle_Ptr_banta_XState(h CGoHandle) *banta.XState {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*banta.XState")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(banta.XState{})).(*banta.XState)
}
func handleFromPtr_Ptr_banta_XState(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*banta.XState", p))
}

// Converters for non-pointer handles for type: banta.BarEnv
func ptrFromHandle_banta_BarEnv(h CGoHandle) *banta.BarEnv {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "banta.BarEnv")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(banta.BarEnv{})).(*banta.BarEnv)
}
func handleFromPtr_banta_BarEnv(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("banta.BarEnv", p))
}

// Converters for non-pointer handles for type: banta.CrossLog
func ptrFromHandle_banta_CrossLog(h CGoHandle) *banta.CrossLog {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "banta.CrossLog")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(banta.CrossLog{})).(*banta.CrossLog)
}
func handleFromPtr_banta_CrossLog(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("banta.CrossLog", p))
}

// Converters for non-pointer handles for type: banta.Series
func ptrFromHandle_banta_Series(h CGoHandle) *banta.Series {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "banta.Series")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(banta.Series{})).(*banta.Series)
}
func handleFromPtr_banta_Series(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("banta.Series", p))
}

// Converters for non-pointer handles for type: banta.XState
func ptrFromHandle_banta_XState(h CGoHandle) *banta.XState {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "banta.XState")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(banta.XState{})).(*banta.XState)
}
func handleFromPtr_banta_XState(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("banta.XState", p))
}

// ---- Package: go ---

// ---- Types ---

// Converters for implicit pointer handles for type: []bool
func ptrFromHandle_Slice_bool(h CGoHandle) *[]bool {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]bool")
	if p == nil {
		return nil
	}
	return p.(*[]bool)
}
func deptrFromHandle_Slice_bool(h CGoHandle) []bool {
	p := ptrFromHandle_Slice_bool(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_bool(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]bool", p))
}

// --- wrapping slice: []bool ---
//
//export Slice_bool_CTor
func Slice_bool_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_bool(&[]bool{}))
}

//export Slice_bool_len
func Slice_bool_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_bool(handle))
}

//export Slice_bool_elem
func Slice_bool_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_Slice_bool(handle)
	return boolGoToPy(s[_idx])
}

//export Slice_bool_subslice
func Slice_bool_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_bool(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_bool(&ss))
}

//export Slice_bool_set
func Slice_bool_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_Slice_bool(handle)
	s[_idx] = boolPyToGo(_vl)
}

//export Slice_bool_append
func Slice_bool_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_Slice_bool(handle)
	*s = append(*s, boolPyToGo(_vl))
}

// Converters for implicit pointer handles for type: []byte
func ptrFromHandle_Slice_byte(h CGoHandle) *[]byte {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]byte")
	if p == nil {
		return nil
	}
	return p.(*[]byte)
}
func deptrFromHandle_Slice_byte(h CGoHandle) []byte {
	p := ptrFromHandle_Slice_byte(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_byte(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]byte", p))
}

// --- wrapping slice: []byte ---
//
//export Slice_byte_CTor
func Slice_byte_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_byte(&[]byte{}))
}

//export Slice_byte_len
func Slice_byte_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_byte(handle))
}

//export Slice_byte_elem
func Slice_byte_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_Slice_byte(handle)
	return C.char(s[_idx])
}

//export Slice_byte_subslice
func Slice_byte_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_byte(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_byte(&ss))
}

//export Slice_byte_set
func Slice_byte_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_Slice_byte(handle)
	s[_idx] = byte(_vl)
}

//export Slice_byte_append
func Slice_byte_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_Slice_byte(handle)
	*s = append(*s, byte(_vl))
}

//export Slice_byte_from_bytes
func Slice_byte_from_bytes(o *C.PyObject) CGoHandle {
	size := C.PyBytes_Size(o)
	ptr := unsafe.Pointer(C.PyBytes_AsString(o))
	data := make([]byte, size)
	tmp := unsafe.Slice((*byte)(ptr), size)
	copy(data, tmp)
	return handleFromPtr_Slice_byte(&data)
}

//export Slice_byte_to_bytes
func Slice_byte_to_bytes(handle CGoHandle) *C.PyObject {
	s := deptrFromHandle_Slice_byte(handle)
	ptr := unsafe.Pointer(&s[0])
	size := len(s)
	return C.PyBytes_FromStringAndSize((*C.char)(ptr), C.long(size))
}

// Converters for implicit pointer handles for type: []error
func ptrFromHandle_Slice_error(h CGoHandle) *[]error {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]error")
	if p == nil {
		return nil
	}
	return p.(*[]error)
}
func deptrFromHandle_Slice_error(h CGoHandle) []error {
	p := ptrFromHandle_Slice_error(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_error(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]error", p))
}

// --- wrapping slice: []error ---
//
//export Slice_error_CTor
func Slice_error_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_error(&[]error{}))
}

//export Slice_error_len
func Slice_error_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_error(handle))
}

//export Slice_error_elem
func Slice_error_elem(handle CGoHandle, _idx int) *C.char {
	s := deptrFromHandle_Slice_error(handle)
	return errorGoToPy(s[_idx])
}

//export Slice_error_subslice
func Slice_error_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_error(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_error(&ss))
}

//export Slice_error_set
func Slice_error_set(handle CGoHandle, _idx int, _vl *C.char) {
	s := deptrFromHandle_Slice_error(handle)
	s[_idx] = errors.New(C.GoString(_vl))
}

//export Slice_error_append
func Slice_error_append(handle CGoHandle, _vl *C.char) {
	s := ptrFromHandle_Slice_error(handle)
	*s = append(*s, errors.New(C.GoString(_vl)))
}

// Converters for implicit pointer handles for type: []float32
func ptrFromHandle_Slice_float32(h CGoHandle) *[]float32 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]float32")
	if p == nil {
		return nil
	}
	return p.(*[]float32)
}
func deptrFromHandle_Slice_float32(h CGoHandle) []float32 {
	p := ptrFromHandle_Slice_float32(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_float32(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]float32", p))
}

// --- wrapping slice: []float32 ---
//
//export Slice_float32_CTor
func Slice_float32_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_float32(&[]float32{}))
}

//export Slice_float32_len
func Slice_float32_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_float32(handle))
}

//export Slice_float32_elem
func Slice_float32_elem(handle CGoHandle, _idx int) C.float {
	s := deptrFromHandle_Slice_float32(handle)
	return C.float(s[_idx])
}

//export Slice_float32_subslice
func Slice_float32_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_float32(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_float32(&ss))
}

//export Slice_float32_set
func Slice_float32_set(handle CGoHandle, _idx int, _vl C.float) {
	s := deptrFromHandle_Slice_float32(handle)
	s[_idx] = float32(_vl)
}

//export Slice_float32_append
func Slice_float32_append(handle CGoHandle, _vl C.float) {
	s := ptrFromHandle_Slice_float32(handle)
	*s = append(*s, float32(_vl))
}

// Converters for implicit pointer handles for type: []float64
func ptrFromHandle_Slice_float64(h CGoHandle) *[]float64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]float64")
	if p == nil {
		return nil
	}
	return p.(*[]float64)
}
func deptrFromHandle_Slice_float64(h CGoHandle) []float64 {
	p := ptrFromHandle_Slice_float64(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_float64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]float64", p))
}

// --- wrapping slice: []float64 ---
//
//export Slice_float64_CTor
func Slice_float64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_float64(&[]float64{}))
}

//export Slice_float64_len
func Slice_float64_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_float64(handle))
}

//export Slice_float64_elem
func Slice_float64_elem(handle CGoHandle, _idx int) C.double {
	s := deptrFromHandle_Slice_float64(handle)
	return C.double(s[_idx])
}

//export Slice_float64_subslice
func Slice_float64_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_float64(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_float64(&ss))
}

//export Slice_float64_set
func Slice_float64_set(handle CGoHandle, _idx int, _vl C.double) {
	s := deptrFromHandle_Slice_float64(handle)
	s[_idx] = float64(_vl)
}

//export Slice_float64_append
func Slice_float64_append(handle CGoHandle, _vl C.double) {
	s := ptrFromHandle_Slice_float64(handle)
	*s = append(*s, float64(_vl))
}

// Converters for implicit pointer handles for type: []int
func ptrFromHandle_Slice_int(h CGoHandle) *[]int {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int")
	if p == nil {
		return nil
	}
	return p.(*[]int)
}
func deptrFromHandle_Slice_int(h CGoHandle) []int {
	p := ptrFromHandle_Slice_int(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int", p))
}

// --- wrapping slice: []int ---
//
//export Slice_int_CTor
func Slice_int_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int(&[]int{}))
}

//export Slice_int_len
func Slice_int_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int(handle))
}

//export Slice_int_elem
func Slice_int_elem(handle CGoHandle, _idx int) C.longlong {
	s := deptrFromHandle_Slice_int(handle)
	return C.longlong(s[_idx])
}

//export Slice_int_subslice
func Slice_int_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int(&ss))
}

//export Slice_int_set
func Slice_int_set(handle CGoHandle, _idx int, _vl C.longlong) {
	s := deptrFromHandle_Slice_int(handle)
	s[_idx] = int(_vl)
}

//export Slice_int_append
func Slice_int_append(handle CGoHandle, _vl C.longlong) {
	s := ptrFromHandle_Slice_int(handle)
	*s = append(*s, int(_vl))
}

// Converters for implicit pointer handles for type: []int16
func ptrFromHandle_Slice_int16(h CGoHandle) *[]int16 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int16")
	if p == nil {
		return nil
	}
	return p.(*[]int16)
}
func deptrFromHandle_Slice_int16(h CGoHandle) []int16 {
	p := ptrFromHandle_Slice_int16(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int16(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int16", p))
}

// --- wrapping slice: []int16 ---
//
//export Slice_int16_CTor
func Slice_int16_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int16(&[]int16{}))
}

//export Slice_int16_len
func Slice_int16_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int16(handle))
}

//export Slice_int16_elem
func Slice_int16_elem(handle CGoHandle, _idx int) C.short {
	s := deptrFromHandle_Slice_int16(handle)
	return C.short(s[_idx])
}

//export Slice_int16_subslice
func Slice_int16_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int16(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int16(&ss))
}

//export Slice_int16_set
func Slice_int16_set(handle CGoHandle, _idx int, _vl C.short) {
	s := deptrFromHandle_Slice_int16(handle)
	s[_idx] = int16(_vl)
}

//export Slice_int16_append
func Slice_int16_append(handle CGoHandle, _vl C.short) {
	s := ptrFromHandle_Slice_int16(handle)
	*s = append(*s, int16(_vl))
}

// Converters for implicit pointer handles for type: []int32
func ptrFromHandle_Slice_int32(h CGoHandle) *[]int32 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int32")
	if p == nil {
		return nil
	}
	return p.(*[]int32)
}
func deptrFromHandle_Slice_int32(h CGoHandle) []int32 {
	p := ptrFromHandle_Slice_int32(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int32(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int32", p))
}

// --- wrapping slice: []int32 ---
//
//export Slice_int32_CTor
func Slice_int32_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int32(&[]int32{}))
}

//export Slice_int32_len
func Slice_int32_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int32(handle))
}

//export Slice_int32_elem
func Slice_int32_elem(handle CGoHandle, _idx int) C.long {
	s := deptrFromHandle_Slice_int32(handle)
	return C.long(s[_idx])
}

//export Slice_int32_subslice
func Slice_int32_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int32(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int32(&ss))
}

//export Slice_int32_set
func Slice_int32_set(handle CGoHandle, _idx int, _vl C.long) {
	s := deptrFromHandle_Slice_int32(handle)
	s[_idx] = int32(_vl)
}

//export Slice_int32_append
func Slice_int32_append(handle CGoHandle, _vl C.long) {
	s := ptrFromHandle_Slice_int32(handle)
	*s = append(*s, int32(_vl))
}

// Converters for implicit pointer handles for type: []int64
func ptrFromHandle_Slice_int64(h CGoHandle) *[]int64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int64")
	if p == nil {
		return nil
	}
	return p.(*[]int64)
}
func deptrFromHandle_Slice_int64(h CGoHandle) []int64 {
	p := ptrFromHandle_Slice_int64(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int64", p))
}

// --- wrapping slice: []int64 ---
//
//export Slice_int64_CTor
func Slice_int64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int64(&[]int64{}))
}

//export Slice_int64_len
func Slice_int64_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int64(handle))
}

//export Slice_int64_elem
func Slice_int64_elem(handle CGoHandle, _idx int) C.longlong {
	s := deptrFromHandle_Slice_int64(handle)
	return C.longlong(s[_idx])
}

//export Slice_int64_subslice
func Slice_int64_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int64(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int64(&ss))
}

//export Slice_int64_set
func Slice_int64_set(handle CGoHandle, _idx int, _vl C.longlong) {
	s := deptrFromHandle_Slice_int64(handle)
	s[_idx] = int64(_vl)
}

//export Slice_int64_append
func Slice_int64_append(handle CGoHandle, _vl C.longlong) {
	s := ptrFromHandle_Slice_int64(handle)
	*s = append(*s, int64(_vl))
}

// Converters for implicit pointer handles for type: []int8
func ptrFromHandle_Slice_int8(h CGoHandle) *[]int8 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int8")
	if p == nil {
		return nil
	}
	return p.(*[]int8)
}
func deptrFromHandle_Slice_int8(h CGoHandle) []int8 {
	p := ptrFromHandle_Slice_int8(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int8(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int8", p))
}

// --- wrapping slice: []int8 ---
//
//export Slice_int8_CTor
func Slice_int8_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int8(&[]int8{}))
}

//export Slice_int8_len
func Slice_int8_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int8(handle))
}

//export Slice_int8_elem
func Slice_int8_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_Slice_int8(handle)
	return C.char(s[_idx])
}

//export Slice_int8_subslice
func Slice_int8_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int8(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int8(&ss))
}

//export Slice_int8_set
func Slice_int8_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_Slice_int8(handle)
	s[_idx] = int8(_vl)
}

//export Slice_int8_append
func Slice_int8_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_Slice_int8(handle)
	*s = append(*s, int8(_vl))
}

// Converters for implicit pointer handles for type: []rune
func ptrFromHandle_Slice_rune(h CGoHandle) *[]rune {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]rune")
	if p == nil {
		return nil
	}
	return p.(*[]rune)
}
func deptrFromHandle_Slice_rune(h CGoHandle) []rune {
	p := ptrFromHandle_Slice_rune(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_rune(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]rune", p))
}

// --- wrapping slice: []rune ---
//
//export Slice_rune_CTor
func Slice_rune_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_rune(&[]rune{}))
}

//export Slice_rune_len
func Slice_rune_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_rune(handle))
}

//export Slice_rune_elem
func Slice_rune_elem(handle CGoHandle, _idx int) C.long {
	s := deptrFromHandle_Slice_rune(handle)
	return C.long(s[_idx])
}

//export Slice_rune_subslice
func Slice_rune_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_rune(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_rune(&ss))
}

//export Slice_rune_set
func Slice_rune_set(handle CGoHandle, _idx int, _vl C.long) {
	s := deptrFromHandle_Slice_rune(handle)
	s[_idx] = rune(_vl)
}

//export Slice_rune_append
func Slice_rune_append(handle CGoHandle, _vl C.long) {
	s := ptrFromHandle_Slice_rune(handle)
	*s = append(*s, rune(_vl))
}

// Converters for implicit pointer handles for type: []string
func ptrFromHandle_Slice_string(h CGoHandle) *[]string {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]string")
	if p == nil {
		return nil
	}
	return p.(*[]string)
}
func deptrFromHandle_Slice_string(h CGoHandle) []string {
	p := ptrFromHandle_Slice_string(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_string(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]string", p))
}

// --- wrapping slice: []string ---
//
//export Slice_string_CTor
func Slice_string_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_string(&[]string{}))
}

//export Slice_string_len
func Slice_string_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_string(handle))
}

//export Slice_string_elem
func Slice_string_elem(handle CGoHandle, _idx int) *C.char {
	s := deptrFromHandle_Slice_string(handle)
	return C.CString(s[_idx])
}

//export Slice_string_subslice
func Slice_string_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_string(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_string(&ss))
}

//export Slice_string_set
func Slice_string_set(handle CGoHandle, _idx int, _vl *C.char) {
	s := deptrFromHandle_Slice_string(handle)
	s[_idx] = C.GoString(_vl)
}

//export Slice_string_append
func Slice_string_append(handle CGoHandle, _vl *C.char) {
	s := ptrFromHandle_Slice_string(handle)
	*s = append(*s, C.GoString(_vl))
}

// Converters for implicit pointer handles for type: []uint
func ptrFromHandle_Slice_uint(h CGoHandle) *[]uint {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint")
	if p == nil {
		return nil
	}
	return p.(*[]uint)
}
func deptrFromHandle_Slice_uint(h CGoHandle) []uint {
	p := ptrFromHandle_Slice_uint(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint", p))
}

// --- wrapping slice: []uint ---
//
//export Slice_uint_CTor
func Slice_uint_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint(&[]uint{}))
}

//export Slice_uint_len
func Slice_uint_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint(handle))
}

//export Slice_uint_elem
func Slice_uint_elem(handle CGoHandle, _idx int) C.ulonglong {
	s := deptrFromHandle_Slice_uint(handle)
	return C.ulonglong(s[_idx])
}

//export Slice_uint_subslice
func Slice_uint_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint(&ss))
}

//export Slice_uint_set
func Slice_uint_set(handle CGoHandle, _idx int, _vl C.ulonglong) {
	s := deptrFromHandle_Slice_uint(handle)
	s[_idx] = uint(_vl)
}

//export Slice_uint_append
func Slice_uint_append(handle CGoHandle, _vl C.ulonglong) {
	s := ptrFromHandle_Slice_uint(handle)
	*s = append(*s, uint(_vl))
}

// Converters for implicit pointer handles for type: []uint16
func ptrFromHandle_Slice_uint16(h CGoHandle) *[]uint16 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint16")
	if p == nil {
		return nil
	}
	return p.(*[]uint16)
}
func deptrFromHandle_Slice_uint16(h CGoHandle) []uint16 {
	p := ptrFromHandle_Slice_uint16(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint16(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint16", p))
}

// --- wrapping slice: []uint16 ---
//
//export Slice_uint16_CTor
func Slice_uint16_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint16(&[]uint16{}))
}

//export Slice_uint16_len
func Slice_uint16_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint16(handle))
}

//export Slice_uint16_elem
func Slice_uint16_elem(handle CGoHandle, _idx int) C.ushort {
	s := deptrFromHandle_Slice_uint16(handle)
	return C.ushort(s[_idx])
}

//export Slice_uint16_subslice
func Slice_uint16_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint16(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint16(&ss))
}

//export Slice_uint16_set
func Slice_uint16_set(handle CGoHandle, _idx int, _vl C.ushort) {
	s := deptrFromHandle_Slice_uint16(handle)
	s[_idx] = uint16(_vl)
}

//export Slice_uint16_append
func Slice_uint16_append(handle CGoHandle, _vl C.ushort) {
	s := ptrFromHandle_Slice_uint16(handle)
	*s = append(*s, uint16(_vl))
}

// Converters for implicit pointer handles for type: []uint32
func ptrFromHandle_Slice_uint32(h CGoHandle) *[]uint32 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint32")
	if p == nil {
		return nil
	}
	return p.(*[]uint32)
}
func deptrFromHandle_Slice_uint32(h CGoHandle) []uint32 {
	p := ptrFromHandle_Slice_uint32(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint32(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint32", p))
}

// --- wrapping slice: []uint32 ---
//
//export Slice_uint32_CTor
func Slice_uint32_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint32(&[]uint32{}))
}

//export Slice_uint32_len
func Slice_uint32_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint32(handle))
}

//export Slice_uint32_elem
func Slice_uint32_elem(handle CGoHandle, _idx int) C.ulong {
	s := deptrFromHandle_Slice_uint32(handle)
	return C.ulong(s[_idx])
}

//export Slice_uint32_subslice
func Slice_uint32_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint32(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint32(&ss))
}

//export Slice_uint32_set
func Slice_uint32_set(handle CGoHandle, _idx int, _vl C.ulong) {
	s := deptrFromHandle_Slice_uint32(handle)
	s[_idx] = uint32(_vl)
}

//export Slice_uint32_append
func Slice_uint32_append(handle CGoHandle, _vl C.ulong) {
	s := ptrFromHandle_Slice_uint32(handle)
	*s = append(*s, uint32(_vl))
}

// Converters for implicit pointer handles for type: []uint64
func ptrFromHandle_Slice_uint64(h CGoHandle) *[]uint64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint64")
	if p == nil {
		return nil
	}
	return p.(*[]uint64)
}
func deptrFromHandle_Slice_uint64(h CGoHandle) []uint64 {
	p := ptrFromHandle_Slice_uint64(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint64", p))
}

// --- wrapping slice: []uint64 ---
//
//export Slice_uint64_CTor
func Slice_uint64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint64(&[]uint64{}))
}

//export Slice_uint64_len
func Slice_uint64_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint64(handle))
}

//export Slice_uint64_elem
func Slice_uint64_elem(handle CGoHandle, _idx int) C.ulonglong {
	s := deptrFromHandle_Slice_uint64(handle)
	return C.ulonglong(s[_idx])
}

//export Slice_uint64_subslice
func Slice_uint64_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint64(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint64(&ss))
}

//export Slice_uint64_set
func Slice_uint64_set(handle CGoHandle, _idx int, _vl C.ulonglong) {
	s := deptrFromHandle_Slice_uint64(handle)
	s[_idx] = uint64(_vl)
}

//export Slice_uint64_append
func Slice_uint64_append(handle CGoHandle, _vl C.ulonglong) {
	s := ptrFromHandle_Slice_uint64(handle)
	*s = append(*s, uint64(_vl))
}

// Converters for implicit pointer handles for type: []uint8
func ptrFromHandle_Slice_uint8(h CGoHandle) *[]uint8 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint8")
	if p == nil {
		return nil
	}
	return p.(*[]uint8)
}
func deptrFromHandle_Slice_uint8(h CGoHandle) []uint8 {
	p := ptrFromHandle_Slice_uint8(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint8(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint8", p))
}

// --- wrapping slice: []uint8 ---
//
//export Slice_uint8_CTor
func Slice_uint8_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint8(&[]uint8{}))
}

//export Slice_uint8_len
func Slice_uint8_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint8(handle))
}

//export Slice_uint8_elem
func Slice_uint8_elem(handle CGoHandle, _idx int) C.uchar {
	s := deptrFromHandle_Slice_uint8(handle)
	return C.uchar(s[_idx])
}

//export Slice_uint8_subslice
func Slice_uint8_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint8(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint8(&ss))
}

//export Slice_uint8_set
func Slice_uint8_set(handle CGoHandle, _idx int, _vl C.uchar) {
	s := deptrFromHandle_Slice_uint8(handle)
	s[_idx] = uint8(_vl)
}

//export Slice_uint8_append
func Slice_uint8_append(handle CGoHandle, _vl C.uchar) {
	s := ptrFromHandle_Slice_uint8(handle)
	*s = append(*s, uint8(_vl))
}

// ---- Package: ta ---

// ---- Types ---

// Converters for implicit pointer handles for type: [2]*banta.Series
func ptrFromHandle_Array_2_Ptr_banta_Series(h CGoHandle) *[2]*banta.Series {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[2]*banta.Series")
	if p == nil {
		return nil
	}
	return p.(*[2]*banta.Series)
}
func deptrFromHandle_Array_2_Ptr_banta_Series(h CGoHandle) [2]*banta.Series {
	p := ptrFromHandle_Array_2_Ptr_banta_Series(h)
	return *p
}
func handleFromPtr_Array_2_Ptr_banta_Series(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[2]*banta.Series", p))
}

// --- wrapping slice: [2]*banta.Series ---
//
//export Array_2_Ptr_banta_Series_CTor
func Array_2_Ptr_banta_Series_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Array_2_Ptr_banta_Series(&[2]*banta.Series{}))
}

//export Array_2_Ptr_banta_Series_len
func Array_2_Ptr_banta_Series_len(handle CGoHandle) int {
	return len(deptrFromHandle_Array_2_Ptr_banta_Series(handle))
}

//export Array_2_Ptr_banta_Series_elem
func Array_2_Ptr_banta_Series_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Array_2_Ptr_banta_Series(handle)
	return handleFromPtr_Ptr_banta_Series(&(s[_idx]))
}

//export Array_2_Ptr_banta_Series_set
func Array_2_Ptr_banta_Series_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Array_2_Ptr_banta_Series(handle)
	s[_idx] = ptrFromHandle_Ptr_banta_Series(_vl)
}

// Converters for implicit pointer handles for type: [3]*banta.Series
func ptrFromHandle_Array_3_Ptr_banta_Series(h CGoHandle) *[3]*banta.Series {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[3]*banta.Series")
	if p == nil {
		return nil
	}
	return p.(*[3]*banta.Series)
}
func deptrFromHandle_Array_3_Ptr_banta_Series(h CGoHandle) [3]*banta.Series {
	p := ptrFromHandle_Array_3_Ptr_banta_Series(h)
	return *p
}
func handleFromPtr_Array_3_Ptr_banta_Series(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[3]*banta.Series", p))
}

// --- wrapping slice: [3]*banta.Series ---
//
//export Array_3_Ptr_banta_Series_CTor
func Array_3_Ptr_banta_Series_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Array_3_Ptr_banta_Series(&[3]*banta.Series{}))
}

//export Array_3_Ptr_banta_Series_len
func Array_3_Ptr_banta_Series_len(handle CGoHandle) int {
	return len(deptrFromHandle_Array_3_Ptr_banta_Series(handle))
}

//export Array_3_Ptr_banta_Series_elem
func Array_3_Ptr_banta_Series_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Array_3_Ptr_banta_Series(handle)
	return handleFromPtr_Ptr_banta_Series(&(s[_idx]))
}

//export Array_3_Ptr_banta_Series_set
func Array_3_Ptr_banta_Series_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Array_3_Ptr_banta_Series(handle)
	s[_idx] = ptrFromHandle_Ptr_banta_Series(_vl)
}

// Converters for implicit pointer handles for type: [4]*banta.Series
func ptrFromHandle_Array_4_Ptr_banta_Series(h CGoHandle) *[4]*banta.Series {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[4]*banta.Series")
	if p == nil {
		return nil
	}
	return p.(*[4]*banta.Series)
}
func deptrFromHandle_Array_4_Ptr_banta_Series(h CGoHandle) [4]*banta.Series {
	p := ptrFromHandle_Array_4_Ptr_banta_Series(h)
	return *p
}
func handleFromPtr_Array_4_Ptr_banta_Series(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[4]*banta.Series", p))
}

// --- wrapping slice: [4]*banta.Series ---
//
//export Array_4_Ptr_banta_Series_CTor
func Array_4_Ptr_banta_Series_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Array_4_Ptr_banta_Series(&[4]*banta.Series{}))
}

//export Array_4_Ptr_banta_Series_len
func Array_4_Ptr_banta_Series_len(handle CGoHandle) int {
	return len(deptrFromHandle_Array_4_Ptr_banta_Series(handle))
}

//export Array_4_Ptr_banta_Series_elem
func Array_4_Ptr_banta_Series_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Array_4_Ptr_banta_Series(handle)
	return handleFromPtr_Ptr_banta_Series(&(s[_idx]))
}

//export Array_4_Ptr_banta_Series_set
func Array_4_Ptr_banta_Series_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Array_4_Ptr_banta_Series(handle)
	s[_idx] = ptrFromHandle_Ptr_banta_Series(_vl)
}

// Converters for implicit pointer handles for type: []*banta.Series
func ptrFromHandle_Slice_Ptr_banta_Series(h CGoHandle) *[]*banta.Series {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]*banta.Series")
	if p == nil {
		return nil
	}
	return p.(*[]*banta.Series)
}
func deptrFromHandle_Slice_Ptr_banta_Series(h CGoHandle) []*banta.Series {
	p := ptrFromHandle_Slice_Ptr_banta_Series(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_Ptr_banta_Series(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]*banta.Series", p))
}

// --- wrapping slice: []*banta.Series ---
//
//export Slice_Ptr_banta_Series_CTor
func Slice_Ptr_banta_Series_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_Ptr_banta_Series(&[]*banta.Series{}))
}

//export Slice_Ptr_banta_Series_len
func Slice_Ptr_banta_Series_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_Ptr_banta_Series(handle))
}

//export Slice_Ptr_banta_Series_elem
func Slice_Ptr_banta_Series_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_Ptr_banta_Series(handle)
	return handleFromPtr_Ptr_banta_Series(&(s[_idx]))
}

//export Slice_Ptr_banta_Series_subslice
func Slice_Ptr_banta_Series_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_Ptr_banta_Series(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_Ptr_banta_Series(&ss))
}

//export Slice_Ptr_banta_Series_set
func Slice_Ptr_banta_Series_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_Ptr_banta_Series(handle)
	s[_idx] = ptrFromHandle_Ptr_banta_Series(_vl)
}

//export Slice_Ptr_banta_Series_append
func Slice_Ptr_banta_Series_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_Ptr_banta_Series(handle)
	*s = append(*s, ptrFromHandle_Ptr_banta_Series(_vl))
}

// Converters for implicit pointer handles for type: []*banta.XState
func ptrFromHandle_Slice_Ptr_banta_XState(h CGoHandle) *[]*banta.XState {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]*banta.XState")
	if p == nil {
		return nil
	}
	return p.(*[]*banta.XState)
}
func deptrFromHandle_Slice_Ptr_banta_XState(h CGoHandle) []*banta.XState {
	p := ptrFromHandle_Slice_Ptr_banta_XState(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_Ptr_banta_XState(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]*banta.XState", p))
}

// --- wrapping slice: []*banta.XState ---
//
//export Slice_Ptr_banta_XState_CTor
func Slice_Ptr_banta_XState_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_Ptr_banta_XState(&[]*banta.XState{}))
}

//export Slice_Ptr_banta_XState_len
func Slice_Ptr_banta_XState_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_Ptr_banta_XState(handle))
}

//export Slice_Ptr_banta_XState_elem
func Slice_Ptr_banta_XState_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_Ptr_banta_XState(handle)
	return handleFromPtr_Ptr_banta_XState(&(s[_idx]))
}

//export Slice_Ptr_banta_XState_subslice
func Slice_Ptr_banta_XState_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_Ptr_banta_XState(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_Ptr_banta_XState(&ss))
}

//export Slice_Ptr_banta_XState_set
func Slice_Ptr_banta_XState_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_Ptr_banta_XState(handle)
	s[_idx] = ptrFromHandle_Ptr_banta_XState(_vl)
}

//export Slice_Ptr_banta_XState_append
func Slice_Ptr_banta_XState_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_Ptr_banta_XState(handle)
	*s = append(*s, ptrFromHandle_Ptr_banta_XState(_vl))
}

// Converters for implicit pointer handles for type: map[int]*banta.CrossLog
func ptrFromHandle_Map_int_Ptr_banta_CrossLog(h CGoHandle) *map[int]*banta.CrossLog {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "map[int]*banta.CrossLog")
	if p == nil {
		return nil
	}
	return p.(*map[int]*banta.CrossLog)
}
func deptrFromHandle_Map_int_Ptr_banta_CrossLog(h CGoHandle) map[int]*banta.CrossLog {
	p := ptrFromHandle_Map_int_Ptr_banta_CrossLog(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Map_int_Ptr_banta_CrossLog(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("map[int]*banta.CrossLog", p))
}

// --- wrapping map: map[int]*banta.CrossLog ---
//
//export Map_int_Ptr_banta_CrossLog_CTor
func Map_int_Ptr_banta_CrossLog_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Map_int_Ptr_banta_CrossLog(&map[int]*banta.CrossLog{}))
}

//export Map_int_Ptr_banta_CrossLog_len
func Map_int_Ptr_banta_CrossLog_len(handle CGoHandle) int {
	return len(deptrFromHandle_Map_int_Ptr_banta_CrossLog(handle))
}

//export Map_int_Ptr_banta_CrossLog_elem
func Map_int_Ptr_banta_CrossLog_elem(handle CGoHandle, _ky C.longlong) CGoHandle {
	s := deptrFromHandle_Map_int_Ptr_banta_CrossLog(handle)
	v, ok := s[int(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return handleFromPtr_Ptr_banta_CrossLog(&v)
}

//export Map_int_Ptr_banta_CrossLog_contains
func Map_int_Ptr_banta_CrossLog_contains(handle CGoHandle, _ky C.longlong) C.char {
	s := deptrFromHandle_Map_int_Ptr_banta_CrossLog(handle)
	_, ok := s[int(_ky)]
	return boolGoToPy(ok)
}

//export Map_int_Ptr_banta_CrossLog_set
func Map_int_Ptr_banta_CrossLog_set(handle CGoHandle, _ky C.longlong, _vl CGoHandle) {
	s := deptrFromHandle_Map_int_Ptr_banta_CrossLog(handle)
	s[int(_ky)] = ptrFromHandle_Ptr_banta_CrossLog(_vl)
}

//export Map_int_Ptr_banta_CrossLog_delete
func Map_int_Ptr_banta_CrossLog_delete(handle CGoHandle, _ky C.longlong) {
	s := deptrFromHandle_Map_int_Ptr_banta_CrossLog(handle)
	delete(s, int(_ky))
}

//export Map_int_Ptr_banta_CrossLog_keys
func Map_int_Ptr_banta_CrossLog_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_Map_int_Ptr_banta_CrossLog(handle)
	kys := make([]int, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_int(&kys)
}

// Converters for implicit pointer handles for type: map[int]*banta.Series
func ptrFromHandle_Map_int_Ptr_banta_Series(h CGoHandle) *map[int]*banta.Series {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "map[int]*banta.Series")
	if p == nil {
		return nil
	}
	return p.(*map[int]*banta.Series)
}
func deptrFromHandle_Map_int_Ptr_banta_Series(h CGoHandle) map[int]*banta.Series {
	p := ptrFromHandle_Map_int_Ptr_banta_Series(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Map_int_Ptr_banta_Series(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("map[int]*banta.Series", p))
}

// --- wrapping map: map[int]*banta.Series ---
//
//export Map_int_Ptr_banta_Series_CTor
func Map_int_Ptr_banta_Series_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Map_int_Ptr_banta_Series(&map[int]*banta.Series{}))
}

//export Map_int_Ptr_banta_Series_len
func Map_int_Ptr_banta_Series_len(handle CGoHandle) int {
	return len(deptrFromHandle_Map_int_Ptr_banta_Series(handle))
}

//export Map_int_Ptr_banta_Series_elem
func Map_int_Ptr_banta_Series_elem(handle CGoHandle, _ky C.longlong) CGoHandle {
	s := deptrFromHandle_Map_int_Ptr_banta_Series(handle)
	v, ok := s[int(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return handleFromPtr_Ptr_banta_Series(&v)
}

//export Map_int_Ptr_banta_Series_contains
func Map_int_Ptr_banta_Series_contains(handle CGoHandle, _ky C.longlong) C.char {
	s := deptrFromHandle_Map_int_Ptr_banta_Series(handle)
	_, ok := s[int(_ky)]
	return boolGoToPy(ok)
}

//export Map_int_Ptr_banta_Series_set
func Map_int_Ptr_banta_Series_set(handle CGoHandle, _ky C.longlong, _vl CGoHandle) {
	s := deptrFromHandle_Map_int_Ptr_banta_Series(handle)
	s[int(_ky)] = ptrFromHandle_Ptr_banta_Series(_vl)
}

//export Map_int_Ptr_banta_Series_delete
func Map_int_Ptr_banta_Series_delete(handle CGoHandle, _ky C.longlong) {
	s := deptrFromHandle_Map_int_Ptr_banta_Series(handle)
	delete(s, int(_ky))
}

//export Map_int_Ptr_banta_Series_keys
func Map_int_Ptr_banta_Series_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_Map_int_Ptr_banta_Series(handle)
	kys := make([]int, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_int(&kys)
}

// Converters for implicit pointer handles for type: map[string]interface{}
func ptrFromHandle_Map_string_interface_(h CGoHandle) *map[string]interface{} {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "map[string]interface{}")
	if p == nil {
		return nil
	}
	return p.(*map[string]interface{})
}
func deptrFromHandle_Map_string_interface_(h CGoHandle) map[string]interface{} {
	p := ptrFromHandle_Map_string_interface_(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Map_string_interface_(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("map[string]interface{}", p))
}

// --- wrapping map: map[string]interface{} ---
//
//export Map_string_interface__CTor
func Map_string_interface__CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Map_string_interface_(&map[string]interface{}{}))
}

//export Map_string_interface__len
func Map_string_interface__len(handle CGoHandle) int {
	return len(deptrFromHandle_Map_string_interface_(handle))
}

//export Map_string_interface__elem
func Map_string_interface__elem(handle CGoHandle, _ky *C.char) *C.char {
	s := deptrFromHandle_Map_string_interface_(handle)
	v, ok := s[C.GoString(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return C.CString(fmt.Sprintf("%s", (v)))
}

//export Map_string_interface__contains
func Map_string_interface__contains(handle CGoHandle, _ky *C.char) C.char {
	s := deptrFromHandle_Map_string_interface_(handle)
	_, ok := s[C.GoString(_ky)]
	return boolGoToPy(ok)
}

//export Map_string_interface__set
func Map_string_interface__set(handle CGoHandle, _ky *C.char, _vl *C.char) {
	s := deptrFromHandle_Map_string_interface_(handle)
	s[C.GoString(_ky)] = C.GoString(_vl)
}

//export Map_string_interface__delete
func Map_string_interface__delete(handle CGoHandle, _ky *C.char) {
	s := deptrFromHandle_Map_string_interface_(handle)
	delete(s, C.GoString(_ky))
}

//export Map_string_interface__keys
func Map_string_interface__keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_Map_string_interface_(handle)
	kys := make([]string, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_string(&kys)
}

// Converters for implicit pointer handles for type: map[string]map[int]*banta.Series
func ptrFromHandle_Map_string_Map_int_Ptr_banta_Series(h CGoHandle) *map[string]map[int]*banta.Series {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "map[string]map[int]*banta.Series")
	if p == nil {
		return nil
	}
	return p.(*map[string]map[int]*banta.Series)
}
func deptrFromHandle_Map_string_Map_int_Ptr_banta_Series(h CGoHandle) map[string]map[int]*banta.Series {
	p := ptrFromHandle_Map_string_Map_int_Ptr_banta_Series(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Map_string_Map_int_Ptr_banta_Series(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("map[string]map[int]*banta.Series", p))
}

// --- wrapping map: map[string]map[int]*banta.Series ---
//
//export Map_string_Map_int_Ptr_banta_Series_CTor
func Map_string_Map_int_Ptr_banta_Series_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Map_string_Map_int_Ptr_banta_Series(&map[string]map[int]*banta.Series{}))
}

//export Map_string_Map_int_Ptr_banta_Series_len
func Map_string_Map_int_Ptr_banta_Series_len(handle CGoHandle) int {
	return len(deptrFromHandle_Map_string_Map_int_Ptr_banta_Series(handle))
}

//export Map_string_Map_int_Ptr_banta_Series_elem
func Map_string_Map_int_Ptr_banta_Series_elem(handle CGoHandle, _ky *C.char) CGoHandle {
	s := deptrFromHandle_Map_string_Map_int_Ptr_banta_Series(handle)
	v, ok := s[C.GoString(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return handleFromPtr_Map_int_Ptr_banta_Series(&v)
}

//export Map_string_Map_int_Ptr_banta_Series_contains
func Map_string_Map_int_Ptr_banta_Series_contains(handle CGoHandle, _ky *C.char) C.char {
	s := deptrFromHandle_Map_string_Map_int_Ptr_banta_Series(handle)
	_, ok := s[C.GoString(_ky)]
	return boolGoToPy(ok)
}

//export Map_string_Map_int_Ptr_banta_Series_set
func Map_string_Map_int_Ptr_banta_Series_set(handle CGoHandle, _ky *C.char, _vl CGoHandle) {
	s := deptrFromHandle_Map_string_Map_int_Ptr_banta_Series(handle)
	s[C.GoString(_ky)] = deptrFromHandle_Map_int_Ptr_banta_Series(_vl)
}

//export Map_string_Map_int_Ptr_banta_Series_delete
func Map_string_Map_int_Ptr_banta_Series_delete(handle CGoHandle, _ky *C.char) {
	s := deptrFromHandle_Map_string_Map_int_Ptr_banta_Series(handle)
	delete(s, C.GoString(_ky))
}

//export Map_string_Map_int_Ptr_banta_Series_keys
func Map_string_Map_int_Ptr_banta_Series_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_Map_string_Map_int_Ptr_banta_Series(handle)
	kys := make([]string, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_string(&kys)
}

// ---- Global Variables: can only use functions to access ---

// ---- Interfaces ---

// ---- Structs ---

// --- wrapping struct: banta.BarEnv ---
//
//export banta_BarEnv_CTor
func banta_BarEnv_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_banta_BarEnv(&banta.BarEnv{}))
}

//export banta_BarEnv_TimeStart_Get
func banta_BarEnv_TimeStart_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_banta_BarEnv(handle)
	return C.longlong(op.TimeStart)
}

//export banta_BarEnv_TimeStart_Set
func banta_BarEnv_TimeStart_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_banta_BarEnv(handle)
	op.TimeStart = int64(val)
}

//export banta_BarEnv_TimeStop_Get
func banta_BarEnv_TimeStop_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_banta_BarEnv(handle)
	return C.longlong(op.TimeStop)
}

//export banta_BarEnv_TimeStop_Set
func banta_BarEnv_TimeStop_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_banta_BarEnv(handle)
	op.TimeStop = int64(val)
}

//export banta_BarEnv_Exchange_Get
func banta_BarEnv_Exchange_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_banta_BarEnv(handle)
	return C.CString(op.Exchange)
}

//export banta_BarEnv_Exchange_Set
func banta_BarEnv_Exchange_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_banta_BarEnv(handle)
	op.Exchange = C.GoString(val)
}

//export banta_BarEnv_MarketType_Get
func banta_BarEnv_MarketType_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_banta_BarEnv(handle)
	return C.CString(op.MarketType)
}

//export banta_BarEnv_MarketType_Set
func banta_BarEnv_MarketType_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_banta_BarEnv(handle)
	op.MarketType = C.GoString(val)
}

//export banta_BarEnv_Symbol_Get
func banta_BarEnv_Symbol_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_banta_BarEnv(handle)
	return C.CString(op.Symbol)
}

//export banta_BarEnv_Symbol_Set
func banta_BarEnv_Symbol_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_banta_BarEnv(handle)
	op.Symbol = C.GoString(val)
}

//export banta_BarEnv_TimeFrame_Get
func banta_BarEnv_TimeFrame_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_banta_BarEnv(handle)
	return C.CString(op.TimeFrame)
}

//export banta_BarEnv_TimeFrame_Set
func banta_BarEnv_TimeFrame_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_banta_BarEnv(handle)
	op.TimeFrame = C.GoString(val)
}

//export banta_BarEnv_TFMSecs_Get
func banta_BarEnv_TFMSecs_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_banta_BarEnv(handle)
	return C.longlong(op.TFMSecs)
}

//export banta_BarEnv_TFMSecs_Set
func banta_BarEnv_TFMSecs_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_banta_BarEnv(handle)
	op.TFMSecs = int64(val)
}

//export banta_BarEnv_BarNum_Get
func banta_BarEnv_BarNum_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_banta_BarEnv(handle)
	return C.longlong(op.BarNum)
}

//export banta_BarEnv_BarNum_Set
func banta_BarEnv_BarNum_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_banta_BarEnv(handle)
	op.BarNum = int(val)
}

//export banta_BarEnv_MaxCache_Get
func banta_BarEnv_MaxCache_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_banta_BarEnv(handle)
	return C.longlong(op.MaxCache)
}

//export banta_BarEnv_MaxCache_Set
func banta_BarEnv_MaxCache_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_banta_BarEnv(handle)
	op.MaxCache = int(val)
}

//export banta_BarEnv_VNum_Get
func banta_BarEnv_VNum_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_banta_BarEnv(handle)
	return C.longlong(op.VNum)
}

//export banta_BarEnv_VNum_Set
func banta_BarEnv_VNum_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_banta_BarEnv(handle)
	op.VNum = int(val)
}

//export banta_BarEnv_Open_Get
func banta_BarEnv_Open_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_banta_BarEnv(handle)
	return handleFromPtr_Ptr_banta_Series(op.Open)
}

//export banta_BarEnv_Open_Set
func banta_BarEnv_Open_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_banta_BarEnv(handle)
	op.Open = ptrFromHandle_Ptr_banta_Series(val)
}

//export banta_BarEnv_High_Get
func banta_BarEnv_High_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_banta_BarEnv(handle)
	return handleFromPtr_Ptr_banta_Series(op.High)
}

//export banta_BarEnv_High_Set
func banta_BarEnv_High_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_banta_BarEnv(handle)
	op.High = ptrFromHandle_Ptr_banta_Series(val)
}

//export banta_BarEnv_Low_Get
func banta_BarEnv_Low_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_banta_BarEnv(handle)
	return handleFromPtr_Ptr_banta_Series(op.Low)
}

//export banta_BarEnv_Low_Set
func banta_BarEnv_Low_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_banta_BarEnv(handle)
	op.Low = ptrFromHandle_Ptr_banta_Series(val)
}

//export banta_BarEnv_Close_Get
func banta_BarEnv_Close_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_banta_BarEnv(handle)
	return handleFromPtr_Ptr_banta_Series(op.Close)
}

//export banta_BarEnv_Close_Set
func banta_BarEnv_Close_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_banta_BarEnv(handle)
	op.Close = ptrFromHandle_Ptr_banta_Series(val)
}

//export banta_BarEnv_Volume_Get
func banta_BarEnv_Volume_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_banta_BarEnv(handle)
	return handleFromPtr_Ptr_banta_Series(op.Volume)
}

//export banta_BarEnv_Volume_Set
func banta_BarEnv_Volume_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_banta_BarEnv(handle)
	op.Volume = ptrFromHandle_Ptr_banta_Series(val)
}

//export banta_BarEnv_Info_Get
func banta_BarEnv_Info_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_banta_BarEnv(handle)
	return handleFromPtr_Ptr_banta_Series(op.Info)
}

//export banta_BarEnv_Info_Set
func banta_BarEnv_Info_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_banta_BarEnv(handle)
	op.Info = ptrFromHandle_Ptr_banta_Series(val)
}

//export banta_BarEnv_Data_Get
func banta_BarEnv_Data_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_banta_BarEnv(handle)
	return handleFromPtr_Map_string_interface_(&op.Data)
}

//export banta_BarEnv_Data_Set
func banta_BarEnv_Data_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_banta_BarEnv(handle)
	op.Data = deptrFromHandle_Map_string_interface_(val)
}

//export banta_BarEnv_OnBar
func banta_BarEnv_OnBar(_handle CGoHandle, barMs C.longlong, open C.double, high C.double, low C.double, close C.double, volume C.double, info C.double) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*banta.BarEnv")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(banta.BarEnv{})).(*banta.BarEnv).OnBar(int64(barMs), float64(open), float64(high), float64(low), float64(close), float64(volume), float64(info))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export banta_BarEnv_Reset
func banta_BarEnv_Reset(_handle CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*banta.BarEnv")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(banta.BarEnv{})).(*banta.BarEnv).Reset()
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(banta.BarEnv{})).(*banta.BarEnv).Reset()
	}
}

//export banta_BarEnv_TrimOverflow
func banta_BarEnv_TrimOverflow(_handle CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*banta.BarEnv")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(banta.BarEnv{})).(*banta.BarEnv).TrimOverflow()
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(banta.BarEnv{})).(*banta.BarEnv).TrimOverflow()
	}
}

//export banta_BarEnv_NewSeries
func banta_BarEnv_NewSeries(_handle CGoHandle, data CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*banta.BarEnv")
	if __err != nil {
		return handleFromPtr_Ptr_banta_Series(nil)
	}
	return handleFromPtr_Ptr_banta_Series(gopyh.Embed(vifc, reflect.TypeOf(banta.BarEnv{})).(*banta.BarEnv).NewSeries(deptrFromHandle_Slice_float64(data)))

}

//export banta_BarEnv_BarCount
func banta_BarEnv_BarCount(_handle CGoHandle, start C.longlong) C.double {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*banta.BarEnv")
	if __err != nil {
		return C.double(0)
	}
	return C.double(gopyh.Embed(vifc, reflect.TypeOf(banta.BarEnv{})).(*banta.BarEnv).BarCount(int64(start)))

}

// --- wrapping struct: banta.Series ---
//
//export banta_Series_CTor
func banta_Series_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_banta_Series(&banta.Series{}))
}

//export banta_Series_ID_Get
func banta_Series_ID_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_banta_Series(handle)
	return C.longlong(op.ID)
}

//export banta_Series_ID_Set
func banta_Series_ID_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_banta_Series(handle)
	op.ID = int(val)
}

//export banta_Series_Env_Get
func banta_Series_Env_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_banta_Series(handle)
	return handleFromPtr_Ptr_banta_BarEnv(op.Env)
}

//export banta_Series_Env_Set
func banta_Series_Env_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_banta_Series(handle)
	op.Env = ptrFromHandle_Ptr_banta_BarEnv(val)
}

//export banta_Series_Data_Get
func banta_Series_Data_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_banta_Series(handle)
	return handleFromPtr_Slice_float64(&op.Data)
}

//export banta_Series_Data_Set
func banta_Series_Data_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_banta_Series(handle)
	op.Data = deptrFromHandle_Slice_float64(val)
}

//export banta_Series_Cols_Get
func banta_Series_Cols_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_banta_Series(handle)
	return handleFromPtr_Slice_Ptr_banta_Series(&op.Cols)
}

//export banta_Series_Cols_Set
func banta_Series_Cols_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_banta_Series(handle)
	op.Cols = deptrFromHandle_Slice_Ptr_banta_Series(val)
}

//export banta_Series_Time_Get
func banta_Series_Time_Get(handle CGoHandle) C.longlong {
	op := ptrFromHandle_banta_Series(handle)
	return C.longlong(op.Time)
}

//export banta_Series_Time_Set
func banta_Series_Time_Set(handle CGoHandle, val C.longlong) {
	op := ptrFromHandle_banta_Series(handle)
	op.Time = int64(val)
}

//export banta_Series_Subs_Get
func banta_Series_Subs_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_banta_Series(handle)
	return handleFromPtr_Map_string_Map_int_Ptr_banta_Series(&op.Subs)
}

//export banta_Series_Subs_Set
func banta_Series_Subs_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_banta_Series(handle)
	op.Subs = deptrFromHandle_Map_string_Map_int_Ptr_banta_Series(val)
}

//export banta_Series_XLogs_Get
func banta_Series_XLogs_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_banta_Series(handle)
	return handleFromPtr_Map_int_Ptr_banta_CrossLog(&op.XLogs)
}

//export banta_Series_XLogs_Set
func banta_Series_XLogs_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_banta_Series(handle)
	op.XLogs = deptrFromHandle_Map_int_Ptr_banta_CrossLog(val)
}

//export banta_Series_Set
func banta_Series_Set(_handle CGoHandle, obj *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*banta.Series")
	if __err != nil {
		return handleFromPtr_Ptr_banta_Series(nil)
	}
	return handleFromPtr_Ptr_banta_Series(gopyh.Embed(vifc, reflect.TypeOf(banta.Series{})).(*banta.Series).Set(C.GoString(obj)))

}

//export banta_Series_Append
func banta_Series_Append(_handle CGoHandle, obj *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*banta.Series")
	if __err != nil {
		return handleFromPtr_Ptr_banta_Series(nil)
	}
	return handleFromPtr_Ptr_banta_Series(gopyh.Embed(vifc, reflect.TypeOf(banta.Series{})).(*banta.Series).Append(C.GoString(obj)))

}

//export banta_Series_Cached
func banta_Series_Cached(_handle CGoHandle) C.char {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*banta.Series")
	if __err != nil {
		return boolGoToPy(false)
	}
	return boolGoToPy(gopyh.Embed(vifc, reflect.TypeOf(banta.Series{})).(*banta.Series).Cached())

}

//export banta_Series_Get
func banta_Series_Get(_handle CGoHandle, i C.longlong) C.double {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*banta.Series")
	if __err != nil {
		return C.double(0)
	}
	return C.double(gopyh.Embed(vifc, reflect.TypeOf(banta.Series{})).(*banta.Series).Get(int(i)))

}

//export banta_Series_Range
func banta_Series_Range(_handle CGoHandle, start C.longlong, stop C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*banta.Series")
	if __err != nil {
		return handleFromPtr_Slice_float64(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(banta.Series{})).(*banta.Series).Range(int(start), int(stop))

	return handleFromPtr_Slice_float64(&cret)
}

//export banta_Series_Add
func banta_Series_Add(_handle CGoHandle, obj *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*banta.Series")
	if __err != nil {
		return handleFromPtr_Ptr_banta_Series(nil)
	}
	return handleFromPtr_Ptr_banta_Series(gopyh.Embed(vifc, reflect.TypeOf(banta.Series{})).(*banta.Series).Add(C.GoString(obj)))

}

//export banta_Series_Sub
func banta_Series_Sub(_handle CGoHandle, obj *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*banta.Series")
	if __err != nil {
		return handleFromPtr_Ptr_banta_Series(nil)
	}
	return handleFromPtr_Ptr_banta_Series(gopyh.Embed(vifc, reflect.TypeOf(banta.Series{})).(*banta.Series).Sub(C.GoString(obj)))

}

//export banta_Series_Mul
func banta_Series_Mul(_handle CGoHandle, obj *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*banta.Series")
	if __err != nil {
		return handleFromPtr_Ptr_banta_Series(nil)
	}
	return handleFromPtr_Ptr_banta_Series(gopyh.Embed(vifc, reflect.TypeOf(banta.Series{})).(*banta.Series).Mul(C.GoString(obj)))

}

//export banta_Series_Div
func banta_Series_Div(_handle CGoHandle, obj *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*banta.Series")
	if __err != nil {
		return handleFromPtr_Ptr_banta_Series(nil)
	}
	return handleFromPtr_Ptr_banta_Series(gopyh.Embed(vifc, reflect.TypeOf(banta.Series{})).(*banta.Series).Div(C.GoString(obj)))

}

//export banta_Series_Min
func banta_Series_Min(_handle CGoHandle, obj *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*banta.Series")
	if __err != nil {
		return handleFromPtr_Ptr_banta_Series(nil)
	}
	return handleFromPtr_Ptr_banta_Series(gopyh.Embed(vifc, reflect.TypeOf(banta.Series{})).(*banta.Series).Min(C.GoString(obj)))

}

//export banta_Series_Max
func banta_Series_Max(_handle CGoHandle, obj *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*banta.Series")
	if __err != nil {
		return handleFromPtr_Ptr_banta_Series(nil)
	}
	return handleFromPtr_Ptr_banta_Series(gopyh.Embed(vifc, reflect.TypeOf(banta.Series{})).(*banta.Series).Max(C.GoString(obj)))

}

//export banta_Series_Abs
func banta_Series_Abs(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*banta.Series")
	if __err != nil {
		return handleFromPtr_Ptr_banta_Series(nil)
	}
	return handleFromPtr_Ptr_banta_Series(gopyh.Embed(vifc, reflect.TypeOf(banta.Series{})).(*banta.Series).Abs())

}

//export banta_Series_Len
func banta_Series_Len(_handle CGoHandle) C.longlong {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*banta.Series")
	if __err != nil {
		return C.longlong(0)
	}
	return C.longlong(gopyh.Embed(vifc, reflect.TypeOf(banta.Series{})).(*banta.Series).Len())

}

//export banta_Series_Cut
func banta_Series_Cut(_handle CGoHandle, keepNum C.longlong, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*banta.Series")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(banta.Series{})).(*banta.Series).Cut(int(keepNum))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(banta.Series{})).(*banta.Series).Cut(int(keepNum))
	}
}

//export banta_Series_Back
func banta_Series_Back(_handle CGoHandle, num C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*banta.Series")
	if __err != nil {
		return handleFromPtr_Ptr_banta_Series(nil)
	}
	return handleFromPtr_Ptr_banta_Series(gopyh.Embed(vifc, reflect.TypeOf(banta.Series{})).(*banta.Series).Back(int(num)))

}

//export banta_Series_To
func banta_Series_To(_handle CGoHandle, k *C.char, v C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*banta.Series")
	if __err != nil {
		return handleFromPtr_Ptr_banta_Series(nil)
	}
	return handleFromPtr_Ptr_banta_Series(gopyh.Embed(vifc, reflect.TypeOf(banta.Series{})).(*banta.Series).To(C.GoString(k), int(v)))

}

// ---- Slices ---

// ---- Maps ---

// ---- Constructors ---

//export ta_CMO
func ta_CMO(obj CGoHandle, period C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_banta_Series(ta.CMO(ptrFromHandle_Ptr_banta_Series(obj), int(period)))

}

//export ta_EMA
func ta_EMA(obj CGoHandle, period C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_banta_Series(ta.EMA(ptrFromHandle_Ptr_banta_Series(obj), int(period)))

}

//export ta_SMA
func ta_SMA(obj CGoHandle, period C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_banta_Series(ta.SMA(ptrFromHandle_Ptr_banta_Series(obj), int(period)))

}

//export ta_Stiffness
func ta_Stiffness(obj CGoHandle, maLen C.longlong, stiffLen C.longlong, stiffMa C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_banta_Series(ta.Stiffness(ptrFromHandle_Ptr_banta_Series(obj), int(maLen), int(stiffLen), int(stiffMa)))

}

//export ta_ADX
func ta_ADX(high CGoHandle, low CGoHandle, close CGoHandle, period C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_banta_Series(ta.ADX(ptrFromHandle_Ptr_banta_Series(high), ptrFromHandle_Ptr_banta_Series(low), ptrFromHandle_Ptr_banta_Series(close), int(period)))

}

//export ta_HLC3
func ta_HLC3(h CGoHandle, l CGoHandle, c CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_banta_Series(ta.HLC3(ptrFromHandle_Ptr_banta_Series(h), ptrFromHandle_Ptr_banta_Series(l), ptrFromHandle_Ptr_banta_Series(c)))

}

//export ta_LowestBar
func ta_LowestBar(obj CGoHandle, period C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_banta_Series(ta.LowestBar(ptrFromHandle_Ptr_banta_Series(obj), int(period)))

}

//export ta_MFI
func ta_MFI(e CGoHandle, period C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_banta_Series(ta.MFI(ptrFromHandle_Ptr_banta_BarEnv(e), int(period)))

}

//export ta_KAMABy
func ta_KAMABy(obj CGoHandle, period C.longlong, fast C.longlong, slow C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_banta_Series(ta.KAMABy(ptrFromHandle_Ptr_banta_Series(obj), int(period), int(fast), int(slow)))

}

//export ta_ROC
func ta_ROC(obj CGoHandle, period C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_banta_Series(ta.ROC(ptrFromHandle_Ptr_banta_Series(obj), int(period)))

}

//export ta_STC
func ta_STC(obj CGoHandle, period C.longlong, fast C.longlong, slow C.longlong, alpha C.double) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_banta_Series(ta.STC(ptrFromHandle_Ptr_banta_Series(obj), int(period), int(fast), int(slow), float64(alpha)))

}

//export ta_CTI
func ta_CTI(obj CGoHandle, period C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_banta_Series(ta.CTI(ptrFromHandle_Ptr_banta_Series(obj), int(period)))

}

//export ta_UTBot
func ta_UTBot(c CGoHandle, atr CGoHandle, rate C.double) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_banta_Series(ta.UTBot(ptrFromHandle_Ptr_banta_Series(c), ptrFromHandle_Ptr_banta_Series(atr), float64(rate)))

}

//export ta_RMA
func ta_RMA(obj CGoHandle, period C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_banta_Series(ta.RMA(ptrFromHandle_Ptr_banta_Series(obj), int(period)))

}

//export ta_CHOP
func ta_CHOP(e CGoHandle, period C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_banta_Series(ta.CHOP(ptrFromHandle_Ptr_banta_BarEnv(e), int(period)))

}

//export ta_HL2
func ta_HL2(h CGoHandle, l CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_banta_Series(ta.HL2(ptrFromHandle_Ptr_banta_Series(h), ptrFromHandle_Ptr_banta_Series(l)))

}

//export ta_CMF
func ta_CMF(env CGoHandle, period C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_banta_Series(ta.CMF(ptrFromHandle_Ptr_banta_BarEnv(env), int(period)))

}

//export ta_WillR
func ta_WillR(e CGoHandle, period C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_banta_Series(ta.WillR(ptrFromHandle_Ptr_banta_BarEnv(e), int(period)))

}

//export ta_LinRegAdv
func ta_LinRegAdv(obj CGoHandle, period C.longlong, angle C.char, intercept C.char, degrees C.char, r C.char, slope C.char, tsf C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_banta_Series(ta.LinRegAdv(ptrFromHandle_Ptr_banta_Series(obj), int(period), boolPyToGo(angle), boolPyToGo(intercept), boolPyToGo(degrees), boolPyToGo(r), boolPyToGo(slope), boolPyToGo(tsf)))

}

//export ta_Sum
func ta_Sum(obj CGoHandle, period C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_banta_Series(ta.Sum(ptrFromHandle_Ptr_banta_Series(obj), int(period)))

}

//export ta_EMABy
func ta_EMABy(obj CGoHandle, period C.longlong, initType C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_banta_Series(ta.EMABy(ptrFromHandle_Ptr_banta_Series(obj), int(period), int(initType)))

}

//export ta_HMA
func ta_HMA(obj CGoHandle, period C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_banta_Series(ta.HMA(ptrFromHandle_Ptr_banta_Series(obj), int(period)))

}

//export ta_RSI
func ta_RSI(obj CGoHandle, period C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_banta_Series(ta.RSI(ptrFromHandle_Ptr_banta_Series(obj), int(period)))

}

//export ta_RSI50
func ta_RSI50(obj CGoHandle, period C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_banta_Series(ta.RSI50(ptrFromHandle_Ptr_banta_Series(obj), int(period)))

}

//export ta_WMA
func ta_WMA(obj CGoHandle, period C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_banta_Series(ta.WMA(ptrFromHandle_Ptr_banta_Series(obj), int(period)))

}

//export ta_Highest
func ta_Highest(obj CGoHandle, period C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_banta_Series(ta.Highest(ptrFromHandle_Ptr_banta_Series(obj), int(period)))

}

//export ta_Lowest
func ta_Lowest(obj CGoHandle, period C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_banta_Series(ta.Lowest(ptrFromHandle_Ptr_banta_Series(obj), int(period)))

}

//export ta_TR
func ta_TR(high CGoHandle, low CGoHandle, close CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_banta_Series(ta.TR(ptrFromHandle_Ptr_banta_Series(high), ptrFromHandle_Ptr_banta_Series(low), ptrFromHandle_Ptr_banta_Series(close)))

}

//export ta_UpDown
func ta_UpDown(obj CGoHandle, vtype C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_banta_Series(ta.UpDown(ptrFromHandle_Ptr_banta_Series(obj), int(vtype)))

}

//export ta_AvgDev
func ta_AvgDev(obj CGoHandle, period C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_banta_Series(ta.AvgDev(ptrFromHandle_Ptr_banta_Series(obj), int(period)))

}

//export ta_CCI
func ta_CCI(obj CGoHandle, period C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_banta_Series(ta.CCI(ptrFromHandle_Ptr_banta_Series(obj), int(period)))

}

//export ta_CRSIBy
func ta_CRSIBy(obj CGoHandle, period C.longlong, upDn C.longlong, roc C.longlong, vtype C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_banta_Series(ta.CRSIBy(ptrFromHandle_Ptr_banta_Series(obj), int(period), int(upDn), int(roc), int(vtype)))

}

//export ta_StdDev
func ta_StdDev(obj CGoHandle, period C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_banta_Series(ta.StdDev(ptrFromHandle_Ptr_banta_Series(obj), int(period)))

}

//export ta_CMOBy
func ta_CMOBy(obj CGoHandle, period C.longlong, maType C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_banta_Series(ta.CMOBy(ptrFromHandle_Ptr_banta_Series(obj), int(period), int(maType)))

}

//export ta_PercentRank
func ta_PercentRank(obj CGoHandle, period C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_banta_Series(ta.PercentRank(ptrFromHandle_Ptr_banta_Series(obj), int(period)))

}

//export ta_VWMA
func ta_VWMA(price CGoHandle, vol CGoHandle, period C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_banta_Series(ta.VWMA(ptrFromHandle_Ptr_banta_Series(price), ptrFromHandle_Ptr_banta_Series(vol), int(period)))

}

//export ta_ER
func ta_ER(obj CGoHandle, period C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_banta_Series(ta.ER(ptrFromHandle_Ptr_banta_Series(obj), int(period)))

}

//export ta_LinReg
func ta_LinReg(obj CGoHandle, period C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_banta_Series(ta.LinReg(ptrFromHandle_Ptr_banta_Series(obj), int(period)))

}

//export ta_RMABy
func ta_RMABy(obj CGoHandle, period C.longlong, initType C.longlong, initVal C.double) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_banta_Series(ta.RMABy(ptrFromHandle_Ptr_banta_Series(obj), int(period), int(initType), float64(initVal)))

}

//export ta_ADL
func ta_ADL(env CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_banta_Series(ta.ADL(ptrFromHandle_Ptr_banta_BarEnv(env)))

}

//export ta_ALMA
func ta_ALMA(obj CGoHandle, period C.longlong, sigma C.double, distOff C.double) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_banta_Series(ta.ALMA(ptrFromHandle_Ptr_banta_Series(obj), int(period), float64(sigma), float64(distOff)))

}

//export ta_ChaikinOsc
func ta_ChaikinOsc(env CGoHandle, sml C.longlong, big C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_banta_Series(ta.ChaikinOsc(ptrFromHandle_Ptr_banta_BarEnv(env), int(sml), int(big)))

}

//export ta_DV2
func ta_DV2(h CGoHandle, l CGoHandle, c CGoHandle, period C.longlong, maLen C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_banta_Series(ta.DV2(ptrFromHandle_Ptr_banta_Series(h), ptrFromHandle_Ptr_banta_Series(l), ptrFromHandle_Ptr_banta_Series(c), int(period), int(maLen)))

}

//export ta_ADXBy
func ta_ADXBy(high CGoHandle, low CGoHandle, close CGoHandle, period C.longlong, smoothing C.longlong, method C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_banta_Series(ta.ADXBy(ptrFromHandle_Ptr_banta_Series(high), ptrFromHandle_Ptr_banta_Series(low), ptrFromHandle_Ptr_banta_Series(close), int(period), int(smoothing), int(method)))

}

//export ta_RMI
func ta_RMI(obj CGoHandle, period C.longlong, montLen C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_banta_Series(ta.RMI(ptrFromHandle_Ptr_banta_Series(obj), int(period), int(montLen)))

}

//export ta_TD
func ta_TD(obj CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_banta_Series(ta.TD(ptrFromHandle_Ptr_banta_Series(obj)))

}

//export ta_KAMA
func ta_KAMA(obj CGoHandle, period C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_banta_Series(ta.KAMA(ptrFromHandle_Ptr_banta_Series(obj), int(period)))

}

//export ta_ATR
func ta_ATR(high CGoHandle, low CGoHandle, close CGoHandle, period C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_banta_Series(ta.ATR(ptrFromHandle_Ptr_banta_Series(high), ptrFromHandle_Ptr_banta_Series(low), ptrFromHandle_Ptr_banta_Series(close), int(period)))

}

//export ta_AvgPrice
func ta_AvgPrice(e CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_banta_Series(ta.AvgPrice(ptrFromHandle_Ptr_banta_BarEnv(e)))

}

//export ta_CRSI
func ta_CRSI(obj CGoHandle, period C.longlong, upDn C.longlong, roc C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_banta_Series(ta.CRSI(ptrFromHandle_Ptr_banta_Series(obj), int(period), int(upDn), int(roc)))

}

//export ta_HighestBar
func ta_HighestBar(obj CGoHandle, period C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_banta_Series(ta.HighestBar(ptrFromHandle_Ptr_banta_Series(obj), int(period)))

}

//export ta_Stoch
func ta_Stoch(high CGoHandle, low CGoHandle, close CGoHandle, period C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_banta_Series(ta.Stoch(ptrFromHandle_Ptr_banta_Series(high), ptrFromHandle_Ptr_banta_Series(low), ptrFromHandle_Ptr_banta_Series(close), int(period)))

}

// ---- Functions ---

//export ta_KDJBy
func ta_KDJBy(high CGoHandle, low CGoHandle, close CGoHandle, period C.longlong, sm1 C.longlong, sm2 C.longlong, maBy *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := ta.KDJBy(ptrFromHandle_Ptr_banta_Series(high), ptrFromHandle_Ptr_banta_Series(low), ptrFromHandle_Ptr_banta_Series(close), int(period), int(sm1), int(sm2), C.GoString(maBy))

	return handleFromPtr_Array_3_Ptr_banta_Series(&cret)
}

//export ta_WrapFloatArr
func ta_WrapFloatArr(res CGoHandle, period C.longlong, inVal C.double) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := ta.WrapFloatArr(ptrFromHandle_Ptr_banta_Series(res), int(period), float64(inVal))

	return handleFromPtr_Slice_float64(&cret)
}

//export ta_StochRSI
func ta_StochRSI(obj CGoHandle, rsiLen C.longlong, stochLen C.longlong, maK C.longlong, maD C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := ta.StochRSI(ptrFromHandle_Ptr_banta_Series(obj), int(rsiLen), int(stochLen), int(maK), int(maD))

	return handleFromPtr_Array_2_Ptr_banta_Series(&cret)
}

//export ta_Aroon
func ta_Aroon(high CGoHandle, low CGoHandle, period C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := ta.Aroon(ptrFromHandle_Ptr_banta_Series(high), ptrFromHandle_Ptr_banta_Series(low), int(period))

	return handleFromPtr_Array_3_Ptr_banta_Series(&cret)
}

//export ta_BBANDS
func ta_BBANDS(obj CGoHandle, period C.longlong, stdUp C.double, stdDn C.double) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := ta.BBANDS(ptrFromHandle_Ptr_banta_Series(obj), int(period), float64(stdUp), float64(stdDn))

	return handleFromPtr_Array_3_Ptr_banta_Series(&cret)
}

//export ta_MACD
func ta_MACD(obj CGoHandle, fast C.longlong, slow C.longlong, smooth C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := ta.MACD(ptrFromHandle_Ptr_banta_Series(obj), int(fast), int(slow), int(smooth))

	return handleFromPtr_Array_2_Ptr_banta_Series(&cret)
}

//export ta_HeikinAshi
func ta_HeikinAshi(e CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := ta.HeikinAshi(ptrFromHandle_Ptr_banta_BarEnv(e))

	return handleFromPtr_Array_4_Ptr_banta_Series(&cret)
}

//export ta_MACDBy
func ta_MACDBy(obj CGoHandle, fast C.longlong, slow C.longlong, smooth C.longlong, initType C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := ta.MACDBy(ptrFromHandle_Ptr_banta_Series(obj), int(fast), int(slow), int(smooth), int(initType))

	return handleFromPtr_Array_2_Ptr_banta_Series(&cret)
}

//export ta_KDJ
func ta_KDJ(high CGoHandle, low CGoHandle, close CGoHandle, period C.longlong, sm1 C.longlong, sm2 C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := ta.KDJ(ptrFromHandle_Ptr_banta_Series(high), ptrFromHandle_Ptr_banta_Series(low), ptrFromHandle_Ptr_banta_Series(close), int(period), int(sm1), int(sm2))

	return handleFromPtr_Array_3_Ptr_banta_Series(&cret)
}

//export ta_PluMinDM
func ta_PluMinDM(high CGoHandle, low CGoHandle, close CGoHandle, period C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := ta.PluMinDM(ptrFromHandle_Ptr_banta_Series(high), ptrFromHandle_Ptr_banta_Series(low), ptrFromHandle_Ptr_banta_Series(close), int(period))

	return handleFromPtr_Array_2_Ptr_banta_Series(&cret)
}

//export ta_StdDevBy
func ta_StdDevBy(obj CGoHandle, period C.longlong, ddof C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := ta.StdDevBy(ptrFromHandle_Ptr_banta_Series(obj), int(period), int(ddof))

	return handleFromPtr_Array_2_Ptr_banta_Series(&cret)
}

//export ta_PluMinDI
func ta_PluMinDI(high CGoHandle, low CGoHandle, close CGoHandle, period C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := ta.PluMinDI(ptrFromHandle_Ptr_banta_Series(high), ptrFromHandle_Ptr_banta_Series(low), ptrFromHandle_Ptr_banta_Series(close), int(period))

	return handleFromPtr_Array_2_Ptr_banta_Series(&cret)
}

// ---- Package: tav ---

// ---- Types ---

// Converters for pointer handles for type: *tav.TJson
func ptrFromHandle_Ptr_tav_TJson(h CGoHandle) *tav.TJson {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*tav.TJson")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(tav.TJson{})).(*tav.TJson)
}
func handleFromPtr_Ptr_tav_TJson(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*tav.TJson", p))
}

// Converters for implicit pointer handles for type: [2][]float64
func ptrFromHandle_Array_2_Slice_float64(h CGoHandle) *[2][]float64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[2][]float64")
	if p == nil {
		return nil
	}
	return p.(*[2][]float64)
}
func deptrFromHandle_Array_2_Slice_float64(h CGoHandle) [2][]float64 {
	p := ptrFromHandle_Array_2_Slice_float64(h)
	return *p
}
func handleFromPtr_Array_2_Slice_float64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[2][]float64", p))
}

// --- wrapping slice: [2][]float64 ---
//
//export Array_2_Slice_float64_CTor
func Array_2_Slice_float64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Array_2_Slice_float64(&[2][]float64{}))
}

//export Array_2_Slice_float64_len
func Array_2_Slice_float64_len(handle CGoHandle) int {
	return len(deptrFromHandle_Array_2_Slice_float64(handle))
}

//export Array_2_Slice_float64_elem
func Array_2_Slice_float64_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Array_2_Slice_float64(handle)
	return handleFromPtr_Slice_float64(&(s[_idx]))
}

//export Array_2_Slice_float64_set
func Array_2_Slice_float64_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Array_2_Slice_float64(handle)
	s[_idx] = deptrFromHandle_Slice_float64(_vl)
}

// Converters for implicit pointer handles for type: [3][]float64
func ptrFromHandle_Array_3_Slice_float64(h CGoHandle) *[3][]float64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[3][]float64")
	if p == nil {
		return nil
	}
	return p.(*[3][]float64)
}
func deptrFromHandle_Array_3_Slice_float64(h CGoHandle) [3][]float64 {
	p := ptrFromHandle_Array_3_Slice_float64(h)
	return *p
}
func handleFromPtr_Array_3_Slice_float64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[3][]float64", p))
}

// --- wrapping slice: [3][]float64 ---
//
//export Array_3_Slice_float64_CTor
func Array_3_Slice_float64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Array_3_Slice_float64(&[3][]float64{}))
}

//export Array_3_Slice_float64_len
func Array_3_Slice_float64_len(handle CGoHandle) int {
	return len(deptrFromHandle_Array_3_Slice_float64(handle))
}

//export Array_3_Slice_float64_elem
func Array_3_Slice_float64_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Array_3_Slice_float64(handle)
	return handleFromPtr_Slice_float64(&(s[_idx]))
}

//export Array_3_Slice_float64_set
func Array_3_Slice_float64_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Array_3_Slice_float64(handle)
	s[_idx] = deptrFromHandle_Slice_float64(_vl)
}

// Converters for implicit pointer handles for type: [4][]float64
func ptrFromHandle_Array_4_Slice_float64(h CGoHandle) *[4][]float64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[4][]float64")
	if p == nil {
		return nil
	}
	return p.(*[4][]float64)
}
func deptrFromHandle_Array_4_Slice_float64(h CGoHandle) [4][]float64 {
	p := ptrFromHandle_Array_4_Slice_float64(h)
	return *p
}
func handleFromPtr_Array_4_Slice_float64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[4][]float64", p))
}

// --- wrapping slice: [4][]float64 ---
//
//export Array_4_Slice_float64_CTor
func Array_4_Slice_float64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Array_4_Slice_float64(&[4][]float64{}))
}

//export Array_4_Slice_float64_len
func Array_4_Slice_float64_len(handle CGoHandle) int {
	return len(deptrFromHandle_Array_4_Slice_float64(handle))
}

//export Array_4_Slice_float64_elem
func Array_4_Slice_float64_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Array_4_Slice_float64(handle)
	return handleFromPtr_Slice_float64(&(s[_idx]))
}

//export Array_4_Slice_float64_set
func Array_4_Slice_float64_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Array_4_Slice_float64(handle)
	s[_idx] = deptrFromHandle_Slice_float64(_vl)
}

// Converters for non-pointer handles for type: tav.TJson
func ptrFromHandle_tav_TJson(h CGoHandle) *tav.TJson {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "tav.TJson")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(tav.TJson{})).(*tav.TJson)
}
func handleFromPtr_tav_TJson(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("tav.TJson", p))
}

// ---- Global Variables: can only use functions to access ---

// ---- Interfaces ---

// ---- Structs ---

// --- wrapping struct: tav.TJson ---
//
//export tav_TJson_CTor
func tav_TJson_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_tav_TJson(&tav.TJson{}))
}

//export tav_TJson_Name_Get
func tav_TJson_Name_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_tav_TJson(handle)
	return C.CString(op.Name)
}

//export tav_TJson_Name_Set
func tav_TJson_Name_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_tav_TJson(handle)
	op.Name = C.GoString(val)
}

// ---- Slices ---

// ---- Maps ---

// ---- Constructors ---

// ---- Functions ---

//export tav_TD
func tav_TD(data CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := tav.TD(deptrFromHandle_Slice_float64(data))

	return handleFromPtr_Slice_float64(&cret)
}

//export tav_ATR
func tav_ATR(high CGoHandle, low CGoHandle, close CGoHandle, period C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := tav.ATR(deptrFromHandle_Slice_float64(high), deptrFromHandle_Slice_float64(low), deptrFromHandle_Slice_float64(close), int(period))

	return handleFromPtr_Slice_float64(&cret)
}

//export tav_RMABy
func tav_RMABy(data CGoHandle, period C.longlong, initType C.longlong, initVal C.double) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := tav.RMABy(deptrFromHandle_Slice_float64(data), int(period), int(initType), float64(initVal))

	return handleFromPtr_Slice_float64(&cret)
}

//export tav_KAMABy
func tav_KAMABy(data CGoHandle, period C.longlong, fast C.longlong, slow C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := tav.KAMABy(deptrFromHandle_Slice_float64(data), int(period), int(fast), int(slow))

	return handleFromPtr_Slice_float64(&cret)
}

//export tav_PluMinDI
func tav_PluMinDI(high CGoHandle, low CGoHandle, close CGoHandle, period C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := tav.PluMinDI(deptrFromHandle_Slice_float64(high), deptrFromHandle_Slice_float64(low), deptrFromHandle_Slice_float64(close), int(period))

	return handleFromPtr_Array_2_Slice_float64(&cret)
}

//export tav_CMF
func tav_CMF(high CGoHandle, low CGoHandle, close CGoHandle, volume CGoHandle, period C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := tav.CMF(deptrFromHandle_Slice_float64(high), deptrFromHandle_Slice_float64(low), deptrFromHandle_Slice_float64(close), deptrFromHandle_Slice_float64(volume), int(period))

	return handleFromPtr_Slice_float64(&cret)
}

//export tav_EMA
func tav_EMA(data CGoHandle, period C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := tav.EMA(deptrFromHandle_Slice_float64(data), int(period))

	return handleFromPtr_Slice_float64(&cret)
}

//export tav_Lowest
func tav_Lowest(data CGoHandle, period C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := tav.Lowest(deptrFromHandle_Slice_float64(data), int(period))

	return handleFromPtr_Slice_float64(&cret)
}

//export tav_LowestBar
func tav_LowestBar(data CGoHandle, period C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := tav.LowestBar(deptrFromHandle_Slice_float64(data), int(period))

	return handleFromPtr_Slice_float64(&cret)
}

//export tav_MFI
func tav_MFI(high CGoHandle, low CGoHandle, close CGoHandle, volume CGoHandle, period C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := tav.MFI(deptrFromHandle_Slice_float64(high), deptrFromHandle_Slice_float64(low), deptrFromHandle_Slice_float64(close), deptrFromHandle_Slice_float64(volume), int(period))

	return handleFromPtr_Slice_float64(&cret)
}

//export tav_ALMA
func tav_ALMA(data CGoHandle, period C.longlong, sigma C.double, distOff C.double) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := tav.ALMA(deptrFromHandle_Slice_float64(data), int(period), float64(sigma), float64(distOff))

	return handleFromPtr_Slice_float64(&cret)
}

//export tav_HMA
func tav_HMA(data CGoHandle, period C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := tav.HMA(deptrFromHandle_Slice_float64(data), int(period))

	return handleFromPtr_Slice_float64(&cret)
}

//export tav_PercentRank
func tav_PercentRank(data CGoHandle, period C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := tav.PercentRank(deptrFromHandle_Slice_float64(data), int(period))

	return handleFromPtr_Slice_float64(&cret)
}

//export tav_RSI
func tav_RSI(data CGoHandle, period C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := tav.RSI(deptrFromHandle_Slice_float64(data), int(period))

	return handleFromPtr_Slice_float64(&cret)
}

//export tav_AvgDev
func tav_AvgDev(data CGoHandle, period C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := tav.AvgDev(deptrFromHandle_Slice_float64(data), int(period))

	return handleFromPtr_Slice_float64(&cret)
}

//export tav_LinRegAdv
func tav_LinRegAdv(data CGoHandle, period C.longlong, angle C.char, intercept C.char, degrees C.char, r C.char, slope C.char, tsf C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := tav.LinRegAdv(deptrFromHandle_Slice_float64(data), int(period), boolPyToGo(angle), boolPyToGo(intercept), boolPyToGo(degrees), boolPyToGo(r), boolPyToGo(slope), boolPyToGo(tsf))

	return handleFromPtr_Slice_float64(&cret)
}

//export tav_StdDev
func tav_StdDev(data CGoHandle, period C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := tav.StdDev(deptrFromHandle_Slice_float64(data), int(period))

	return handleFromPtr_Slice_float64(&cret)
}

//export tav_StdDevBy
func tav_StdDevBy(data CGoHandle, period C.longlong, ddof C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := tav.StdDevBy(deptrFromHandle_Slice_float64(data), int(period), int(ddof))

	return handleFromPtr_Array_2_Slice_float64(&cret)
}

//export tav_WMA
func tav_WMA(data CGoHandle, period C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := tav.WMA(deptrFromHandle_Slice_float64(data), int(period))

	return handleFromPtr_Slice_float64(&cret)
}

//export tav_CRSIBy
func tav_CRSIBy(data CGoHandle, period C.longlong, upDn C.longlong, rocVal C.longlong, vtype C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := tav.CRSIBy(deptrFromHandle_Slice_float64(data), int(period), int(upDn), int(rocVal), int(vtype))

	return handleFromPtr_Slice_float64(&cret)
}

//export tav_Stoch
func tav_Stoch(high CGoHandle, low CGoHandle, close CGoHandle, period C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := tav.Stoch(deptrFromHandle_Slice_float64(high), deptrFromHandle_Slice_float64(low), deptrFromHandle_Slice_float64(close), int(period))

	return handleFromPtr_Slice_float64(&cret)
}

//export tav_CMOBy
func tav_CMOBy(data CGoHandle, period C.longlong, maType C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := tav.CMOBy(deptrFromHandle_Slice_float64(data), int(period), int(maType))

	return handleFromPtr_Slice_float64(&cret)
}

//export tav_MACD
func tav_MACD(data CGoHandle, fast C.longlong, slow C.longlong, smooth C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := tav.MACD(deptrFromHandle_Slice_float64(data), int(fast), int(slow), int(smooth))

	return handleFromPtr_Array_2_Slice_float64(&cret)
}

//export tav_Stiffness
func tav_Stiffness(data CGoHandle, maLen C.longlong, stiffLen C.longlong, stiffMa C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := tav.Stiffness(deptrFromHandle_Slice_float64(data), int(maLen), int(stiffLen), int(stiffMa))

	return handleFromPtr_Slice_float64(&cret)
}

//export tav_UpDown
func tav_UpDown(data CGoHandle, vtype C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := tav.UpDown(deptrFromHandle_Slice_float64(data), int(vtype))

	return handleFromPtr_Slice_float64(&cret)
}

//export tav_ADX
func tav_ADX(high CGoHandle, low CGoHandle, close CGoHandle, period C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := tav.ADX(deptrFromHandle_Slice_float64(high), deptrFromHandle_Slice_float64(low), deptrFromHandle_Slice_float64(close), int(period))

	return handleFromPtr_Slice_float64(&cret)
}

//export tav_Aroon
func tav_Aroon(high CGoHandle, low CGoHandle, period C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := tav.Aroon(deptrFromHandle_Slice_float64(high), deptrFromHandle_Slice_float64(low), int(period))

	return handleFromPtr_Array_3_Slice_float64(&cret)
}

//export tav_RMI
func tav_RMI(data CGoHandle, period C.longlong, montLen C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := tav.RMI(deptrFromHandle_Slice_float64(data), int(period), int(montLen))

	return handleFromPtr_Slice_float64(&cret)
}

//export tav_ROC
func tav_ROC(data CGoHandle, period C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := tav.ROC(deptrFromHandle_Slice_float64(data), int(period))

	return handleFromPtr_Slice_float64(&cret)
}

//export tav_CMO
func tav_CMO(data CGoHandle, period C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := tav.CMO(deptrFromHandle_Slice_float64(data), int(period))

	return handleFromPtr_Slice_float64(&cret)
}

//export tav_HLC3
func tav_HLC3(a CGoHandle, b CGoHandle, c CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := tav.HLC3(deptrFromHandle_Slice_float64(a), deptrFromHandle_Slice_float64(b), deptrFromHandle_Slice_float64(c))

	return handleFromPtr_Slice_float64(&cret)
}

//export tav_TR
func tav_TR(high CGoHandle, low CGoHandle, close CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := tav.TR(deptrFromHandle_Slice_float64(high), deptrFromHandle_Slice_float64(low), deptrFromHandle_Slice_float64(close))

	return handleFromPtr_Slice_float64(&cret)
}

//export tav_BBANDS
func tav_BBANDS(data CGoHandle, period C.longlong, stdUp C.double, stdDn C.double) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := tav.BBANDS(deptrFromHandle_Slice_float64(data), int(period), float64(stdUp), float64(stdDn))

	return handleFromPtr_Array_3_Slice_float64(&cret)
}

//export tav_MACDBy
func tav_MACDBy(data CGoHandle, fast C.longlong, slow C.longlong, smooth C.longlong, initType C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := tav.MACDBy(deptrFromHandle_Slice_float64(data), int(fast), int(slow), int(smooth), int(initType))

	return handleFromPtr_Array_2_Slice_float64(&cret)
}

//export tav_HighestBar
func tav_HighestBar(data CGoHandle, period C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := tav.HighestBar(deptrFromHandle_Slice_float64(data), int(period))

	return handleFromPtr_Slice_float64(&cret)
}

//export tav_JsonExp
func tav_JsonExp(goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	if boolPyToGo(goRun) {
		go tav.JsonExp()
	} else {
		tav.JsonExp()
	}
}

//export tav_KDJBy
func tav_KDJBy(high CGoHandle, low CGoHandle, close CGoHandle, period C.longlong, sm1 C.longlong, sm2 C.longlong, maBy *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := tav.KDJBy(deptrFromHandle_Slice_float64(high), deptrFromHandle_Slice_float64(low), deptrFromHandle_Slice_float64(close), int(period), int(sm1), int(sm2), C.GoString(maBy))

	return handleFromPtr_Array_3_Slice_float64(&cret)
}

//export tav_PluMinDM
func tav_PluMinDM(high CGoHandle, low CGoHandle, cls CGoHandle, period C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := tav.PluMinDM(deptrFromHandle_Slice_float64(high), deptrFromHandle_Slice_float64(low), deptrFromHandle_Slice_float64(cls), int(period))

	return handleFromPtr_Array_2_Slice_float64(&cret)
}

//export tav_RSIBy
func tav_RSIBy(data CGoHandle, period C.longlong, subVal C.double) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := tav.RSIBy(deptrFromHandle_Slice_float64(data), int(period), float64(subVal))

	return handleFromPtr_Slice_float64(&cret)
}

//export tav_CCI
func tav_CCI(data CGoHandle, period C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := tav.CCI(deptrFromHandle_Slice_float64(data), int(period))

	return handleFromPtr_Slice_float64(&cret)
}

//export tav_EMABy
func tav_EMABy(data CGoHandle, period C.longlong, initType C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := tav.EMABy(deptrFromHandle_Slice_float64(data), int(period), int(initType))

	return handleFromPtr_Slice_float64(&cret)
}

//export tav_RMA
func tav_RMA(data CGoHandle, period C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := tav.RMA(deptrFromHandle_Slice_float64(data), int(period))

	return handleFromPtr_Slice_float64(&cret)
}

//export tav_STC
func tav_STC(data CGoHandle, period C.longlong, fast C.longlong, slow C.longlong, alpha C.double) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := tav.STC(deptrFromHandle_Slice_float64(data), int(period), int(fast), int(slow), float64(alpha))

	return handleFromPtr_Slice_float64(&cret)
}

//export tav_WillR
func tav_WillR(high CGoHandle, low CGoHandle, close CGoHandle, period C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := tav.WillR(deptrFromHandle_Slice_float64(high), deptrFromHandle_Slice_float64(low), deptrFromHandle_Slice_float64(close), int(period))

	return handleFromPtr_Slice_float64(&cret)
}

//export tav_ER
func tav_ER(data CGoHandle, period C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := tav.ER(deptrFromHandle_Slice_float64(data), int(period))

	return handleFromPtr_Slice_float64(&cret)
}

//export tav_LinReg
func tav_LinReg(data CGoHandle, period C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := tav.LinReg(deptrFromHandle_Slice_float64(data), int(period))

	return handleFromPtr_Slice_float64(&cret)
}

//export tav_CTI
func tav_CTI(data CGoHandle, period C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := tav.CTI(deptrFromHandle_Slice_float64(data), int(period))

	return handleFromPtr_Slice_float64(&cret)
}

//export tav_DV2
func tav_DV2(h CGoHandle, l CGoHandle, c CGoHandle, period C.longlong, maLen C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := tav.DV2(deptrFromHandle_Slice_float64(h), deptrFromHandle_Slice_float64(l), deptrFromHandle_Slice_float64(c), int(period), int(maLen))

	return handleFromPtr_Slice_float64(&cret)
}

//export tav_HeikinAshi
func tav_HeikinAshi(open CGoHandle, high CGoHandle, low CGoHandle, close CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := tav.HeikinAshi(deptrFromHandle_Slice_float64(open), deptrFromHandle_Slice_float64(high), deptrFromHandle_Slice_float64(low), deptrFromHandle_Slice_float64(close))

	return handleFromPtr_Array_4_Slice_float64(&cret)
}

//export tav_StochRSI
func tav_StochRSI(obj CGoHandle, rsiLen C.longlong, stochLen C.longlong, maK C.longlong, maD C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := tav.StochRSI(deptrFromHandle_Slice_float64(obj), int(rsiLen), int(stochLen), int(maK), int(maD))

	return handleFromPtr_Array_2_Slice_float64(&cret)
}

//export tav_ADXBy
func tav_ADXBy(high CGoHandle, low CGoHandle, close CGoHandle, period C.longlong, smoothing C.longlong, method C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := tav.ADXBy(deptrFromHandle_Slice_float64(high), deptrFromHandle_Slice_float64(low), deptrFromHandle_Slice_float64(close), int(period), int(smoothing), int(method))

	return handleFromPtr_Slice_float64(&cret)
}

//export tav_CHOP
func tav_CHOP(high CGoHandle, low CGoHandle, close CGoHandle, period C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := tav.CHOP(deptrFromHandle_Slice_float64(high), deptrFromHandle_Slice_float64(low), deptrFromHandle_Slice_float64(close), int(period))

	return handleFromPtr_Slice_float64(&cret)
}

//export tav_Cross
func tav_Cross(data1 CGoHandle, data2 CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := tav.Cross(deptrFromHandle_Slice_float64(data1), deptrFromHandle_Slice_float64(data2))

	return handleFromPtr_Slice_int(&cret)
}

//export tav_KDJ
func tav_KDJ(high CGoHandle, low CGoHandle, close CGoHandle, period C.longlong, sm1 C.longlong, sm2 C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := tav.KDJ(deptrFromHandle_Slice_float64(high), deptrFromHandle_Slice_float64(low), deptrFromHandle_Slice_float64(close), int(period), int(sm1), int(sm2))

	return handleFromPtr_Array_3_Slice_float64(&cret)
}

//export tav_SMA
func tav_SMA(data CGoHandle, period C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := tav.SMA(deptrFromHandle_Slice_float64(data), int(period))

	return handleFromPtr_Slice_float64(&cret)
}

//export tav_Sum
func tav_Sum(data CGoHandle, period C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := tav.Sum(deptrFromHandle_Slice_float64(data), int(period))

	return handleFromPtr_Slice_float64(&cret)
}

//export tav_UTBot
func tav_UTBot(c CGoHandle, atr CGoHandle, rate C.double) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := tav.UTBot(deptrFromHandle_Slice_float64(c), deptrFromHandle_Slice_float64(atr), float64(rate))

	return handleFromPtr_Slice_float64(&cret)
}

//export tav_VWMA
func tav_VWMA(price CGoHandle, volume CGoHandle, period C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := tav.VWMA(deptrFromHandle_Slice_float64(price), deptrFromHandle_Slice_float64(volume), int(period))

	return handleFromPtr_Slice_float64(&cret)
}

//export tav_CRSI
func tav_CRSI(data CGoHandle, period C.longlong, upDn C.longlong, rocVal C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := tav.CRSI(deptrFromHandle_Slice_float64(data), int(period), int(upDn), int(rocVal))

	return handleFromPtr_Slice_float64(&cret)
}

//export tav_HL2
func tav_HL2(a CGoHandle, b CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := tav.HL2(deptrFromHandle_Slice_float64(a), deptrFromHandle_Slice_float64(b))

	return handleFromPtr_Slice_float64(&cret)
}

//export tav_Highest
func tav_Highest(data CGoHandle, period C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := tav.Highest(deptrFromHandle_Slice_float64(data), int(period))

	return handleFromPtr_Slice_float64(&cret)
}

//export tav_KAMA
func tav_KAMA(data CGoHandle, period C.longlong) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	cret := tav.KAMA(deptrFromHandle_Slice_float64(data), int(period))

	return handleFromPtr_Slice_float64(&cret)
}
