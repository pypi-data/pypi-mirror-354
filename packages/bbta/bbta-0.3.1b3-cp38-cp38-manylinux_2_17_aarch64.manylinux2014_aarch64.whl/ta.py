
# python wrapper for package github.com/banbox/banta/python/ta within overall package bbta
# This is what you import to use the package.
# File is generated by gopy. Do not edit.
# gopy build -no-make -dynamic-link=True -output build/lib.linux-aarch64-cpython-38 -name bbta -vm /opt/python/cp38-cp38/bin/python -rename=true github.com/banbox/banta/python/ta github.com/banbox/banta/python/tav

# the following is required to enable dlopen to open the _go.so file
import os,sys,inspect,collections
try:
	import collections.abc as _collections_abc
except ImportError:
	_collections_abc = collections

cwd = os.getcwd()
currentdir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
os.chdir(currentdir)
from . import _bbta
from . import go

os.chdir(cwd)

# to use this code in your end-user python file, import it as follows:
# from bbta import ta
# and then refer to everything using ta. prefix
# packages imported by this package listed below:




# ---- Types ---

# Python type for slice [2]*banta.Series
class Array_2_Ptr_banta_Series(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_bbta.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_bbta.IncRef(self.handle)
	def __del__(self):
		_bbta.DecRef(self.handle)
	def __str__(self):
		s = 'ta.Array_2_Ptr_banta_Series len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'ta.Array_2_Ptr_banta_Series([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _bbta.Array_2_Ptr_banta_Series_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.Ptr_banta_Series(handle=_bbta.Array_2_Ptr_banta_Series_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_bbta.Array_2_Ptr_banta_Series_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.Ptr_banta_Series(handle=_bbta.Array_2_Ptr_banta_Series_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration

# Python type for slice [3]*banta.Series
class Array_3_Ptr_banta_Series(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_bbta.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_bbta.IncRef(self.handle)
	def __del__(self):
		_bbta.DecRef(self.handle)
	def __str__(self):
		s = 'ta.Array_3_Ptr_banta_Series len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'ta.Array_3_Ptr_banta_Series([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _bbta.Array_3_Ptr_banta_Series_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.Ptr_banta_Series(handle=_bbta.Array_3_Ptr_banta_Series_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_bbta.Array_3_Ptr_banta_Series_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.Ptr_banta_Series(handle=_bbta.Array_3_Ptr_banta_Series_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration

# Python type for slice [4]*banta.Series
class Array_4_Ptr_banta_Series(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_bbta.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_bbta.IncRef(self.handle)
	def __del__(self):
		_bbta.DecRef(self.handle)
	def __str__(self):
		s = 'ta.Array_4_Ptr_banta_Series len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'ta.Array_4_Ptr_banta_Series([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _bbta.Array_4_Ptr_banta_Series_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.Ptr_banta_Series(handle=_bbta.Array_4_Ptr_banta_Series_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_bbta.Array_4_Ptr_banta_Series_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.Ptr_banta_Series(handle=_bbta.Array_4_Ptr_banta_Series_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration

# Python type for slice []*banta.Series
class Slice_Ptr_banta_Series(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_bbta.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_bbta.IncRef(self.handle)
		else:
			self.handle = _bbta.Slice_Ptr_banta_Series_CTor()
			_bbta.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_Ptr_banta_Series.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_bbta.DecRef(self.handle)
	def __str__(self):
		s = 'ta.Slice_Ptr_banta_Series len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'ta.Slice_Ptr_banta_Series([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _bbta.Slice_Ptr_banta_Series_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _bbta.Slice_Ptr_banta_Series_len(self.handle)
				return Slice_Ptr_banta_Series(handle=_bbta.Slice_Ptr_banta_Series_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.Ptr_banta_Series(handle=_bbta.Slice_Ptr_banta_Series_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_bbta.Slice_Ptr_banta_Series_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_Ptr_banta_Series.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.Ptr_banta_Series(handle=_bbta.Slice_Ptr_banta_Series_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_bbta.Slice_Ptr_banta_Series_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []*banta.XState
class Slice_Ptr_banta_XState(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_bbta.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_bbta.IncRef(self.handle)
		else:
			self.handle = _bbta.Slice_Ptr_banta_XState_CTor()
			_bbta.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_Ptr_banta_XState.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_bbta.DecRef(self.handle)
	def __str__(self):
		s = 'ta.Slice_Ptr_banta_XState len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'ta.Slice_Ptr_banta_XState([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _bbta.Slice_Ptr_banta_XState_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _bbta.Slice_Ptr_banta_XState_len(self.handle)
				return Slice_Ptr_banta_XState(handle=_bbta.Slice_Ptr_banta_XState_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return go.Ptr_banta_XState(handle=_bbta.Slice_Ptr_banta_XState_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_bbta.Slice_Ptr_banta_XState_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_Ptr_banta_XState.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = go.Ptr_banta_XState(handle=_bbta.Slice_Ptr_banta_XState_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_bbta.Slice_Ptr_banta_XState_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for map map[int]*banta.CrossLog
class Map_int_Ptr_banta_CrossLog(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_bbta.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_bbta.IncRef(self.handle)
		else:
			self.handle = _bbta.Map_int_Ptr_banta_CrossLog_CTor()
			_bbta.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_int_Ptr_banta_CrossLog.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_bbta.Map_int_Ptr_banta_CrossLog_set(self.handle, k, v)
	def __del__(self):
		_bbta.DecRef(self.handle)
	def __str__(self):
		s = 'bbta.Map_int_Ptr_banta_CrossLog len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'bbta.Map_int_Ptr_banta_CrossLog({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _bbta.Map_int_Ptr_banta_CrossLog_len(self.handle)
	def __getitem__(self, key):
		return go.Ptr_banta_CrossLog(handle=_bbta.Map_int_Ptr_banta_CrossLog_elem(self.handle, key))
	def __setitem__(self, key, value):
		_bbta.Map_int_Ptr_banta_CrossLog_set(self.handle, key, value.handle)
	def __delitem__(self, key):
		return _bbta.Map_int_Ptr_banta_CrossLog_delete(self.handle, key)
	def keys(self):
		return go.Slice_int(handle=_bbta.Map_int_Ptr_banta_CrossLog_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _bbta.Map_int_Ptr_banta_CrossLog_contains(self.handle, key)

# Python type for map map[int]*banta.Series
class Map_int_Ptr_banta_Series(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_bbta.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_bbta.IncRef(self.handle)
		else:
			self.handle = _bbta.Map_int_Ptr_banta_Series_CTor()
			_bbta.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_int_Ptr_banta_Series.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_bbta.Map_int_Ptr_banta_Series_set(self.handle, k, v)
	def __del__(self):
		_bbta.DecRef(self.handle)
	def __str__(self):
		s = 'bbta.Map_int_Ptr_banta_Series len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'bbta.Map_int_Ptr_banta_Series({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _bbta.Map_int_Ptr_banta_Series_len(self.handle)
	def __getitem__(self, key):
		return go.Ptr_banta_Series(handle=_bbta.Map_int_Ptr_banta_Series_elem(self.handle, key))
	def __setitem__(self, key, value):
		_bbta.Map_int_Ptr_banta_Series_set(self.handle, key, value.handle)
	def __delitem__(self, key):
		return _bbta.Map_int_Ptr_banta_Series_delete(self.handle, key)
	def keys(self):
		return go.Slice_int(handle=_bbta.Map_int_Ptr_banta_Series_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _bbta.Map_int_Ptr_banta_Series_contains(self.handle, key)

# Python type for map map[string]interface{}
class Map_string_interface_(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_bbta.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_bbta.IncRef(self.handle)
		else:
			self.handle = _bbta.Map_string_interface__CTor()
			_bbta.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_string_interface_.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_bbta.Map_string_interface__set(self.handle, k, v)
	def __del__(self):
		_bbta.DecRef(self.handle)
	def __str__(self):
		s = 'bbta.Map_string_interface_ len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'bbta.Map_string_interface_({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _bbta.Map_string_interface__len(self.handle)
	def __getitem__(self, key):
		return _bbta.Map_string_interface__elem(self.handle, key)
	def __setitem__(self, key, value):
		_bbta.Map_string_interface__set(self.handle, key, value)
	def __delitem__(self, key):
		return _bbta.Map_string_interface__delete(self.handle, key)
	def keys(self):
		return go.Slice_string(handle=_bbta.Map_string_interface__keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _bbta.Map_string_interface__contains(self.handle, key)

# Python type for map map[string]map[int]*banta.Series
class Map_string_Map_int_Ptr_banta_Series(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_bbta.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_bbta.IncRef(self.handle)
		else:
			self.handle = _bbta.Map_string_Map_int_Ptr_banta_Series_CTor()
			_bbta.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Mapping):
					raise TypeError('Map_string_Map_int_Ptr_banta_Series.__init__ takes a mapping as argument')
				for k, v in args[0].items():
					_bbta.Map_string_Map_int_Ptr_banta_Series_set(self.handle, k, v)
	def __del__(self):
		_bbta.DecRef(self.handle)
	def __str__(self):
		s = 'bbta.Map_string_Map_int_Ptr_banta_Series len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' {'
		if len(self) < 120:
			for k, v in self.items():
				s += str(k) + '=' + str(v) + ', '
		return s + '}'
	def __repr__(self):
		s = 'bbta.Map_string_Map_int_Ptr_banta_Series({'
		for k, v in self.items():
			s += str(k) + '=' + str(v) + ', '
		return s + '})'
	def __len__(self):
		return _bbta.Map_string_Map_int_Ptr_banta_Series_len(self.handle)
	def __getitem__(self, key):
		return Map_int_Ptr_banta_Series(handle=_bbta.Map_string_Map_int_Ptr_banta_Series_elem(self.handle, key))
	def __setitem__(self, key, value):
		_bbta.Map_string_Map_int_Ptr_banta_Series_set(self.handle, key, value.handle)
	def __delitem__(self, key):
		return _bbta.Map_string_Map_int_Ptr_banta_Series_delete(self.handle, key)
	def keys(self):
		return go.Slice_string(handle=_bbta.Map_string_Map_int_Ptr_banta_Series_keys(self.handle))
	def values(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append(self[k])
		return vls
	def items(self):
		vls = []
		kys = self.keys()
		for k in kys:
			vls.append((k, self[k]))
		return vls
	def __iter__(self):
		return iter(self.items())
	def __contains__(self, key):
		return _bbta.Map_string_Map_int_Ptr_banta_Series_contains(self.handle, key)


#---- Enums from Go (collections of consts with same type) ---


#---- Constants from Go: Python can only ask that you please don't change these! ---


# ---- Global Variables: can only use functions to access ---


# ---- Interfaces ---


# ---- Structs ---

# Python type for struct banta.BarEnv
class BarEnv(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_bbta.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_bbta.IncRef(self.handle)
		else:
			self.handle = _bbta.banta_BarEnv_CTor()
			_bbta.IncRef(self.handle)
			if  0 < len(args):
				self.TimeStart = args[0]
			if "TimeStart" in kwargs:
				self.TimeStart = kwargs["TimeStart"]
			if  1 < len(args):
				self.TimeStop = args[1]
			if "TimeStop" in kwargs:
				self.TimeStop = kwargs["TimeStop"]
			if  2 < len(args):
				self.Exchange = args[2]
			if "Exchange" in kwargs:
				self.Exchange = kwargs["Exchange"]
			if  3 < len(args):
				self.MarketType = args[3]
			if "MarketType" in kwargs:
				self.MarketType = kwargs["MarketType"]
			if  4 < len(args):
				self.Symbol = args[4]
			if "Symbol" in kwargs:
				self.Symbol = kwargs["Symbol"]
			if  5 < len(args):
				self.TimeFrame = args[5]
			if "TimeFrame" in kwargs:
				self.TimeFrame = kwargs["TimeFrame"]
			if  6 < len(args):
				self.TFMSecs = args[6]
			if "TFMSecs" in kwargs:
				self.TFMSecs = kwargs["TFMSecs"]
			if  7 < len(args):
				self.BarNum = args[7]
			if "BarNum" in kwargs:
				self.BarNum = kwargs["BarNum"]
			if  8 < len(args):
				self.MaxCache = args[8]
			if "MaxCache" in kwargs:
				self.MaxCache = kwargs["MaxCache"]
			if  9 < len(args):
				self.VNum = args[9]
			if "VNum" in kwargs:
				self.VNum = kwargs["VNum"]
			if  10 < len(args):
				self.Open = args[10]
			if "Open" in kwargs:
				self.Open = kwargs["Open"]
			if  11 < len(args):
				self.High = args[11]
			if "High" in kwargs:
				self.High = kwargs["High"]
			if  12 < len(args):
				self.Low = args[12]
			if "Low" in kwargs:
				self.Low = kwargs["Low"]
			if  13 < len(args):
				self.Close = args[13]
			if "Close" in kwargs:
				self.Close = kwargs["Close"]
			if  14 < len(args):
				self.Volume = args[14]
			if "Volume" in kwargs:
				self.Volume = kwargs["Volume"]
			if  15 < len(args):
				self.Info = args[15]
			if "Info" in kwargs:
				self.Info = kwargs["Info"]
			if  16 < len(args):
				self.Data = args[16]
			if "Data" in kwargs:
				self.Data = kwargs["Data"]
	def __del__(self):
		_bbta.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'banta.BarEnv{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'banta.BarEnv ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def time_start(self):
		return _bbta.banta_BarEnv_TimeStart_Get(self.handle)
	@time_start.setter
	def time_start(self, value):
		if isinstance(value, go.GoClass):
			_bbta.banta_BarEnv_TimeStart_Set(self.handle, value.handle)
		else:
			_bbta.banta_BarEnv_TimeStart_Set(self.handle, value)
	@property
	def time_stop(self):
		return _bbta.banta_BarEnv_TimeStop_Get(self.handle)
	@time_stop.setter
	def time_stop(self, value):
		if isinstance(value, go.GoClass):
			_bbta.banta_BarEnv_TimeStop_Set(self.handle, value.handle)
		else:
			_bbta.banta_BarEnv_TimeStop_Set(self.handle, value)
	@property
	def exchange(self):
		return _bbta.banta_BarEnv_Exchange_Get(self.handle)
	@exchange.setter
	def exchange(self, value):
		if isinstance(value, go.GoClass):
			_bbta.banta_BarEnv_Exchange_Set(self.handle, value.handle)
		else:
			_bbta.banta_BarEnv_Exchange_Set(self.handle, value)
	@property
	def market_type(self):
		return _bbta.banta_BarEnv_MarketType_Get(self.handle)
	@market_type.setter
	def market_type(self, value):
		if isinstance(value, go.GoClass):
			_bbta.banta_BarEnv_MarketType_Set(self.handle, value.handle)
		else:
			_bbta.banta_BarEnv_MarketType_Set(self.handle, value)
	@property
	def symbol(self):
		return _bbta.banta_BarEnv_Symbol_Get(self.handle)
	@symbol.setter
	def symbol(self, value):
		if isinstance(value, go.GoClass):
			_bbta.banta_BarEnv_Symbol_Set(self.handle, value.handle)
		else:
			_bbta.banta_BarEnv_Symbol_Set(self.handle, value)
	@property
	def time_frame(self):
		return _bbta.banta_BarEnv_TimeFrame_Get(self.handle)
	@time_frame.setter
	def time_frame(self, value):
		if isinstance(value, go.GoClass):
			_bbta.banta_BarEnv_TimeFrame_Set(self.handle, value.handle)
		else:
			_bbta.banta_BarEnv_TimeFrame_Set(self.handle, value)
	@property
	def tfm_secs(self):
		return _bbta.banta_BarEnv_TFMSecs_Get(self.handle)
	@tfm_secs.setter
	def tfm_secs(self, value):
		if isinstance(value, go.GoClass):
			_bbta.banta_BarEnv_TFMSecs_Set(self.handle, value.handle)
		else:
			_bbta.banta_BarEnv_TFMSecs_Set(self.handle, value)
	@property
	def bar_num(self):
		return _bbta.banta_BarEnv_BarNum_Get(self.handle)
	@bar_num.setter
	def bar_num(self, value):
		if isinstance(value, go.GoClass):
			_bbta.banta_BarEnv_BarNum_Set(self.handle, value.handle)
		else:
			_bbta.banta_BarEnv_BarNum_Set(self.handle, value)
	@property
	def max_cache(self):
		return _bbta.banta_BarEnv_MaxCache_Get(self.handle)
	@max_cache.setter
	def max_cache(self, value):
		if isinstance(value, go.GoClass):
			_bbta.banta_BarEnv_MaxCache_Set(self.handle, value.handle)
		else:
			_bbta.banta_BarEnv_MaxCache_Set(self.handle, value)
	@property
	def v_num(self):
		return _bbta.banta_BarEnv_VNum_Get(self.handle)
	@v_num.setter
	def v_num(self, value):
		if isinstance(value, go.GoClass):
			_bbta.banta_BarEnv_VNum_Set(self.handle, value.handle)
		else:
			_bbta.banta_BarEnv_VNum_Set(self.handle, value)
	@property
	def open(self):
		return go.Ptr_banta_Series(handle=_bbta.banta_BarEnv_Open_Get(self.handle))
	@open.setter
	def open(self, value):
		if isinstance(value, go.GoClass):
			_bbta.banta_BarEnv_Open_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def high(self):
		return go.Ptr_banta_Series(handle=_bbta.banta_BarEnv_High_Get(self.handle))
	@high.setter
	def high(self, value):
		if isinstance(value, go.GoClass):
			_bbta.banta_BarEnv_High_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def low(self):
		return go.Ptr_banta_Series(handle=_bbta.banta_BarEnv_Low_Get(self.handle))
	@low.setter
	def low(self, value):
		if isinstance(value, go.GoClass):
			_bbta.banta_BarEnv_Low_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def close(self):
		return go.Ptr_banta_Series(handle=_bbta.banta_BarEnv_Close_Get(self.handle))
	@close.setter
	def close(self, value):
		if isinstance(value, go.GoClass):
			_bbta.banta_BarEnv_Close_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def volume(self):
		return go.Ptr_banta_Series(handle=_bbta.banta_BarEnv_Volume_Get(self.handle))
	@volume.setter
	def volume(self, value):
		if isinstance(value, go.GoClass):
			_bbta.banta_BarEnv_Volume_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def info(self):
		return go.Ptr_banta_Series(handle=_bbta.banta_BarEnv_Info_Get(self.handle))
	@info.setter
	def info(self, value):
		if isinstance(value, go.GoClass):
			_bbta.banta_BarEnv_Info_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def data(self):
		return Map_string_interface_(handle=_bbta.banta_BarEnv_Data_Get(self.handle))
	@data.setter
	def data(self, value):
		if isinstance(value, go.GoClass):
			_bbta.banta_BarEnv_Data_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def on_bar(self, barMs, open, high, low, close, volume, info):
		"""OnBar(long barMs, float open, float high, float low, float close, float volume, float info) str"""
		return _bbta.banta_BarEnv_OnBar(self.handle, barMs, open, high, low, close, volume, info)
	def reset(self, goRun=False):
		"""Reset() """
		_bbta.banta_BarEnv_Reset(self.handle, goRun)
	def trim_overflow(self, goRun=False):
		"""TrimOverflow() """
		_bbta.banta_BarEnv_TrimOverflow(self.handle, goRun)
	def new_series(self, data):
		"""NewSeries([]float data) object"""
		return go.Ptr_banta_Series(handle=_bbta.banta_BarEnv_NewSeries(self.handle, data.handle))
	def bar_count(self, start):
		"""BarCount(long start) float"""
		return _bbta.banta_BarEnv_BarCount(self.handle, start)

# Python type for struct banta.Series
class Series(go.GoClass):
	"""为方便起见，定义类型别名，以便我们可以使用与原始包中相同的类型名称。\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_bbta.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_bbta.IncRef(self.handle)
		else:
			self.handle = _bbta.banta_Series_CTor()
			_bbta.IncRef(self.handle)
			if  0 < len(args):
				self.ID = args[0]
			if "ID" in kwargs:
				self.ID = kwargs["ID"]
			if  1 < len(args):
				self.Env = args[1]
			if "Env" in kwargs:
				self.Env = kwargs["Env"]
			if  2 < len(args):
				self.Data = args[2]
			if "Data" in kwargs:
				self.Data = kwargs["Data"]
			if  3 < len(args):
				self.Cols = args[3]
			if "Cols" in kwargs:
				self.Cols = kwargs["Cols"]
			if  4 < len(args):
				self.Time = args[4]
			if "Time" in kwargs:
				self.Time = kwargs["Time"]
			if  6 < len(args):
				self.Subs = args[6]
			if "Subs" in kwargs:
				self.Subs = kwargs["Subs"]
			if  7 < len(args):
				self.XLogs = args[7]
			if "XLogs" in kwargs:
				self.XLogs = kwargs["XLogs"]
	def __del__(self):
		_bbta.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'banta.Series{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'banta.Series ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def id(self):
		return _bbta.banta_Series_ID_Get(self.handle)
	@id.setter
	def id(self, value):
		if isinstance(value, go.GoClass):
			_bbta.banta_Series_ID_Set(self.handle, value.handle)
		else:
			_bbta.banta_Series_ID_Set(self.handle, value)
	@property
	def env(self):
		return go.Ptr_banta_BarEnv(handle=_bbta.banta_Series_Env_Get(self.handle))
	@env.setter
	def env(self, value):
		if isinstance(value, go.GoClass):
			_bbta.banta_Series_Env_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def data(self):
		return go.Slice_float64(handle=_bbta.banta_Series_Data_Get(self.handle))
	@data.setter
	def data(self, value):
		if isinstance(value, go.GoClass):
			_bbta.banta_Series_Data_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def cols(self):
		return Slice_Ptr_banta_Series(handle=_bbta.banta_Series_Cols_Get(self.handle))
	@cols.setter
	def cols(self, value):
		if isinstance(value, go.GoClass):
			_bbta.banta_Series_Cols_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def time(self):
		return _bbta.banta_Series_Time_Get(self.handle)
	@time.setter
	def time(self, value):
		if isinstance(value, go.GoClass):
			_bbta.banta_Series_Time_Set(self.handle, value.handle)
		else:
			_bbta.banta_Series_Time_Set(self.handle, value)
	@property
	def subs(self):
		return Map_string_Map_int_Ptr_banta_Series(handle=_bbta.banta_Series_Subs_Get(self.handle))
	@subs.setter
	def subs(self, value):
		if isinstance(value, go.GoClass):
			_bbta.banta_Series_Subs_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def x_logs(self):
		return Map_int_Ptr_banta_CrossLog(handle=_bbta.banta_Series_XLogs_Get(self.handle))
	@x_logs.setter
	def x_logs(self, value):
		if isinstance(value, go.GoClass):
			_bbta.banta_Series_XLogs_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	def set(self, obj):
		"""Set(str obj) object"""
		return go.Ptr_banta_Series(handle=_bbta.banta_Series_Set(self.handle, obj))
	def append(self, obj):
		"""Append(str obj) object"""
		return go.Ptr_banta_Series(handle=_bbta.banta_Series_Append(self.handle, obj))
	def cached(self):
		"""Cached() bool"""
		return _bbta.banta_Series_Cached(self.handle)
	def get(self, i):
		"""Get(int i) float"""
		return _bbta.banta_Series_Get(self.handle, i)
	def range(self, start, stop):
		"""Range(int start, int stop) []float"""
		return go.Slice_float64(handle=_bbta.banta_Series_Range(self.handle, start, stop))
	def add(self, obj):
		"""Add(str obj) object"""
		return go.Ptr_banta_Series(handle=_bbta.banta_Series_Add(self.handle, obj))
	def sub(self, obj):
		"""Sub(str obj) object"""
		return go.Ptr_banta_Series(handle=_bbta.banta_Series_Sub(self.handle, obj))
	def mul(self, obj):
		"""Mul(str obj) object"""
		return go.Ptr_banta_Series(handle=_bbta.banta_Series_Mul(self.handle, obj))
	def div(self, obj):
		"""Div(str obj) object"""
		return go.Ptr_banta_Series(handle=_bbta.banta_Series_Div(self.handle, obj))
	def min(self, obj):
		"""Min(str obj) object"""
		return go.Ptr_banta_Series(handle=_bbta.banta_Series_Min(self.handle, obj))
	def max(self, obj):
		"""Max(str obj) object"""
		return go.Ptr_banta_Series(handle=_bbta.banta_Series_Max(self.handle, obj))
	def abs(self):
		"""Abs() object"""
		return go.Ptr_banta_Series(handle=_bbta.banta_Series_Abs(self.handle))
	def len(self):
		"""Len() int"""
		return _bbta.banta_Series_Len(self.handle)
	def cut(self, keepNum, goRun=False):
		"""Cut(int keepNum) """
		_bbta.banta_Series_Cut(self.handle, keepNum, goRun)
	def back(self, num):
		"""Back(int num) object"""
		return go.Ptr_banta_Series(handle=_bbta.banta_Series_Back(self.handle, num))
	def to(self, k, v):
		"""To(str k, int v) object"""
		return go.Ptr_banta_Series(handle=_bbta.banta_Series_To(self.handle, k, v))


# ---- Slices ---


# ---- Maps ---


# ---- Constructors ---
def avg_price(e):
	"""AvgPrice(object e) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_AvgPrice(e.handle))
def crsi_by(obj, period, upDn, roc, vtype):
	"""CRSIBy(object obj, int period, int upDn, int roc, int vtype) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_CRSIBy(obj.handle, period, upDn, roc, vtype))
def highest(obj, period):
	"""Highest(object obj, int period) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_Highest(obj.handle, period))
def adl(env):
	"""ADL(object env) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_ADL(env.handle))
def chaikin_osc(env, sml, big):
	"""ChaikinOsc(object env, int sml, int big) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_ChaikinOsc(env.handle, sml, big))
def hlc3(h, l, c):
	"""HLC3(object h, object l, object c) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_HLC3(h.handle, l.handle, c.handle))
def lin_reg(obj, period):
	"""LinReg(object obj, int period) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_LinReg(obj.handle, period))
def percent_rank(obj, period):
	"""PercentRank(object obj, int period) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_PercentRank(obj.handle, period))
def ut_bot(c, atr, rate):
	"""UTBot(object c, object atr, float rate) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_UTBot(c.handle, atr.handle, rate))
def std_dev(obj, period):
	"""StdDev(object obj, int period) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_StdDev(obj.handle, period))
def td(obj):
	"""TD(object obj) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_TD(obj.handle))
def rsi(obj, period):
	"""RSI(object obj, int period) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_RSI(obj.handle, period))
def sma(obj, period):
	"""SMA(object obj, int period) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_SMA(obj.handle, period))
def lin_reg_adv(obj, period, angle, intercept, degrees, r, slope, tsf):
	"""LinRegAdv(object obj, int period, bool angle, bool intercept, bool degrees, bool r, bool slope, bool tsf) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_LinRegAdv(obj.handle, period, angle, intercept, degrees, r, slope, tsf))
def lowest(obj, period):
	"""Lowest(object obj, int period) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_Lowest(obj.handle, period))
def vwma(price, vol, period):
	"""VWMA(object price, object vol, int period) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_VWMA(price.handle, vol.handle, period))
def chop(e, period):
	"""CHOP(object e, int period) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_CHOP(e.handle, period))
def kama(obj, period):
	"""KAMA(object obj, int period) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_KAMA(obj.handle, period))
def mfi(e, period):
	"""MFI(object e, int period) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_MFI(e.handle, period))
def stiffness(obj, maLen, stiffLen, stiffMa):
	"""Stiffness(object obj, int maLen, int stiffLen, int stiffMa) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_Stiffness(obj.handle, maLen, stiffLen, stiffMa))
def wma(obj, period):
	"""WMA(object obj, int period) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_WMA(obj.handle, period))
def cmf(env, period):
	"""CMF(object env, int period) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_CMF(env.handle, period))
def er(obj, period):
	"""ER(object obj, int period) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_ER(obj.handle, period))
def will_r(e, period):
	"""WillR(object e, int period) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_WillR(e.handle, period))
def avg_dev(obj, period):
	"""AvgDev(object obj, int period) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_AvgDev(obj.handle, period))
def cmo_by(obj, period, maType):
	"""CMOBy(object obj, int period, int maType) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_CMOBy(obj.handle, period, maType))
def ema(obj, period):
	"""EMA(object obj, int period) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_EMA(obj.handle, period))
def rma(obj, period):
	"""RMA(object obj, int period) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_RMA(obj.handle, period))
def alma(obj, period, sigma, distOff):
	"""ALMA(object obj, int period, float sigma, float distOff) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_ALMA(obj.handle, period, sigma, distOff))
def stc(obj, period, fast, slow, alpha):
	"""STC(object obj, int period, int fast, int slow, float alpha) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_STC(obj.handle, period, fast, slow, alpha))
def adx_by(high, low, close, period, smoothing, method):
	"""ADXBy(object high, object low, object close, int period, int smoothing, int method) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_ADXBy(high.handle, low.handle, close.handle, period, smoothing, method))
def crsi(obj, period, upDn, roc):
	"""CRSI(object obj, int period, int upDn, int roc) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_CRSI(obj.handle, period, upDn, roc))
def dv2(h, l, c, period, maLen):
	"""DV2(object h, object l, object c, int period, int maLen) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_DV2(h.handle, l.handle, c.handle, period, maLen))
def roc(obj, period):
	"""ROC(object obj, int period) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_ROC(obj.handle, period))
def atr(high, low, close, period):
	"""ATR(object high, object low, object close, int period) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_ATR(high.handle, low.handle, close.handle, period))
def cmo(obj, period):
	"""CMO(object obj, int period) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_CMO(obj.handle, period))
def hl2(h, l):
	"""HL2(object h, object l) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_HL2(h.handle, l.handle))
def kama_by(obj, period, fast, slow):
	"""KAMABy(object obj, int period, int fast, int slow) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_KAMABy(obj.handle, period, fast, slow))
def rmi(obj, period, montLen):
	"""RMI(object obj, int period, int montLen) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_RMI(obj.handle, period, montLen))
def rsi50(obj, period):
	"""RSI50(object obj, int period) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_RSI50(obj.handle, period))
def adx(high, low, close, period):
	"""ADX(object high, object low, object close, int period) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_ADX(high.handle, low.handle, close.handle, period))
def cti(obj, period):
	"""CTI(object obj, int period) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_CTI(obj.handle, period))
def ema_by(obj, period, initType):
	"""EMABy(object obj, int period, int initType) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_EMABy(obj.handle, period, initType))
def hma(obj, period):
	"""HMA(object obj, int period) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_HMA(obj.handle, period))
def up_down(obj, vtype):
	"""UpDown(object obj, int vtype) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_UpDown(obj.handle, vtype))
def highest_bar(obj, period):
	"""HighestBar(object obj, int period) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_HighestBar(obj.handle, period))
def lowest_bar(obj, period):
	"""LowestBar(object obj, int period) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_LowestBar(obj.handle, period))
def cci(obj, period):
	"""CCI(object obj, int period) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_CCI(obj.handle, period))
def rma_by(obj, period, initType, initVal):
	"""RMABy(object obj, int period, int initType, float initVal) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_RMABy(obj.handle, period, initType, initVal))
def stoch(high, low, close, period):
	"""Stoch(object high, object low, object close, int period) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_Stoch(high.handle, low.handle, close.handle, period))
def sum(obj, period):
	"""Sum(object obj, int period) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_Sum(obj.handle, period))
def tr(high, low, close):
	"""TR(object high, object low, object close) object"""
	return go.Ptr_banta_Series(handle=_bbta.ta_TR(high.handle, low.handle, close.handle))


# ---- Functions ---
def macd(obj, fast, slow, smooth):
	"""MACD(object obj, int fast, int slow, int smooth) []object"""
	return Array_2_Ptr_banta_Series(handle=_bbta.ta_MACD(obj.handle, fast, slow, smooth))
def stoch_rsi(obj, rsiLen, stochLen, maK, maD):
	"""StochRSI(object obj, int rsiLen, int stochLen, int maK, int maD) []object"""
	return Array_2_Ptr_banta_Series(handle=_bbta.ta_StochRSI(obj.handle, rsiLen, stochLen, maK, maD))
def kdj(high, low, close, period, sm1, sm2):
	"""KDJ(object high, object low, object close, int period, int sm1, int sm2) []object"""
	return Array_3_Ptr_banta_Series(handle=_bbta.ta_KDJ(high.handle, low.handle, close.handle, period, sm1, sm2))
def plu_min_dm(high, low, close, period):
	"""PluMinDM(object high, object low, object close, int period) []object"""
	return Array_2_Ptr_banta_Series(handle=_bbta.ta_PluMinDM(high.handle, low.handle, close.handle, period))
def aroon(high, low, period):
	"""Aroon(object high, object low, int period) []object"""
	return Array_3_Ptr_banta_Series(handle=_bbta.ta_Aroon(high.handle, low.handle, period))
def kdj_by(high, low, close, period, sm1, sm2, maBy):
	"""KDJBy(object high, object low, object close, int period, int sm1, int sm2, str maBy) []object"""
	return Array_3_Ptr_banta_Series(handle=_bbta.ta_KDJBy(high.handle, low.handle, close.handle, period, sm1, sm2, maBy))
def std_dev_by(obj, period, ddof):
	"""StdDevBy(object obj, int period, int ddof) []object"""
	return Array_2_Ptr_banta_Series(handle=_bbta.ta_StdDevBy(obj.handle, period, ddof))
def heikin_ashi(e):
	"""HeikinAshi(object e) []object"""
	return Array_4_Ptr_banta_Series(handle=_bbta.ta_HeikinAshi(e.handle))
def wrap_float_arr(res, period, inVal):
	"""WrapFloatArr(object res, int period, float inVal) []float"""
	return go.Slice_float64(handle=_bbta.ta_WrapFloatArr(res.handle, period, inVal))
def bbands(obj, period, stdUp, stdDn):
	"""BBANDS(object obj, int period, float stdUp, float stdDn) []object"""
	return Array_3_Ptr_banta_Series(handle=_bbta.ta_BBANDS(obj.handle, period, stdUp, stdDn))
def macd_by(obj, fast, slow, smooth, initType):
	"""MACDBy(object obj, int fast, int slow, int smooth, int initType) []object"""
	return Array_2_Ptr_banta_Series(handle=_bbta.ta_MACDBy(obj.handle, fast, slow, smooth, initType))
def plu_min_di(high, low, close, period):
	"""PluMinDI(object high, object low, object close, int period) []object"""
	return Array_2_Ptr_banta_Series(handle=_bbta.ta_PluMinDI(high.handle, low.handle, close.handle, period))


