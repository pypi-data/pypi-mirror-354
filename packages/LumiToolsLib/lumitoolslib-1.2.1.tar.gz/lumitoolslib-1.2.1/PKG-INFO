Metadata-Version: 2.4
Name: LumiToolsLib
Version: 1.2.1
Summary: Python utilities for dynamic strings, sandboxed files, and ANSI colors
Author-email: StrawberryMilcRivers <chocomilccy@gmail.com>
License-Expression: MIT
Requires-Python: >=3.8
Description-Content-Type: text/markdown
License-File: LICENSE
Requires-Dist: pyperclip>=1.8.0
Requires-Dist: requests>=2.25.0
Requires-Dist: win10toast>=0.9.0; platform_system == "Windows"
Provides-Extra: dev
Requires-Dist: pytest; extra == "dev"
Requires-Dist: black; extra == "dev"
Requires-Dist: mypy; extra == "dev"
Dynamic: license-file

# **ltools** ðŸ”§
*A Swiss Army knife for Python scripting and automation*

[![PyPI version](https://badge.fury.io/py/LumiToolsLib.svg)](https://pypi.org/project/LumiToolsLib/)

`ltools` is a powerful utility library for Python that simplifies file operations, text manipulation, encoding, system tasks, and more, with built-in **sandbox mode** for safe testing.

---

## **Features** âœ¨
âœ… **File Operations** â€“ Read, write, copy, grep, and manage files (with sandbox support).
âœ… **Dynamic Strings** â€“ `S()` and `M()` for runtime string interpolation.
âœ… **Encoding/Decoding** â€“ Secure `encode()`/`decode()` with shadow keys.
âœ… **System Utilities** â€“ Cross-platform notifications, clipboard access, and public IP fetching.
âœ… **ANSI Styling** â€“ RGB colors and text formatting for terminals.
âœ… **Sandbox Mode** â€“ Virtual filesystem for testing without touching real files.
âœ… **Smart Functions** â€“ Fuzzy matching, random generators, UUIDs, and more.

---

## **Quick Start**

### **1. File Operations (Sandbox Supported)**
```python
from ltools import *

# Write to a sandboxed file (doesn't touch disk)
debug.sandbox(True)  # Enable sandbox mode
rw_file("test.txt", "Hello, sandbox!")
print(file_exists("test.txt"))  # True (in sandbox)

# Real filesystem operations
debug.sandbox(False)
rw_file("real_file.txt", "This writes to disk.")
```

### **2. Dynamic Strings (`S` and `M` Classes)**
```python
user = "Alice"
id_num = 42

# S() updates dynamically
greeting = S("User {user} (ID: {id_num}) logged in at {timestamp()}")
m_greeting = M("User {user} (ID: [id_num]) logged in at {timestamp()}")
print(greeting)  # "User Alice (ID: 42) logged in at ..."
print(m_greeting)  # "User Alice (ID: 42) logged in at ..."

user = "Bob"
id_num = 31

print(greeting)  # Automatically updates to "User Bob (ID: 31)..."
print(m_greeting)  # Updates to "User Bob (ID: 42)..."
```

### **3. Encoding & Security**
```python
encoded = encode("Secret Message")
decoded = decode(encoded)
print(decoded.decode())
```

### **4. System Utilities**
```python
notify("Task Done", "Script completed successfully!")  # OS notification
clipboard_copy("Copy this to clipboard")
print(censor(get_public_ip(),'-'))  # "192.---.-.1" (censored)
```

### **5. Run the Full Demo**
```python
tech_demo()  # Showcases all features
```

## **API Highlights**

| Function | Description |
|----------|-------------|
| `rw_file()` | Read/write files (sandbox-aware). |
| `S("text {var}")` | Dynamic string (updates on variable changes). |
| `encode(data)` / `decode(data)` | Secure encoding with shadow keys. |
| `notify()` | Cross-platform system notifications. |
| `file_grep()` | Search files using regex. |
| `ansi()` | RGB terminal styling. |
| `debug.sandbox()` | Toggle sandbox mode. |

## **DEBUG Features**
```debug.sandbox(True/False)  # Sets if you want to use sandbox or not.
debug.death(True/False)    # Enables/disables debug.death(), which raises an error on call. Good for testing error handling.
debug.status()             # Prints current sandbox and death state.
debug.peek_vars(dictionary, KeysToInspect=None) # Returns values from the dictionary. If KeysToInspect is not provided, returns all keys+values.
debug.safe_eval(expression, globals_=None, locals_=None) # Attempts to evaluate an expression safely with error-catching. Pass in globals()/locals() for scope control.
debug.trace(msg="Trace", pause=False, lines=2) # Prints a mini traceback (stack trace) up to `lines` frames, with a header. pause=True will halt execution until Enter is pressed.
debug.pause(msg="\nPaused. Press enter to continue code.") # Simple pause that waits for user input. Customize the message if you'd like.
debug.watch(var_name, scope, prefix="[WATCH]") # Prints the value of a variable from a provided `scope` (e.g., locals() or globals()). Helpful for real-time debug output.
```

## **Why Use ltools?**
- **Saves Time** â€“ No reinventing the wheel for common tasks.
- **Safe Testing** â€“ Sandbox mode prevents accidental file changes.
- **Cross-Platform** â€“ Works on Windows, macOS, and Linux.
- **Batteries Included** â€“ From clipboard ops to quantum random numbers.
