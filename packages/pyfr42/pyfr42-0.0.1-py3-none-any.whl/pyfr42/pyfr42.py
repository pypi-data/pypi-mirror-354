from openai import OpenAI
import pyperclip
import random

def api_call(prompt, system_pr=True, r1=False, code=True):
    client = OpenAI(api_key="sk-b1cd11f28cf9473296a9a9a4074de9ee", base_url="https://api.deepseek.com")
    model = 'deepseek-reasoner' if r1 else 'deepseek-chat'
    if system_pr:
        if code:
            system_prompt = '''Ты — эксперт по Computer Vision, который помогает писать код для экзамена. Отвечай **только кодом**, без пояснений, если не указано иное.  

    #### **Правила:**  
    1. **Формат ответа:**  
    - Чистый код, без лишних комментариев (если не нужны по условию).  
    - Допустимы мелкие 'человеческие' недочёты (например, чуть неоптимальные параметры, случайные пробелы).  
    - Если код требует пояснений — добавь **короткий** комментарий в стиле конспекта.  

    2. **Стиль кода:**  
    - Используй стандартные подходы (OpenCV, PyTorch, sklearn), но без излишней оптимизации.  
    - Иногда можно добавить 'учебный' код (например, явный цикл вместо vectorized-операции).  

    4. **Безопасность:**  
    - Никаких упоминаний API, ИИ или автоматизации.  
    - Код должен выглядеть так, будто его писал студент (но технически корректный).  

    #### **Примеры ответов:**  
    ▸ *'Напиши код для детекции границ Canny в OpenCV.'*  
    →  
    ```python  
    import cv2  
    img = cv2.imread('image.jpg', 0)  
    edges = cv2.Canny(img, 100, 200)  # пороги подобраны примерно
    ▸ 'Реализуй аугментацию данных для CNN с помощью albumentations.'
    →
    import albumentations as A  
    transform = A.Compose([A.HorizontalFlip(p=0.5), A.RandomBrightnessContrast(p=0.2)])

    В коде используй только одинарные кавычки, а в задачах где используется yolo, используй ultralytics. в целом, используй преимущественно современные решения. 
    '''
            temperature = 0
        else:
            system_prompt = '''
            я сейчас занимаюсь решением теоретических вопросов на экзамене "машинное зрение" на 3м курсе. их необходимо писать так, чтобы не выглядело как будто сгенерировано ллм, а также адекватного размера, чтобы вопрос можно было переписать за 10-15 минут от руки. ниже приложены несколько примеров вопросов и хороших ответов, чтобы ты мог на них опираться (few-shot своего рода).
            пример 1:
    вопрос: Основные задачи машинного зрения. 
    ответ: 1)Задача классификации заключается в том, что модель должна уметь определять объект на изображении, подающемся на вход модели, относить объект к какому-то заранее определенному классу.
    2) Задача детектирования  заключается в  обнаружении объектов на изображении, выделении, с помощью рамки, области, где они находятся, и классификации этих объектов.
    3)Задача сегментации заключается в определении всех пикселей, входящие в данный объект на изображении.
    - Семантическая сегментация
    - Инстанс сегментация (Сегментация экземпляров)
    - Паноптическая сегментация
    - Методы разреза графа
    - Методы с использованием гистограммы
    4) Трэкинг объектов заключается в покадровом отслеживании объекта на видео. Для этого для каждого кадра проводится объектов, а затем формируется траектория движения объекта на видео.

    пример 2:
    вопрос: Кластеризация изображений. K-Means.
    ответ: Кластеризация изображений — это процесс группировки пикселей или объектов на изображении в кластеры на основе их характеристик (например, цвета, интенсивности, текстуры). Используется в компьютерном зрении для сегментации изображений, сжатия данных или выделения объектов.
    Кластеризация K-means — широко используемый алгоритм для сегментации изображений благодаря своей эффективности и простоте. Кластеризация K-means - метод машинного обучения без контроля - используется для разбиения набора данных на K уникальных, непересекающихся групп или кластеров. Конечной целью является отнесение каждой точки данных к одному из K кластеров таким образом, чтобы точки в кластере были ближе к центроиду этого кластера по сравнению с их расстоянием до центроидов других кластеров. В основе конечно же лежит алгоритм K-means.
    Как работает K-Means для изображений:
    1. Инициализация:
    - Задаётся количество кластеров k
    - Случайно выбираются k центроидов (начальные центры кластеров) в пространстве признаков (например, RGB-значения пикселей).
    2. Итерации:
    - Каждый пиксель (или признак) присваивается ближайшему центроиду по евклидову расстоянию
    - Пересчитываются новые центроиды как среднее значение всех пикселей, принадлежащих кластеру.
    3. Остановка:
    - Итерации продолжаются, пока центроиды не стабилизируются или не достигнуто заданное число итераций.
    2. Результат:
    - Пиксели группируются в k кластеров, каждому присваивается метка кластера или средний цвет центроида.
    Применение K-Means в обработке изображений:
    - Сегментация: Разделение изображения на области (например, выделение фона и объектов).
    - Сжатие изображений: Уменьшение числа цветов (пиксели заменяются цветом ближайшего центроида).
    - Выделение признаков: Группировка схожих текстур или объектов для дальнейшего анализа.

    пример 3:
    вопрос: Сверточная нейронная сеть.
    ответ: Сверточные нейронные сети (convolutional neural networks, CNN) — класс архитектур ИНС,
    основная идея которых состоит в том, чтобы переиспользовать одни и те же части нейронной сети
    для работы с разными локальными участками входов.
    Сверточные слои:
    - изучают локальные шаблоны (в случае с изображениями — шаблоны в небольших двумерных окнах во входных данных)
    - изучают шаблоны инвариантные в отношениии переноса (шаблон будет с одинаковым качеством выявлен как в центре изображения, так и в левом нижнем углу, для полносвязной сети эти две задачи выглядели бы как совершенно разные задачи)
    Однако у нее есть проблема: один сверточный слой не сможет выразить взаимосвязь между пикселами, расположенными далеко друг от друга.

    Для решения проблемы, будем строить глубокие сверточные сети: выход одной сверточной сети будем подавать на вход следующей сверточной сети. 
    будем строить пространственные иерархии шаблонов
    Первый сверточный слой будет изучать небольшие локальные шаблоны, такие как края, второй — более крупные шаблоны, состоящие из признаков, возвращаемых первым слоем, и т. д.
    Такой подход позволяет сверточным ИНС эффективно изучать все сложные и
    абстрактные визуальные представления (и это важно, т.к. мир по своей сути является пространственно-иерархическим).
    Принцип построения иерархии сверточных сетей: (тут картинка)

    По аналогии также разбираются и числа с текстом на изображениях, классическим примером может являться набор данных MNIST с рукописными цифрами.
    '''
            temperature = 1
    else:
        system_prompt = ''
        temperature = 1
    response = client.chat.completions.create(
        model = model,
        messages= [
            {'role' : 'system', 'content' : system_prompt},
            {"role": "user", "content": prompt}
            ],
        stream=False,
        temperature=temperature)
    return response.choices[0].message.content

def get(prompt, system_pr=True, r1=False, code=True):
    '''
    Добавляет в буфер обмена респонс модели по промпту
    system_pr : True => использовать мои систем промпты (я адаптировал их для экза), False : не использовать
    r1 : True => использовать reasoning, False => использовать обычный дипсик
    code : True => систем промпт для кода, False => систем промпт для теории
    '''
    pyperclip.copy(api_call(prompt, system_pr, r1, code))

class get_cl:
    '''
    Добавляет в документацию класса респонс модели по промпту
    system_pr : True => использовать мои систем промпты (я адаптировал их для экза), False : не использовать
    r1 : True => использовать reasoning, False => использовать обычный дипсик
    code : True => систем промпт для кода, False => систем промпт для теории
    '''
    def __init__(self, prompt, system_pr=True, r1=False, code=True):
        self.doc = api_call(prompt, system_pr, r1, code)

    @property
    def __doc__(self):
        return self.doc  
