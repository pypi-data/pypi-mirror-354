"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
Copyright 2022 The Pigweed Authors

Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at

    https://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
"""
import builtins
import google.protobuf.descriptor
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import sys
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

@typing_extensions.final
class Chunk(google.protobuf.message.Message):
    """Represents a chunk of data sent by the transfer service. Includes fields for
    configuring the transfer parameters.

    Notation: (Read|Write) (→|←)
      X → Means client sending data to the server.
      X ← Means server sending data to the client.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _Type:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _TypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[Chunk._Type.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        DATA: Chunk._Type.ValueType  # 0
        """Chunk containing transfer data."""
        START: Chunk._Type.ValueType  # 1
        """First chunk of a transfer (only sent by the client)."""
        PARAMETERS_RETRANSMIT: Chunk._Type.ValueType  # 2
        """Transfer parameters indicating that the transmitter should retransmit
        from the specified offset.
        """
        PARAMETERS_CONTINUE: Chunk._Type.ValueType  # 3
        """Transfer parameters telling the transmitter to continue sending up to
        index `offset + pending_bytes` of data. If the transmitter is already
        beyond `offset`, it does not have to rewind.
        """
        COMPLETION: Chunk._Type.ValueType  # 4
        """Sender of the chunk is terminating the transfer."""
        COMPLETION_ACK: Chunk._Type.ValueType  # 5
        """Acknowledge the completion of a transfer. Currently unused.
        TODO(konkers): Implement this behavior.
        """
        START_ACK: Chunk._Type.ValueType  # 6
        """Acknowledges a transfer start request, accepting the session ID for the
        transfer and optionally negotiating the protocol version. Sent from
        server to client.
        """
        START_ACK_CONFIRMATION: Chunk._Type.ValueType  # 7
        """Confirmation of a START_ACK's negotiated parameters, sent by the client
        to the server. Initiates the data transfer proper.
        """

    class Type(_Type, metaclass=_TypeEnumTypeWrapper): ...
    DATA: Chunk.Type.ValueType  # 0
    """Chunk containing transfer data."""
    START: Chunk.Type.ValueType  # 1
    """First chunk of a transfer (only sent by the client)."""
    PARAMETERS_RETRANSMIT: Chunk.Type.ValueType  # 2
    """Transfer parameters indicating that the transmitter should retransmit
    from the specified offset.
    """
    PARAMETERS_CONTINUE: Chunk.Type.ValueType  # 3
    """Transfer parameters telling the transmitter to continue sending up to
    index `offset + pending_bytes` of data. If the transmitter is already
    beyond `offset`, it does not have to rewind.
    """
    COMPLETION: Chunk.Type.ValueType  # 4
    """Sender of the chunk is terminating the transfer."""
    COMPLETION_ACK: Chunk.Type.ValueType  # 5
    """Acknowledge the completion of a transfer. Currently unused.
    TODO(konkers): Implement this behavior.
    """
    START_ACK: Chunk.Type.ValueType  # 6
    """Acknowledges a transfer start request, accepting the session ID for the
    transfer and optionally negotiating the protocol version. Sent from
    server to client.
    """
    START_ACK_CONFIRMATION: Chunk.Type.ValueType  # 7
    """Confirmation of a START_ACK's negotiated parameters, sent by the client
    to the server. Initiates the data transfer proper.
    """

    TRANSFER_ID_FIELD_NUMBER: builtins.int
    PENDING_BYTES_FIELD_NUMBER: builtins.int
    MAX_CHUNK_SIZE_BYTES_FIELD_NUMBER: builtins.int
    MIN_DELAY_MICROSECONDS_FIELD_NUMBER: builtins.int
    OFFSET_FIELD_NUMBER: builtins.int
    DATA_FIELD_NUMBER: builtins.int
    REMAINING_BYTES_FIELD_NUMBER: builtins.int
    STATUS_FIELD_NUMBER: builtins.int
    WINDOW_END_OFFSET_FIELD_NUMBER: builtins.int
    TYPE_FIELD_NUMBER: builtins.int
    RESOURCE_ID_FIELD_NUMBER: builtins.int
    SESSION_ID_FIELD_NUMBER: builtins.int
    PROTOCOL_VERSION_FIELD_NUMBER: builtins.int
    DESIRED_SESSION_ID_FIELD_NUMBER: builtins.int
    INITIAL_OFFSET_FIELD_NUMBER: builtins.int
    transfer_id: builtins.int
    """Represents the source or destination of the data. May be ephemeral or
    stable depending on the implementation. Sent in every request to identify
    the transfer target.

    LEGACY FIELD ONLY. Split into resource_id and session_id in transfer v2.

     Read → ID of transfer
     Read ← ID of transfer
    Write → ID of transfer
    Write ← ID of transfer
    """
    pending_bytes: builtins.int
    """Used by the receiver to indicate how many bytes it can accept. The
    transmitter sends this much data, divided into chunks no larger than
    max_chunk_size_bytes. The receiver then starts another window by sending
    request_bytes again with a new offset.

     Read → The client requests this many bytes to be sent.
     Read ← N/A
    Write → N/A
    Write ← The server requests this many bytes to be sent.
    """
    max_chunk_size_bytes: builtins.int
    """Maximum size of an individual chunk. The transmitter may send smaller
    chunks if required.

     Read → Set maximum size for subsequent chunks.
     Read ← N/A
    Write → N/A
    Write ← Set maximum size for subsequent chunks.
    """
    min_delay_microseconds: builtins.int
    """Minimum required delay between chunks. The transmitter may delay longer if
    desired.

     Read → Set minimum delay for subsequent chunks.
     Read ← N/A
    Write → N/A
    Write ← Set minimum delay for subsequent chunks.
    """
    offset: builtins.int
    """On writes, the offset of the data. On reads, the offset at which to read.

     Read → Read data starting at this offset.
     Read ← Offset of the data.
    Write → Offset of the data.
    Write ← Write data starting at this offset.
    """
    data: builtins.bytes
    """The data that was read or the data to write.

     Read → N/A
     Read ← Data read
    Write → Data to write
    Write ← N/A
    """
    remaining_bytes: builtins.int
    """Estimated bytes remaining to read/write. Optional except for the last data
    chunk, for which remaining_bytes must be set to 0.

    The sender can set remaining_bytes at the beginning of a read/write so that
    the receiver can track progress or cancel the transaction if the value is
    too large.

     Read → N/A
     Read ← Remaining bytes to read, excluding any data in this chunk. Set to
            0 for the last chunk.
    Write → Remaining bytes to write, excluding any data in is chunk. Set to
            0 for the last chunk.
    Write ← N/A
    """
    status: builtins.int
    """Pigweed status code indicating the completion of a transfer. This is only
    present in the final packet sent by either the transmitter or receiver.

    The possible status codes and their meanings are listed below:

      OK: Transfer completed successfully.
      DATA_LOSS: Transfer data could not be read/written (e.g. corruption).
      INVALID_ARGUMENT: Received malformed chunk.
      NOT_FOUND: The requested resource ID is not registered (read/write).
      OUT_OF_RANGE: The requested offset is larger than the data (read/write).
      RESOURCE_EXHAUSTED: Concurrent transfer limit reached.
      UNIMPLEMENTED: Resource ID does not support requested operation (e.g.
          trying to write to a read-only transfer).

     Read → Transfer complete.
     Read ← Transfer complete.
    Write → Transfer complete.
    Write ← Transfer complete.
    """
    window_end_offset: builtins.int
    """The offset up to which the transmitter can send data before waiting for the
    receiver to acknowledge.

     Read → Offset up to which the server can send without blocking.
     Read ← N/A
    Write → N/A
    Write ← Offset up to which the client can send without blocking.

    TODO(frolv): This will replace the pending_bytes field. Once all uses of
    transfer are migrated, that field should be removed.
    """
    type: global___Chunk.Type.ValueType
    """The type of this chunk. This field should only be processed when present.
    TODO(frolv): Update all users of pw_transfer and remove the optional
    semantics from this field.

     Read → Chunk type (start/parameters).
     Read ← Chunk type (data).
    Write → Chunk type (data).
    Write ← Chunk type (start/parameters).
    """
    resource_id: builtins.int
    """Unique identifier for the source or destination of transfer data. May be
    stable or ephemeral depending on the implementation. Only sent during the
    initial handshake phase of a version 2 or higher transfer.

     Read → ID of transferable resource
     Read ← ID of transferable resource
    Write → ID of transferable resource
    Write ← ID of transferable resource
    """
    session_id: builtins.int
    """Unique identifier for a specific transfer session. Chosen by the transfer
    client during the initial handshake phase, and persists for the remainder
    of that transfer operation.

     Read → ID of transfer session
     Read ← ID of transfer session
    Write → ID of transfer session
    Write ← ID of transfer session
    """
    protocol_version: builtins.int
    """The protocol version to use for this transfer. Only sent during the initial
    handshake phase of a version 2 or higher transfer to negotiate a common
    protocol version between the client and server.

     Read → Desired (START) or configured (START_ACK_CONFIRMATION) version.
     Read ← Configured protocol version (START_ACK).
    Write → Desired (START) or configured (START_ACK_CONFIRMATION) version.
    Write ← Configured protocol version (START_ACK).
    """
    desired_session_id: builtins.int
    """Unique identifier for a specific transfer session. Chosen by the transfer
    client during the initial handshake phase. This field is used to request a
    session during the handshake, after which the regular session_id field is
    used.

     Read → Requested ID of transfer session
     Read ← N/A
    Write → Requested ID of transfer session
    Write ← N/A
    """
    initial_offset: builtins.int
    """The initial offset to start the transfer from. Can be used for read or
    write transfers. Set by the client during start handshake.
    Needs to be accepted by the resource transfer handler in order for the
    non-zero offset transfer to start from the initial_offset.

     Read → Requested initial offset for the session
     Read ← Confirmed (matches) or denied (zero) initial offset
    Write → Requested initial offset for the session
    Write ← Confirmed (matches) or denied (zero) initial offset
    """
    def __init__(
        self,
        *,
        transfer_id: builtins.int = ...,
        pending_bytes: builtins.int | None = ...,
        max_chunk_size_bytes: builtins.int | None = ...,
        min_delay_microseconds: builtins.int | None = ...,
        offset: builtins.int = ...,
        data: builtins.bytes = ...,
        remaining_bytes: builtins.int | None = ...,
        status: builtins.int | None = ...,
        window_end_offset: builtins.int = ...,
        type: global___Chunk.Type.ValueType | None = ...,
        resource_id: builtins.int | None = ...,
        session_id: builtins.int | None = ...,
        protocol_version: builtins.int | None = ...,
        desired_session_id: builtins.int | None = ...,
        initial_offset: builtins.int = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["_desired_session_id", b"_desired_session_id", "_max_chunk_size_bytes", b"_max_chunk_size_bytes", "_min_delay_microseconds", b"_min_delay_microseconds", "_pending_bytes", b"_pending_bytes", "_protocol_version", b"_protocol_version", "_remaining_bytes", b"_remaining_bytes", "_resource_id", b"_resource_id", "_session_id", b"_session_id", "_status", b"_status", "_type", b"_type", "desired_session_id", b"desired_session_id", "max_chunk_size_bytes", b"max_chunk_size_bytes", "min_delay_microseconds", b"min_delay_microseconds", "pending_bytes", b"pending_bytes", "protocol_version", b"protocol_version", "remaining_bytes", b"remaining_bytes", "resource_id", b"resource_id", "session_id", b"session_id", "status", b"status", "type", b"type"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["_desired_session_id", b"_desired_session_id", "_max_chunk_size_bytes", b"_max_chunk_size_bytes", "_min_delay_microseconds", b"_min_delay_microseconds", "_pending_bytes", b"_pending_bytes", "_protocol_version", b"_protocol_version", "_remaining_bytes", b"_remaining_bytes", "_resource_id", b"_resource_id", "_session_id", b"_session_id", "_status", b"_status", "_type", b"_type", "data", b"data", "desired_session_id", b"desired_session_id", "initial_offset", b"initial_offset", "max_chunk_size_bytes", b"max_chunk_size_bytes", "min_delay_microseconds", b"min_delay_microseconds", "offset", b"offset", "pending_bytes", b"pending_bytes", "protocol_version", b"protocol_version", "remaining_bytes", b"remaining_bytes", "resource_id", b"resource_id", "session_id", b"session_id", "status", b"status", "transfer_id", b"transfer_id", "type", b"type", "window_end_offset", b"window_end_offset"]) -> None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_desired_session_id", b"_desired_session_id"]) -> typing_extensions.Literal["desired_session_id"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_max_chunk_size_bytes", b"_max_chunk_size_bytes"]) -> typing_extensions.Literal["max_chunk_size_bytes"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_min_delay_microseconds", b"_min_delay_microseconds"]) -> typing_extensions.Literal["min_delay_microseconds"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_pending_bytes", b"_pending_bytes"]) -> typing_extensions.Literal["pending_bytes"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_protocol_version", b"_protocol_version"]) -> typing_extensions.Literal["protocol_version"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_remaining_bytes", b"_remaining_bytes"]) -> typing_extensions.Literal["remaining_bytes"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_resource_id", b"_resource_id"]) -> typing_extensions.Literal["resource_id"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_session_id", b"_session_id"]) -> typing_extensions.Literal["session_id"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_status", b"_status"]) -> typing_extensions.Literal["status"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_type", b"_type"]) -> typing_extensions.Literal["type"] | None: ...

global___Chunk = Chunk

@typing_extensions.final
class ResourceStatusRequest(google.protobuf.message.Message):
    """Request for GetResourceStatus, indicating the resource to get status from."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    RESOURCE_ID_FIELD_NUMBER: builtins.int
    resource_id: builtins.int
    def __init__(
        self,
        *,
        resource_id: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["resource_id", b"resource_id"]) -> None: ...

global___ResourceStatusRequest = ResourceStatusRequest

@typing_extensions.final
class ResourceStatus(google.protobuf.message.Message):
    """Response for GetResourceStatus"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    RESOURCE_ID_FIELD_NUMBER: builtins.int
    STATUS_FIELD_NUMBER: builtins.int
    WRITEABLE_OFFSET_FIELD_NUMBER: builtins.int
    READABLE_OFFSET_FIELD_NUMBER: builtins.int
    WRITE_CHECKSUM_FIELD_NUMBER: builtins.int
    READ_CHECKSUM_FIELD_NUMBER: builtins.int
    resource_id: builtins.int
    """Resource id, matching request"""
    status: builtins.int
    """Status of the resource, returns Unimplemented by default."""
    writeable_offset: builtins.int
    """The offset that can be written to (other than 0)."""
    readable_offset: builtins.int
    """The offset that can be read from (other than 0)."""
    write_checksum: builtins.int
    """The checksum at the given write offset."""
    read_checksum: builtins.int
    """The checksum at the given read offset."""
    def __init__(
        self,
        *,
        resource_id: builtins.int = ...,
        status: builtins.int = ...,
        writeable_offset: builtins.int = ...,
        readable_offset: builtins.int = ...,
        write_checksum: builtins.int | None = ...,
        read_checksum: builtins.int | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["_read_checksum", b"_read_checksum", "_write_checksum", b"_write_checksum", "read_checksum", b"read_checksum", "write_checksum", b"write_checksum"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["_read_checksum", b"_read_checksum", "_write_checksum", b"_write_checksum", "read_checksum", b"read_checksum", "readable_offset", b"readable_offset", "resource_id", b"resource_id", "status", b"status", "write_checksum", b"write_checksum", "writeable_offset", b"writeable_offset"]) -> None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_read_checksum", b"_read_checksum"]) -> typing_extensions.Literal["read_checksum"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_write_checksum", b"_write_checksum"]) -> typing_extensions.Literal["write_checksum"] | None: ...

global___ResourceStatus = ResourceStatus
