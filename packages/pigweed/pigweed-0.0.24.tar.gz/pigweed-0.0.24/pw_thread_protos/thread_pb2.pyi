"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
Copyright 2021 The Pigweed Authors

Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at

    https://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
"""
import builtins
import collections.abc
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import sys
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

@typing_extensions.final
class ThreadState(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _Enum:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _EnumEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[ThreadState._Enum.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        UNKNOWN: ThreadState._Enum.ValueType  # 0
        """Thread state is invalid or cannot be expressed by this enum."""
        INTERRUPT_HANDLER: ThreadState._Enum.ValueType  # 1
        """Interrupt handling is often done on a stack that isn't associated with a
        true RTOS thread. This state indicates the provided thread info is for an
        interrupt handler.
        """
        RUNNING: ThreadState._Enum.ValueType  # 2
        """This is the currently active thread as marked by the RTOS. In crashes in
        interrupt contexts, this isn’t necessarily the thread that crashed.
        """
        READY: ThreadState._Enum.ValueType  # 3
        """Thread is ready to run, but isn’t currently running."""
        SUSPENDED: ThreadState._Enum.ValueType  # 4
        """The thread is not ready to run, and will not be ready to run until it is
        explicitly resumed.
        """
        BLOCKED: ThreadState._Enum.ValueType  # 5
        """The thread is waiting on something before it can run again."""
        INACTIVE: ThreadState._Enum.ValueType  # 6
        """The thread is either not yet initialized, or has terminated. In other
        words, this thread is a suspended thread that cannot be unsuspended.
        """

    class Enum(_Enum, metaclass=_EnumEnumTypeWrapper): ...
    UNKNOWN: ThreadState.Enum.ValueType  # 0
    """Thread state is invalid or cannot be expressed by this enum."""
    INTERRUPT_HANDLER: ThreadState.Enum.ValueType  # 1
    """Interrupt handling is often done on a stack that isn't associated with a
    true RTOS thread. This state indicates the provided thread info is for an
    interrupt handler.
    """
    RUNNING: ThreadState.Enum.ValueType  # 2
    """This is the currently active thread as marked by the RTOS. In crashes in
    interrupt contexts, this isn’t necessarily the thread that crashed.
    """
    READY: ThreadState.Enum.ValueType  # 3
    """Thread is ready to run, but isn’t currently running."""
    SUSPENDED: ThreadState.Enum.ValueType  # 4
    """The thread is not ready to run, and will not be ready to run until it is
    explicitly resumed.
    """
    BLOCKED: ThreadState.Enum.ValueType  # 5
    """The thread is waiting on something before it can run again."""
    INACTIVE: ThreadState.Enum.ValueType  # 6
    """The thread is either not yet initialized, or has terminated. In other
    words, this thread is a suspended thread that cannot be unsuspended.
    """

    def __init__(
        self,
    ) -> None: ...

global___ThreadState = ThreadState

@typing_extensions.final
class Thread(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    NAME_FIELD_NUMBER: builtins.int
    ACTIVE_FIELD_NUMBER: builtins.int
    STATE_FIELD_NUMBER: builtins.int
    RAW_BACKTRACE_FIELD_NUMBER: builtins.int
    SYMBOLIZED_BACKTRACE_FIELD_NUMBER: builtins.int
    RAW_STACK_FIELD_NUMBER: builtins.int
    STACK_START_POINTER_FIELD_NUMBER: builtins.int
    STACK_END_POINTER_FIELD_NUMBER: builtins.int
    STACK_POINTER_FIELD_NUMBER: builtins.int
    CPU_USAGE_HUNDREDTHS_FIELD_NUMBER: builtins.int
    STACK_POINTER_EST_PEAK_FIELD_NUMBER: builtins.int
    name: builtins.bytes
    """Thread names must be unique; this allows extensions of Snapshot to augment
    threads with additional data. This should either be human readable text, or
    tokenized data (e.g. base-64 encoded or binary data).
    """
    active: builtins.bool
    """This field has been deprecatdin favor of using the state enum to report
    RUNNING or INTERRUPT_CONTEXT to mark them as active.

    Whether or not this thread is the thread is the currently active context
    at the time of capture. For multi-thread dumps, this field should only be
    set on ONE thread.
    """
    state: global___ThreadState.Enum.ValueType
    """A summarized thread state. RTOS-specific extensions of the Thread message
    may provide more specific thread state information.
    """
    @property
    def raw_backtrace(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """Contents of a stack trace. It is expected that this stack is pre-walked,
        and contains addresses. Most recent stack events are at the beginning of
        the captured stack trace.
        """
    @property
    def symbolized_backtrace(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """Results of symbolizing stack_entries. This is usually not provided by the
        device, but instead by server/host side processing.
        """
    raw_stack: builtins.bytes
    """This should contain the raw contents of the thread's stack. This might not
    match stack_size. It can be larger due to a stack overflow, or smaller due
    to the implementation deciding to only capture a portion of the stack.
    Partial stack captures are typically a result of storage/memory
    limitations.
    """
    stack_start_pointer: builtins.int
    """The address this thread's stack pointer began at. For descending stacks,
    this is the highest address of the stack bounds. For ascending stacks, this
    is the lowest address of the stack bounds.
    """
    stack_end_pointer: builtins.int
    """The furthest permitted address from where this thread's stack pointer
    began. For descending stacks, this is the lowest address of the stack
    bounds. For ascending stacks, this is the highest address of the stack
    bounds.
    """
    stack_pointer: builtins.int
    """The current stack pointer of this thread."""
    cpu_usage_hundredths: builtins.int
    """CPU usage info. This is the percentage of CPU time the thread has been
    active in hundredths of a percent. (e.g. 5.00% = 500u)
    """
    stack_pointer_est_peak: builtins.int
    """The address of highest estimated currently used in the thread stack.
    Percentage of bytes used can be calculated by:
    (stack_estimate_max_addr-stack_start_pointer) /
    (stack_end_pointer-stack_start_pointer) * 100%
    """
    def __init__(
        self,
        *,
        name: builtins.bytes = ...,
        active: builtins.bool = ...,
        state: global___ThreadState.Enum.ValueType = ...,
        raw_backtrace: collections.abc.Iterable[builtins.int] | None = ...,
        symbolized_backtrace: collections.abc.Iterable[builtins.str] | None = ...,
        raw_stack: builtins.bytes = ...,
        stack_start_pointer: builtins.int | None = ...,
        stack_end_pointer: builtins.int | None = ...,
        stack_pointer: builtins.int | None = ...,
        cpu_usage_hundredths: builtins.int | None = ...,
        stack_pointer_est_peak: builtins.int | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["_cpu_usage_hundredths", b"_cpu_usage_hundredths", "_stack_end_pointer", b"_stack_end_pointer", "_stack_pointer", b"_stack_pointer", "_stack_pointer_est_peak", b"_stack_pointer_est_peak", "_stack_start_pointer", b"_stack_start_pointer", "cpu_usage_hundredths", b"cpu_usage_hundredths", "stack_end_pointer", b"stack_end_pointer", "stack_pointer", b"stack_pointer", "stack_pointer_est_peak", b"stack_pointer_est_peak", "stack_start_pointer", b"stack_start_pointer"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["_cpu_usage_hundredths", b"_cpu_usage_hundredths", "_stack_end_pointer", b"_stack_end_pointer", "_stack_pointer", b"_stack_pointer", "_stack_pointer_est_peak", b"_stack_pointer_est_peak", "_stack_start_pointer", b"_stack_start_pointer", "active", b"active", "cpu_usage_hundredths", b"cpu_usage_hundredths", "name", b"name", "raw_backtrace", b"raw_backtrace", "raw_stack", b"raw_stack", "stack_end_pointer", b"stack_end_pointer", "stack_pointer", b"stack_pointer", "stack_pointer_est_peak", b"stack_pointer_est_peak", "stack_start_pointer", b"stack_start_pointer", "state", b"state", "symbolized_backtrace", b"symbolized_backtrace"]) -> None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_cpu_usage_hundredths", b"_cpu_usage_hundredths"]) -> typing_extensions.Literal["cpu_usage_hundredths"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_stack_end_pointer", b"_stack_end_pointer"]) -> typing_extensions.Literal["stack_end_pointer"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_stack_pointer", b"_stack_pointer"]) -> typing_extensions.Literal["stack_pointer"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_stack_pointer_est_peak", b"_stack_pointer_est_peak"]) -> typing_extensions.Literal["stack_pointer_est_peak"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_stack_start_pointer", b"_stack_start_pointer"]) -> typing_extensions.Literal["stack_start_pointer"] | None: ...

global___Thread = Thread

@typing_extensions.final
class SnapshotThreadInfo(google.protobuf.message.Message):
    """This message overlays the pw.snapshot.Snapshot proto. It's valid to encode
    this message to the same sink that a Snapshot proto is being written to.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    THREADS_FIELD_NUMBER: builtins.int
    @property
    def threads(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Thread]: ...
    def __init__(
        self,
        *,
        threads: collections.abc.Iterable[global___Thread] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["threads", b"threads"]) -> None: ...

global___SnapshotThreadInfo = SnapshotThreadInfo
