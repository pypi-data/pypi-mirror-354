key,value
make_server.warning,"您是否已创建mcp-weather项目？\n请先完成之前的教程"
make_server.step1.title,"步骤1：创建服务器实例"
make_server.step1.intro1,"在此步骤中，您将使用生命周期管理器创建服务器实例。"
make_server.step1.intro2,"让我们分解每个部分的作用："
make_server.step1.decorator.title,"1. @asynccontextmanager装饰器："
make_server.step1.decorator.1,"- 此装饰器帮助管理服务器的生命周期"
make_server.step1.decorator.2,"- 确保服务器资源的正确设置和清理"
make_server.step1.decorator.3,"- 类似于上下文管理器（with语句），但用于异步代码"
make_server.step1.lifespan.title,"2. server_lifespan函数："
make_server.step1.lifespan.1,"- 管理服务器的生命周期事件"
make_server.step1.lifespan.2,"- yield server.name：在其活动生命周期期间提供上下文（在这里是server.name）"
make_server.step1.lifespan.3,"- 可以通过访问server.request_context来获取此上下文"
make_server.step1.lifespan.4,"- finally块：服务器关闭时用于清理代码的地方"
make_server.step1.instance.title,"3. 服务器实例创建："
make_server.step1.instance.1,"- 创建一个名为'weather'的新mcp.server"
make_server.step1.instance.2,"- 附加生命周期管理器以处理生命周期事件"
make_server.step1.add_code,"将以下代码添加到文件中："
make_server.step1.dependency,"您还需要在project.toml文件中添加依赖项"
make_server.step2.title,"步骤2：添加运行函数和主函数"
make_server.step2.intro1,"在此步骤中，您将添加运行函数和主入口点。"
make_server.step2.intro2,"MCP服务器可以通过两种方式实现："
make_server.step2.stdio.title,"1. 通过标准输入/输出（stdio）的本地服务器"
make_server.step2.stdio.1,"- 通过stdin/stdout直接通信"
make_server.step2.stdio.2,"- 许多MCP服务器都随包一起分发，可以使用npx、uv运行"
make_server.step2.stdio.3,"- 因此，MCP主机通常直接在本地环境中运行mcp服务器"
make_server.step2.sse.title,"2. 通过服务器发送事件（SSE）的HTTP服务器"
make_server.step2.sse.1,"- 使用SSE进行基于Web的通信"
make_server.step2.sse.2,"- 更复杂但允许远程连接"
make_server.step2.sse.3,"- 一些MCP主机不支持这种类型的连接"
make_server.step2.implement,"在本教程中，为了简单起见，我们将实现一个stdio服务器。"
make_server.step2.setup,"运行函数将使用stdio_server设置通信通道。"
make_server.step2.add_code,"将以下代码添加到文件中："
make_server.step2.dependency,"您还需要在project.toml文件中添加依赖项"
make_server.step3.title,"步骤3：添加工具"
make_server.step3.intro1,"工具是模型上下文协议（MCP）的核心功能之一。"
make_server.step3.intro2,"它们使AI模型能够与外部系统交互并执行实际任务。"
make_server.step3.keypoints.title,"关于工具的关键点："
make_server.step3.model.title,"1. 以模型为中心的控制："
make_server.step3.model.1,"- 专为以模型为中心的控制而设计"
make_server.step3.model.2,"- AI模型可以理解上下文并自动查找和调用工具"
make_server.step3.safety.title,"2. 安全性和可靠性："
make_server.step3.safety.1,"- 实际工具执行始终需要用户批准"
make_server.step3.safety.2,"- 确保与外部系统的安全和受控交互"
make_server.step3.schema.title,"3. 输入模式："
make_server.step3.schema.1,"- 定义每个工具的输入参数结构"
make_server.step3.schema.2,"- 使用JSON Schema格式指定："
make_server.step3.schema.3,"- 参数类型"
make_server.step3.schema.4,"- 参数描述"
make_server.step3.schema.5,"- 必需参数"
make_server.step3.structure,"工具结构"
make_server.step3.add_code,"将以下代码添加到文件中："
make_server.step4.title,"步骤4：实现工具处理程序"
make_server.step4.intro1,"现在我们将使用ModelContextProtocol的call_tool实现工具处理程序。"
make_server.step4.intro2,"工具处理程序根据通过list_tools接收到的工具信息被调用。"
make_server.step4.request_format,"工具调用请求格式："
make_server.step4.response_format,"工具调用响应格式："
make_server.step4.add_code,"将以下代码添加到文件中："
