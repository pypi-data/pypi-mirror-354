# Generated from pot_http.es5.cjs
SCRIPT = '// Example input:\n// var embeddedInputData = {\n//     "port": 12345,\n//     "content_bindings": ["dQw4w9WgXcQ"]\n// };\n// embeddedInputData.ytAtR = JSON.parse(\'\\x7b\\x7d\');\n\n// yt-dlp\'s PhantomJSwrapper relies on\n// `\'phantom.exit();\' in jscode`\n// phantom.exit();\n\nvar globalObj = (typeof globalThis !== \'undefined\') ? globalThis :\n    (typeof global !== \'undefined\') ? global :\n        (typeof window !== \'undefined\') ? window :\n            (typeof self !== \'undefined\') ? self :\n                this;\n\nvar writeError, writeDebug, writeLog, nop = function () { }, exit;\nif (typeof phantomInnerAPI !== \'undefined\') {\n    exit = phantomInnerAPI.exit;\n    writeError = phantomInnerAPI.writeError;\n    writeLog = phantomInnerAPI.writeLog;\n    if (embeddedInputData.NDEBUG) {\n        writeDebug = nop;\n        phantomInnerAPI.disableDebugging();\n    } else {\n        writeDebug = phantomInnerAPI.writeDebug;\n    }\n} else {\n    writeError = function () { console.error.apply(console, arguments); return console.trace(); };\n    writeDebug = embeddedInputData.NDEBUG ? nop : function () { return console.debug.apply(console, arguments); };\n    writeLog = function () { return console.log.apply(console, arguments); };\n    if (typeof phantom !== \'undefined\')\n        exit = function () { return phantom.exit.apply(phantom, arguments); };\n    else if (typeof process !== \'undefined\') {\n        exit = function () { return process.exit.apply(process, arguments); };\n        var JSDOM = require(\'jsdom\').JSDOM;\n        var dom = new JSDOM(\'<!DOCTYPE html><html lang="en"><head><title></title></head><body></body></html>\', {\n            url: \'https://www.youtube.com/\',\n            referrer: \'https://www.youtube.com/\',\n            userAgent: \'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36(KHTML, like Gecko)\'\n        });\n\n        Object.assign(globalObj, {\n            window: dom.window,\n            document: dom.window.document,\n            location: dom.window.location,\n            origin: dom.window.origin\n        });\n\n        if (!Reflect.has(globalObj, \'navigator\'))\n            Object.defineProperty(globalObj, \'navigator\', { value: dom.window.navigator });\n        // for debugging\n        embeddedInputData.port = process.args && process.args[2] || 3200;\n    }\n    else\n        exit = nop;\n}\n\nfunction compatFetch(resolve, reject, url, req) {\n    req = req || {};\n    req.method = req.method ? req.method.toUpperCase() : (req.body ? \'POST\' : \'GET\');\n    req.headers = req.headers || {};\n    req.body = req.body || null;\n    req.timeout = req.timeout || 3000;\n    if (typeof fetch === \'function\') {\n        writeDebug(\'FETCH\', url);\n        fetch(url, req).then(function (response) {\n            return {\n                ok: response.ok,\n                status: response.status,\n                url: response.url,\n                text: function (resolveInner, rejectInner) {\n                    response.text().then(resolveInner).catch(rejectInner);\n                },\n                json: function (resolveInner, rejectInner) {\n                    response.json().then(resolveInner).catch(rejectInner);\n                },\n                headers: {\n                    get: response.headers.get,\n                    _raw: response.headers\n                }\n            };\n        }).then(resolve).catch(reject);\n    } else if (typeof XMLHttpRequest !== \'undefined\') {\n        writeDebug(\'XHR\', url);\n        var xhr;\n        try {\n            xhr = new XMLHttpRequest();\n        } catch (err) {\n            return reject(err);\n        }\n        xhr.open(req.method, url, true);\n        for (var hdr in req.headers) {\n            if (hdr.toLowerCase() === \'user-agent\') {\n                if (typeof phantomInnerAPI === \'undefined\')\n                    return reject(new Error(\'UA is not supported\'));\n                else\n                    phantomInnerAPI.setUA(req.headers[hdr]);\n            } else {\n                xhr.setRequestHeader(hdr, req.headers[hdr]);\n            }\n        }\n        writeDebug(\'XHR HDRSET\');\n        var doneCallbacks = [];\n        var timeoutId;\n        if (req && typeof req.timeout === \'number\') {\n            xhr.timeout = req.timeout;\n            if (typeof phantom !== \'undefined\' || typeof phantomInnerAPI !== \'undefined\') {\n                // phantomjs doesn\'t seem to support XHR with timeout\n                timeoutId = setTimeout(function () {\n                    xhr.abort();\n                    if (typeof xhr.ontimeout === \'function\')\n                        xhr.ontimeout();\n                    writeDebug(\'XHR TIMEDOUT \' + url);\n                }, req.timeout);\n            }\n            writeDebug(\'XHR SETTIMEOUT \' + req.timeout);\n        }\n\n        var resolveWrapped = function (args) {\n            if (timeoutId) clearTimeout(timeoutId);\n            return resolve(args);\n        };\n        var rejectWrapped = function (args) {\n            if (timeoutId) clearTimeout(timeoutId);\n            return reject(args);\n        };\n        xhr.onreadystatechange = function () {\n            if (xhr.readyState === XMLHttpRequest.HEADERS_RECEIVED) {\n                resolveWrapped({\n                    ok: (xhr.status >= 200 && xhr.status < 300),\n                    status: xhr.status,\n                    url: xhr.responseUrl,\n                    text: function (resolveInner, _rejectInner) {\n                        doneCallbacks.push(resolveInner);\n                    },\n                    json: function (resolveInner, rejectInner) {\n                        doneCallbacks.push(function (responseText) {\n                            var parsed;\n                            try {\n                                parsed = JSON.parse(responseText);\n                            } catch (err) {\n                                return rejectInner(err);\n                            }\n                            resolveInner(parsed);\n                        });\n                    },\n                    headers: {\n                        get: function (name) {\n                            return xhr.getResponseHeader(name);\n                        },\n                        _raw: xhr.getAllResponseHeaders()\n                    }\n                });\n            } else if (xhr.readyState === XMLHttpRequest.DONE) {\n                setTimeout(function () {\n                    doneCallbacks = doneCallbacks.filter(function (x) {\n                        if (typeof x === \'function\')\n                            x(xhr.responseText);\n                        return false;\n                    });\n                }, 0);\n            } else return;\n            writeDebug(\'XHR RS \' + xhr.readyState + \' \' + url);\n        };\n        xhr.onerror = function () {\n            rejectWrapped(new Error(\'XHR failed\'));\n        };\n\n        xhr.ontimeout = function () {\n            rejectWrapped(new Error(\'XHR timed out\'));\n        };\n\n        try {\n            xhr.send(req.body);\n        } catch (err) {\n            return rejectWrapped(err);\n        }\n        writeDebug(\'XHR SENT\');\n    } else {\n        return reject(new Error(\'Could not find available networking API.\'));\n    }\n}\n\nvar base64urlToBase64Map = {\n    \'-\': \'+\',\n    _: \'/\',\n    \'.\': \'=\'\n};\n\nvar base64urlCharRegex = /[-_.]/g;\n\nfunction b64ToUTF8Arr(b64) {\n    var b64Mod;\n\n    if (base64urlCharRegex.test(b64)) {\n        b64Mod = base64.replace(base64urlCharRegex, function (match) {\n            return base64urlToBase64Map[match];\n        });\n    } else {\n        b64Mod = b64;\n    }\n    b64Mod = atob(b64Mod);\n    var ret = [];\n    b64Mod.split(\'\').forEach(function (chr) {\n        ret.push(chr.charCodeAt(0));\n    });\n    return ret;\n}\n\nfunction UTF8ArrToB64(u8, b64Url) {\n    b64Url = (typeof b64Url === \'undefined\') ? false : b64Url;\n    var str = \'\';\n    Array.prototype.forEach.call(u8, function (chrCode) {\n        str += String.fromCharCode(chrCode);\n    });\n    var result = btoa(str);\n    if (b64Url) {\n        return result\n            .replace(/\\+/g, \'-\')\n            .replace(/\\//g, \'_\');\n    }\n    return result;\n}\n\nfunction encodeASCII(str) {\n    var ret = [];\n    str.split(\'\').forEach(function (chr) {\n        ret.push(chr.charCodeAt(0));\n    });\n    return ret;\n}\n\nfunction buildPOTServerURL(path) {\n    return \'http://127.0.0.1:\'.concat(embeddedInputData.port, path);\n}\n\nfunction fetchChallenge(resolve, reject) {\n    if (embeddedInputData.ytAtR) {\n        writeDebug(\'FETCH_CHL ytAtR\');\n        var bgChallenge = embeddedInputData.ytAtR.bgChallenge;\n        var interpUrl = bgChallenge.interpreterUrl.privateDoNotAccessOrElseTrustedResourceUrlWrappedValue;\n        compatFetch(function (respRaw) {\n            if (!respRaw.ok)\n                return reject(new Error(\'Could not get challenge\'));\n            respRaw.text(function (respText) {\n                resolve({\n                    ijs: respText,\n                    uie: bgChallenge.userInteractionElement,\n                    vmn: bgChallenge.globalName,\n                    prg: bgChallenge.program\n                });\n            }, reject);\n        }, reject, buildPOTServerURL(\'/dl_js?url=\' + encodeURIComponent(\'https:\' + interpUrl)));\n    } else {\n        compatFetch(function (respRaw) {\n            if (!respRaw.ok)\n                return reject(new Error(\'Could not get challenge\'));\n            respRaw.json(function (respJson) {\n                if (!respJson || respJson.error) {\n                    var err = \'Could not get challenge\';\n                    if (respJson && respJson.error)\n                        err += \': \' + respJson.error;\n                    return reject(new Error(err));\n                }\n                resolve({\n                    ijs: respJson.interpreterJavascript.privateDoNotAccessOrElseSafeScriptWrappedValue,\n                    uie: respJson.userInteractionElement,\n                    vmn: respJson.globalName,\n                    prg: respJson.program\n                });\n            }, reject);\n        }, reject, buildPOTServerURL(\'/descrambled\'));\n    }\n}\n\nfunction load(resolve, reject, vm, program, userInteractionElement) {\n    if (!vm)\n        return reject(new Error(\'VM not found\'));\n    if (!vm.a)\n        return reject(new Error(\'VM init function not found\'));\n    var vmFns;\n    var asyncResolved = false;\n    var syncResolved = false;\n    var syncSnapshotFunction;\n    function maybeDone() {\n        if (asyncResolved && syncResolved) {\n            resolve({\n                syncSnapshotFunction: syncSnapshotFunction,\n                vmFns: vmFns\n            });\n        }\n    }\n    function vmFunctionsCallback(asyncSnapshotFunction, shutdownFunction, passEventFunction, checkCameraFunction) {\n        vmFns = {\n            asyncSnapshotFunction: asyncSnapshotFunction,\n            shutdownFunction: shutdownFunction,\n            passEventFunction: passEventFunction,\n            checkCameraFunction: checkCameraFunction\n        };\n        asyncResolved = true;\n        maybeDone();\n    }\n    syncSnapshotFunction = vm.a(program, vmFunctionsCallback, true, userInteractionElement, nop, [[], []])[0];\n    syncResolved = true;\n    maybeDone();\n}\n\nfunction snapshot(resolve, reject, vmFns, args, timeout) {\n    timeout = (typeof timeout === \'undefined\') ? 3000 : timeout;\n    if (!vmFns.asyncSnapshotFunction)\n        return reject(new Error(\'Asynchronous snapshot function not found\'));\n    var timeoutId;\n    var resolved = false;\n    function resolveWrapped(x) {\n        if (resolved) return writeDebug(\'SSHOT_MULTICB RESOLVE\');\n        resolved = true;\n        clearTimeout(timeoutId);\n        writeDebug(\'TYPEOF_WPSO\', typeof args.webPoSignalOutput[0]);\n        resolve(x);\n    }\n    function rejectWrapped(x) {\n        if (resolved) return writeDebug(\'SSHOT_MULTICB REJECT\');\n        resolved = true;\n        clearTimeout(timeoutId);\n        reject(x);\n    }\n    timeoutId = setTimeout(function () {\n        rejectWrapped(new Error(\'VM operation timed out\'));\n    }, timeout);\n    vmFns.asyncSnapshotFunction(resolveWrapped, [\n        args.contentBinding,\n        args.signedTimestamp,\n        args.webPoSignalOutput,\n        args.skipPrivacyBuffer\n    ]);\n}\n\nfunction getWebSafeMinter(resolve, reject, integrityTokenData, webPoSignalOutput) {\n    var getMinter = webPoSignalOutput[0];\n    if (!getMinter)\n        return reject(new Error(\'PMD:Undefined\'));\n    if (!integrityTokenData.integrityToken)\n        return reject(new Error(\'No integrity token provided\'));\n    var mintCallback = getMinter(b64ToUTF8Arr(integrityTokenData.integrityToken));\n    if (typeof mintCallback !== \'function\')\n        return reject(new Error(\'APF:Failed\'));\n    resolve(function (resolveInner, rejectInner, identifier) {\n        var result = mintCallback(encodeASCII(identifier));\n        if (!result)\n            return rejectInner(new Error(\'YNJ:Undefined\'));\n        if (!(result instanceof Uint8Array))\n            return rejectInner(new Error(\'ODM:Invalid\'));\n        resolveInner(UTF8ArrToB64(result, true));\n    });\n}\n\n(function () {\n    writeDebug(\'FUNC\');\n    var identifiers = embeddedInputData.content_bindings;\n    if (!identifiers.length) {\n        writeLog(\'[]\');\n        return exit(0);\n    }\n    fetchChallenge(function (chl) {\n        writeDebug(\'CHL\');\n        if (chl.ijs) {\n            new Function(chl.ijs)();\n        } else {\n            writeError(\'Could not load VM\');\n            return exit(1);\n        }\n        writeDebug(\'VM_LOADED\', JSON.stringify(globalObj[chl.vmn]));\n        writeDebug(\'VM_INIT_FN\', globalObj[chl.vmn] && typeof globalObj[chl.vmn].a);\n        load(function (bg) {\n            writeDebug(\'LD\');\n            var webPoSignalOutput = [];\n            snapshot(function (botguardResponse) {\n                writeDebug(\'SSHOT\', botguardResponse);\n                compatFetch(function (integrityTokenResponse) {\n                    writeDebug(\'IT\');\n                    integrityTokenResponse.json(function (integrityTokenJson) {\n                        writeDebug(\'ITJ\', JSON.stringify(integrityTokenJson));\n                        if (!integrityTokenResponse.ok || !integrityTokenJson) {\n                            var errMsg = \'Failed to get integrity token response: \';\n                            if (integrityTokenResponse && integrityTokenResponse.error)\n                                errMsg += \': \' + integrityTokenResponse.error;\n                            writeError(errMsg);\n                            return exit(1);\n                        }\n                        if (typeof integrityTokenJson.integrityToken !== \'string\') {\n                            writeError(\'Could not get integrity token\');\n                            return exit(1);\n                        }\n                        getWebSafeMinter(function (webSafeMinter) {\n                            var pots = [];\n                            function exitIfCompleted() {\n                                if (Object.keys(pots).length === identifiers.length) {\n                                    writeLog(JSON.stringify(pots));\n                                    exit(+(pots.indexOf(null) !== -1));\n                                }\n                            }\n                            identifiers.forEach(function (identifier, idx) {\n                                webSafeMinter(function (pot) {\n                                    pots[idx] = pot;\n                                    exitIfCompleted();\n                                }, function (err) {\n                                    writeError(\n                                        \'Failed to mint web-safe POT for identifier \'.concat(identifier, \':\'), err);\n                                    pots[idx] = null;\n                                    exitIfCompleted();\n                                }, identifier);\n                            });\n                        }, function (err) {\n                            writeError(\'Failed to get web-safe minter:\', err);\n                            exit(1);\n                        }, integrityTokenJson, webPoSignalOutput);\n                    }, function (err) {\n                        writeError(\'Failed to parse JSON:\', err);\n                        exit(1);\n                    });\n                }, function (err) {\n                    writeError(\'Failed to fetch integrity token response:\', err);\n                    exit(1);\n                }, buildPOTServerURL(\'/genit\'), {\n                    method: \'POST\',\n                    body: JSON.stringify(botguardResponse)\n                });\n            }, function (err) {\n                writeError(\'Snapshot failed: \' + err);\n                exit(1);\n            }, bg.vmFns, { webPoSignalOutput: webPoSignalOutput });\n        }, function (err) {\n            writeError(\'Error loading VM: \' + err);\n            exit(1);\n        }, globalObj[chl.vmn], chl.prg, chl.uie);\n    }, function (err) {\n        writeError(\'Failed to parse challenge: \' + err);\n        exit(1);\n    });\n})();\n'
# Generated from wrapper.cjs
SCRIPT_WRAPPER = '(function () {\n    \'use strict\';\n    if (typeof phantom === \'undefined\')\n        throw new Error(\'This script must be run in phantomjs\');\n    var UA =\n        \'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/37.0.2062.120 Safari/537.36\';\n    var page = require(\'webpage\').create();\n\n    // method: "method name",\n    // args: variadic: Array or single argument\n    page.onCallback = function (method, args) {\n        args = Array.isArray(args) ? args : [args];\n        var ret = {};\n        if (typeof method !== \'string\') {\n            ret.result = \'error\';\n            ret.error = \'method is not a string\';\n            console.log(\'onCallback error: \' + ret.error);\n            return ret;\n        }\n        var fnMap = {\n            exit: function (code) { return phantom.exit(code); },\n            writeError: function () { return console.trace.apply(console, arguments); },\n            writeDebug: function () { return console.debug.apply(console, arguments); },\n            writeLog: function () { return console.log.apply(console, arguments); },\n            disableDebugging: function () {\n                page.onConsoleMessage = undefined;\n            },\n            index: function () { return Object.keys(this); },\n            setUA: function (ua) {\n                return page.settings.userAgent = page.customHeaders[\'User-Agent\'] = ua;\n            }\n        };\n        var obj = fnMap[method];\n        ret.objType = typeof obj;\n        if (typeof obj === \'function\') {\n            ret.result = \'success\';\n            ret.value = obj.apply(fnMap, args);\n            return ret;\n        } else if (typeof obj === \'undefined\') {\n            ret.result = \'error\';\n            ret.error = \'object is undefined\';\n            console.log(\'onCallback error: \' + ret.error);\n            return ret;\n        } else {\n            ret.result = \'error\';\n            ret.error = \'unknown object type: \' + typeof obj;\n            console.log(\'onCallback error: \' + ret.error);\n            return ret;\n        }\n    };\n\n    page.onConsoleMessage = function (msg) {\n        console.log(\'CONSOLE: \' + msg);\n    };\n\n    page.customHeaders[\'User-Agent\'] = page.settings.userAgent = UA;\n\n    page.open(\'about:blank\', function (status) {\n        if (status !== \'success\') {\n            console.error(\'Failed to load the page\');\n            phantom.exit();\n            return;\n        }\n        page.setContent(\n            \'<!DOCTYPE html><html lang="en"><head><title></title></head><body></body></html>\',\n            \'https://www.youtube.com/\');\n\n        page.evaluate(function () {\n            \'use strict\';\n            function callHost(method) {\n                var res = callHost.callPhantom.call(window, method, Array.prototype.slice.call(arguments, 1));\n                if (res.result === \'error\')\n                    throw new Error(\'callPhantom failure: \' + res.error);\n                else if (res.result === \'success\')\n                    return res.value;\n                else\n                    throw new Error(\'callPhanton unknown result: \' + res.result);\n            }\n            if (typeof window.callPhantom !== \'function\')\n                throw new Error(\'Could not find window.callPhantom\');\n            callHost.callPhantom = window.callPhantom;\n            delete window.callPhantom;\n            var phantomInnerAPI = {};\n            callHost(\'index\').forEach(\n                function (method) {\n                    phantomInnerAPI[method] = function () {\n                        return callHost.apply(null, [method].concat(Array.prototype.slice.call(arguments)));\n                    };\n                }\n            );\n/*__PLACEHOLDER_REPLACE_WITH_SCRIPT_CONTENT__*/\n        });\n    });\n})();\n'
