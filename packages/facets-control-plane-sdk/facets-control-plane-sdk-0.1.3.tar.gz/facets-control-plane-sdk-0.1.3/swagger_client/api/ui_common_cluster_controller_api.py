# coding: utf-8

"""
    Api Documentation

    Api Documentation  # noqa: E501

    OpenAPI spec version: 1.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class UiCommonClusterControllerApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def add_cluster_schedules_using_post(self, body, cluster_id, **kwargs):  # noqa: E501
        """addClusterSchedules  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_cluster_schedules_using_post(body, cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ScheduleRequest body: request (required)
        :param str cluster_id: clusterId (required)
        :return: list[ClusterSchedule]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_cluster_schedules_using_post_with_http_info(body, cluster_id, **kwargs)  # noqa: E501
        else:
            (data) = self.add_cluster_schedules_using_post_with_http_info(body, cluster_id, **kwargs)  # noqa: E501
            return data

    def add_cluster_schedules_using_post_with_http_info(self, body, cluster_id, **kwargs):  # noqa: E501
        """addClusterSchedules  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_cluster_schedules_using_post_with_http_info(body, cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ScheduleRequest body: request (required)
        :param str cluster_id: clusterId (required)
        :return: list[ClusterSchedule]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'cluster_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_cluster_schedules_using_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_cluster_schedules_using_post`")  # noqa: E501
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params or
                params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `add_cluster_schedules_using_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['clusterId'] = params['cluster_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['main']  # noqa: E501

        return self.api_client.call_api(
            '/cc-ui/v1/clusters/{clusterId}/schedule', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ClusterSchedule]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_tools_config_using_post(self, body, cluster_id, **kwargs):  # noqa: E501
        """addToolsConfig  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_tools_config_using_post(body, cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ToolsConfig body: toolsConfig (required)
        :param str cluster_id: clusterId (required)
        :return: ToolsConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_tools_config_using_post_with_http_info(body, cluster_id, **kwargs)  # noqa: E501
        else:
            (data) = self.add_tools_config_using_post_with_http_info(body, cluster_id, **kwargs)  # noqa: E501
            return data

    def add_tools_config_using_post_with_http_info(self, body, cluster_id, **kwargs):  # noqa: E501
        """addToolsConfig  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_tools_config_using_post_with_http_info(body, cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ToolsConfig body: toolsConfig (required)
        :param str cluster_id: clusterId (required)
        :return: ToolsConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'cluster_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_tools_config_using_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_tools_config_using_post`")  # noqa: E501
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params or
                params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `add_tools_config_using_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['clusterId'] = params['cluster_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['main']  # noqa: E501

        return self.api_client.call_api(
            '/cc-ui/v1/clusters/{clusterId}/tools-config', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ToolsConfig',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def attach_image_using_post(self, body, cluster_id, **kwargs):  # noqa: E501
        """attachImage  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.attach_image_using_post(body, cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ImageOverrideRequest body: request (required)
        :param str cluster_id: clusterId (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.attach_image_using_post_with_http_info(body, cluster_id, **kwargs)  # noqa: E501
        else:
            (data) = self.attach_image_using_post_with_http_info(body, cluster_id, **kwargs)  # noqa: E501
            return data

    def attach_image_using_post_with_http_info(self, body, cluster_id, **kwargs):  # noqa: E501
        """attachImage  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.attach_image_using_post_with_http_info(body, cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ImageOverrideRequest body: request (required)
        :param str cluster_id: clusterId (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'cluster_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method attach_image_using_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `attach_image_using_post`")  # noqa: E501
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params or
                params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `attach_image_using_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['clusterId'] = params['cluster_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['main']  # noqa: E501

        return self.api_client.call_api(
            '/cc-ui/v1/clusters/{clusterId}/attach-image', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def bulk_enable_disable_resources_using_put(self, body, cluster_id, **kwargs):  # noqa: E501
        """bulkEnableDisableResources  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.bulk_enable_disable_resources_using_put(body, cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[ResourceEnableDisableRequest] body: resourceEnableDisableRequestList (required)
        :param str cluster_id: clusterId (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.bulk_enable_disable_resources_using_put_with_http_info(body, cluster_id, **kwargs)  # noqa: E501
        else:
            (data) = self.bulk_enable_disable_resources_using_put_with_http_info(body, cluster_id, **kwargs)  # noqa: E501
            return data

    def bulk_enable_disable_resources_using_put_with_http_info(self, body, cluster_id, **kwargs):  # noqa: E501
        """bulkEnableDisableResources  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.bulk_enable_disable_resources_using_put_with_http_info(body, cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[ResourceEnableDisableRequest] body: resourceEnableDisableRequestList (required)
        :param str cluster_id: clusterId (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'cluster_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method bulk_enable_disable_resources_using_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `bulk_enable_disable_resources_using_put`")  # noqa: E501
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params or
                params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `bulk_enable_disable_resources_using_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['clusterId'] = params['cluster_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['main']  # noqa: E501

        return self.api_client.call_api(
            '/cc-ui/v1/clusters/{clusterId}/resource-enable-disable', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def copy_configurations_selective_using_put(self, body, cluster_id, **kwargs):  # noqa: E501
        """Copy configurations from one cluster to another selectively  # noqa: E501

        Copies configurations from the source cluster to the target cluster. When mode is INCLUDE: Only specified configuration types are copied. When mode is EXCLUDE: All configuration types are copied except the specified ones.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.copy_configurations_selective_using_put(body, cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CopyConfigurationsRequest body: Request containing source cluster ID, selection mode (INCLUDE/EXCLUDE), and set of configuration types (required)
        :param str cluster_id: clusterId (required)
        :return: AbstractCluster
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.copy_configurations_selective_using_put_with_http_info(body, cluster_id, **kwargs)  # noqa: E501
        else:
            (data) = self.copy_configurations_selective_using_put_with_http_info(body, cluster_id, **kwargs)  # noqa: E501
            return data

    def copy_configurations_selective_using_put_with_http_info(self, body, cluster_id, **kwargs):  # noqa: E501
        """Copy configurations from one cluster to another selectively  # noqa: E501

        Copies configurations from the source cluster to the target cluster. When mode is INCLUDE: Only specified configuration types are copied. When mode is EXCLUDE: All configuration types are copied except the specified ones.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.copy_configurations_selective_using_put_with_http_info(body, cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CopyConfigurationsRequest body: Request containing source cluster ID, selection mode (INCLUDE/EXCLUDE), and set of configuration types (required)
        :param str cluster_id: clusterId (required)
        :return: AbstractCluster
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'cluster_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method copy_configurations_selective_using_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `copy_configurations_selective_using_put`")  # noqa: E501
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params or
                params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `copy_configurations_selective_using_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['clusterId'] = params['cluster_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['main']  # noqa: E501

        return self.api_client.call_api(
            '/cc-ui/v1/clusters/{clusterId}/copy-configurations-selective', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AbstractCluster',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_availability_schedule_using_post(self, body, cluster_id, **kwargs):  # noqa: E501
        """createAvailabilitySchedule  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_availability_schedule_using_post(body, cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[ScheduleRequest] body: schedules (required)
        :param str cluster_id: clusterId (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_availability_schedule_using_post_with_http_info(body, cluster_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_availability_schedule_using_post_with_http_info(body, cluster_id, **kwargs)  # noqa: E501
            return data

    def create_availability_schedule_using_post_with_http_info(self, body, cluster_id, **kwargs):  # noqa: E501
        """createAvailabilitySchedule  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_availability_schedule_using_post_with_http_info(body, cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[ScheduleRequest] body: schedules (required)
        :param str cluster_id: clusterId (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'cluster_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_availability_schedule_using_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_availability_schedule_using_post`")  # noqa: E501
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params or
                params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `create_availability_schedule_using_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['clusterId'] = params['cluster_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['main']  # noqa: E501

        return self.api_client.call_api(
            '/cc-ui/v1/clusters/{clusterId}/availability-schedule', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_cluster_tf_details_using_post(self, body, cluster_id, **kwargs):  # noqa: E501
        """createClusterTFDetails  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_cluster_tf_details_using_post(body, cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TFRunConfigurations body: tfRunConfigurations (required)
        :param str cluster_id: clusterId (required)
        :return: TFRunConfigurations
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_cluster_tf_details_using_post_with_http_info(body, cluster_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_cluster_tf_details_using_post_with_http_info(body, cluster_id, **kwargs)  # noqa: E501
            return data

    def create_cluster_tf_details_using_post_with_http_info(self, body, cluster_id, **kwargs):  # noqa: E501
        """createClusterTFDetails  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_cluster_tf_details_using_post_with_http_info(body, cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TFRunConfigurations body: tfRunConfigurations (required)
        :param str cluster_id: clusterId (required)
        :return: TFRunConfigurations
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'cluster_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_cluster_tf_details_using_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_cluster_tf_details_using_post`")  # noqa: E501
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params or
                params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `create_cluster_tf_details_using_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['clusterId'] = params['cluster_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['main']  # noqa: E501

        return self.api_client.call_api(
            '/cc-ui/v1/clusters/{clusterId}/tfRunConfigurations', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TFRunConfigurations',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_draft_cluster_using_post(self, body, **kwargs):  # noqa: E501
        """createDraftCluster  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_draft_cluster_using_post(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DraftClusterRequest body: clusterRequest (required)
        :return: AbstractCluster
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_draft_cluster_using_post_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_draft_cluster_using_post_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def create_draft_cluster_using_post_with_http_info(self, body, **kwargs):  # noqa: E501
        """createDraftCluster  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_draft_cluster_using_post_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DraftClusterRequest body: clusterRequest (required)
        :return: AbstractCluster
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_draft_cluster_using_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_draft_cluster_using_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['main']  # noqa: E501

        return self.api_client.call_api(
            '/cc-ui/v1/clusters/draft-cluster', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AbstractCluster',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_snapshot_using_post(self, cluster_id, instance_name, resource_type, **kwargs):  # noqa: E501
        """createSnapshot  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_snapshot_using_post(cluster_id, instance_name, resource_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_id: clusterId (required)
        :param str instance_name: instanceName (required)
        :param str resource_type: resourceType (required)
        :return: bool
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_snapshot_using_post_with_http_info(cluster_id, instance_name, resource_type, **kwargs)  # noqa: E501
        else:
            (data) = self.create_snapshot_using_post_with_http_info(cluster_id, instance_name, resource_type, **kwargs)  # noqa: E501
            return data

    def create_snapshot_using_post_with_http_info(self, cluster_id, instance_name, resource_type, **kwargs):  # noqa: E501
        """createSnapshot  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_snapshot_using_post_with_http_info(cluster_id, instance_name, resource_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_id: clusterId (required)
        :param str instance_name: instanceName (required)
        :param str resource_type: resourceType (required)
        :return: bool
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_id', 'instance_name', 'resource_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_snapshot_using_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params or
                params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `create_snapshot_using_post`")  # noqa: E501
        # verify the required parameter 'instance_name' is set
        if ('instance_name' not in params or
                params['instance_name'] is None):
            raise ValueError("Missing the required parameter `instance_name` when calling `create_snapshot_using_post`")  # noqa: E501
        # verify the required parameter 'resource_type' is set
        if ('resource_type' not in params or
                params['resource_type'] is None):
            raise ValueError("Missing the required parameter `resource_type` when calling `create_snapshot_using_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['clusterId'] = params['cluster_id']  # noqa: E501
        if 'instance_name' in params:
            path_params['instanceName'] = params['instance_name']  # noqa: E501
        if 'resource_type' in params:
            path_params['resourceType'] = params['resource_type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['main']  # noqa: E501

        return self.api_client.call_api(
            '/cc-ui/v1/clusters/{clusterId}/dr/{resourceType}/snapshots/{instanceName}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='bool',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_template_inputs_using_post(self, body, cluster_id, input_type, **kwargs):  # noqa: E501
        """createTemplateInputs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_template_inputs_using_post(body, cluster_id, input_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[StackTemplateInput] body: templateInputs (required)
        :param str cluster_id: clusterId (required)
        :param str input_type: inputType (required)
        :return: dict(str, list[StackTemplateInput])
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_template_inputs_using_post_with_http_info(body, cluster_id, input_type, **kwargs)  # noqa: E501
        else:
            (data) = self.create_template_inputs_using_post_with_http_info(body, cluster_id, input_type, **kwargs)  # noqa: E501
            return data

    def create_template_inputs_using_post_with_http_info(self, body, cluster_id, input_type, **kwargs):  # noqa: E501
        """createTemplateInputs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_template_inputs_using_post_with_http_info(body, cluster_id, input_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[StackTemplateInput] body: templateInputs (required)
        :param str cluster_id: clusterId (required)
        :param str input_type: inputType (required)
        :return: dict(str, list[StackTemplateInput])
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'cluster_id', 'input_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_template_inputs_using_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_template_inputs_using_post`")  # noqa: E501
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params or
                params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `create_template_inputs_using_post`")  # noqa: E501
        # verify the required parameter 'input_type' is set
        if ('input_type' not in params or
                params['input_type'] is None):
            raise ValueError("Missing the required parameter `input_type` when calling `create_template_inputs_using_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['clusterId'] = params['cluster_id']  # noqa: E501
        if 'input_type' in params:
            path_params['inputType'] = params['input_type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['main']  # noqa: E501

        return self.api_client.call_api(
            '/cc-ui/v1/clusters/{clusterId}/templateInputs/{inputType}/items', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='dict(str, list[StackTemplateInput])',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_availability_schedule_using_delete(self, availability_schedule_id, cluster_id, **kwargs):  # noqa: E501
        """deleteAvailabilitySchedule  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_availability_schedule_using_delete(availability_schedule_id, cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str availability_schedule_id: availabilityScheduleId (required)
        :param str cluster_id: clusterId (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_availability_schedule_using_delete_with_http_info(availability_schedule_id, cluster_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_availability_schedule_using_delete_with_http_info(availability_schedule_id, cluster_id, **kwargs)  # noqa: E501
            return data

    def delete_availability_schedule_using_delete_with_http_info(self, availability_schedule_id, cluster_id, **kwargs):  # noqa: E501
        """deleteAvailabilitySchedule  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_availability_schedule_using_delete_with_http_info(availability_schedule_id, cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str availability_schedule_id: availabilityScheduleId (required)
        :param str cluster_id: clusterId (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['availability_schedule_id', 'cluster_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_availability_schedule_using_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'availability_schedule_id' is set
        if ('availability_schedule_id' not in params or
                params['availability_schedule_id'] is None):
            raise ValueError("Missing the required parameter `availability_schedule_id` when calling `delete_availability_schedule_using_delete`")  # noqa: E501
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params or
                params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `delete_availability_schedule_using_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'availability_schedule_id' in params:
            path_params['availabilityScheduleId'] = params['availability_schedule_id']  # noqa: E501
        if 'cluster_id' in params:
            path_params['clusterId'] = params['cluster_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['main']  # noqa: E501

        return self.api_client.call_api(
            '/cc-ui/v1/clusters/{clusterId}/availability-schedule/{availabilityScheduleId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_cluster_force_using_delete(self, cluster_id, **kwargs):  # noqa: E501
        """deleteClusterForce  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_cluster_force_using_delete(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_id: clusterId (required)
        :return: bool
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_cluster_force_using_delete_with_http_info(cluster_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_cluster_force_using_delete_with_http_info(cluster_id, **kwargs)  # noqa: E501
            return data

    def delete_cluster_force_using_delete_with_http_info(self, cluster_id, **kwargs):  # noqa: E501
        """deleteClusterForce  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_cluster_force_using_delete_with_http_info(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_id: clusterId (required)
        :return: bool
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_cluster_force_using_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params or
                params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `delete_cluster_force_using_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['clusterId'] = params['cluster_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['main']  # noqa: E501

        return self.api_client.call_api(
            '/cc-ui/v1/clusters/{clusterId}/force', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='bool',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_cluster_schedule_using_delete(self, cluster_id, cluster_schedule_id, **kwargs):  # noqa: E501
        """deleteClusterSchedule  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_cluster_schedule_using_delete(cluster_id, cluster_schedule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_id: clusterId (required)
        :param str cluster_schedule_id: clusterScheduleId (required)
        :return: list[ClusterSchedule]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_cluster_schedule_using_delete_with_http_info(cluster_id, cluster_schedule_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_cluster_schedule_using_delete_with_http_info(cluster_id, cluster_schedule_id, **kwargs)  # noqa: E501
            return data

    def delete_cluster_schedule_using_delete_with_http_info(self, cluster_id, cluster_schedule_id, **kwargs):  # noqa: E501
        """deleteClusterSchedule  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_cluster_schedule_using_delete_with_http_info(cluster_id, cluster_schedule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_id: clusterId (required)
        :param str cluster_schedule_id: clusterScheduleId (required)
        :return: list[ClusterSchedule]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_id', 'cluster_schedule_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_cluster_schedule_using_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params or
                params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `delete_cluster_schedule_using_delete`")  # noqa: E501
        # verify the required parameter 'cluster_schedule_id' is set
        if ('cluster_schedule_id' not in params or
                params['cluster_schedule_id'] is None):
            raise ValueError("Missing the required parameter `cluster_schedule_id` when calling `delete_cluster_schedule_using_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['clusterId'] = params['cluster_id']  # noqa: E501
        if 'cluster_schedule_id' in params:
            path_params['clusterScheduleId'] = params['cluster_schedule_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['main']  # noqa: E501

        return self.api_client.call_api(
            '/cc-ui/v1/clusters/{clusterId}/schedule/{clusterScheduleId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ClusterSchedule]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_cluster_tf_details_using_delete(self, cluster_id, **kwargs):  # noqa: E501
        """deleteClusterTFDetails  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_cluster_tf_details_using_delete(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_id: clusterId (required)
        :return: TFRunConfigurations
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_cluster_tf_details_using_delete_with_http_info(cluster_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_cluster_tf_details_using_delete_with_http_info(cluster_id, **kwargs)  # noqa: E501
            return data

    def delete_cluster_tf_details_using_delete_with_http_info(self, cluster_id, **kwargs):  # noqa: E501
        """deleteClusterTFDetails  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_cluster_tf_details_using_delete_with_http_info(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_id: clusterId (required)
        :return: TFRunConfigurations
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_cluster_tf_details_using_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params or
                params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `delete_cluster_tf_details_using_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['clusterId'] = params['cluster_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['main']  # noqa: E501

        return self.api_client.call_api(
            '/cc-ui/v1/clusters/{clusterId}/tfRunConfigurations', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TFRunConfigurations',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_cluster_using_delete1(self, cluster_id, **kwargs):  # noqa: E501
        """deleteCluster  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_cluster_using_delete1(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_id: clusterId (required)
        :return: bool
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_cluster_using_delete1_with_http_info(cluster_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_cluster_using_delete1_with_http_info(cluster_id, **kwargs)  # noqa: E501
            return data

    def delete_cluster_using_delete1_with_http_info(self, cluster_id, **kwargs):  # noqa: E501
        """deleteCluster  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_cluster_using_delete1_with_http_info(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_id: clusterId (required)
        :return: bool
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_cluster_using_delete1" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params or
                params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `delete_cluster_using_delete1`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['clusterId'] = params['cluster_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['main']  # noqa: E501

        return self.api_client.call_api(
            '/cc-ui/v1/clusters/{clusterId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='bool',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_overrides_using_delete(self, cluster_id, resource_name, resource_type, **kwargs):  # noqa: E501
        """deleteOverrides  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_overrides_using_delete(cluster_id, resource_name, resource_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_id: clusterId (required)
        :param str resource_name: resourceName (required)
        :param str resource_type: resourceType (required)
        :return: list[OverrideObject]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_overrides_using_delete_with_http_info(cluster_id, resource_name, resource_type, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_overrides_using_delete_with_http_info(cluster_id, resource_name, resource_type, **kwargs)  # noqa: E501
            return data

    def delete_overrides_using_delete_with_http_info(self, cluster_id, resource_name, resource_type, **kwargs):  # noqa: E501
        """deleteOverrides  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_overrides_using_delete_with_http_info(cluster_id, resource_name, resource_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_id: clusterId (required)
        :param str resource_name: resourceName (required)
        :param str resource_type: resourceType (required)
        :return: list[OverrideObject]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_id', 'resource_name', 'resource_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_overrides_using_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params or
                params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `delete_overrides_using_delete`")  # noqa: E501
        # verify the required parameter 'resource_name' is set
        if ('resource_name' not in params or
                params['resource_name'] is None):
            raise ValueError("Missing the required parameter `resource_name` when calling `delete_overrides_using_delete`")  # noqa: E501
        # verify the required parameter 'resource_type' is set
        if ('resource_type' not in params or
                params['resource_type'] is None):
            raise ValueError("Missing the required parameter `resource_type` when calling `delete_overrides_using_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['clusterId'] = params['cluster_id']  # noqa: E501
        if 'resource_name' in params:
            path_params['resourceName'] = params['resource_name']  # noqa: E501
        if 'resource_type' in params:
            path_params['resourceType'] = params['resource_type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['main']  # noqa: E501

        return self.api_client.call_api(
            '/cc-ui/v1/clusters/{clusterId}/overrides/{resourceType}/{resourceName}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[OverrideObject]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_template_inputs_using_delete(self, cluster_id, input_type, uid, **kwargs):  # noqa: E501
        """deleteTemplateInputs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_template_inputs_using_delete(cluster_id, input_type, uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_id: clusterId (required)
        :param str input_type: inputType (required)
        :param str uid: uid (required)
        :return: StackTemplateInput
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_template_inputs_using_delete_with_http_info(cluster_id, input_type, uid, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_template_inputs_using_delete_with_http_info(cluster_id, input_type, uid, **kwargs)  # noqa: E501
            return data

    def delete_template_inputs_using_delete_with_http_info(self, cluster_id, input_type, uid, **kwargs):  # noqa: E501
        """deleteTemplateInputs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_template_inputs_using_delete_with_http_info(cluster_id, input_type, uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_id: clusterId (required)
        :param str input_type: inputType (required)
        :param str uid: uid (required)
        :return: StackTemplateInput
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_id', 'input_type', 'uid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_template_inputs_using_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params or
                params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `delete_template_inputs_using_delete`")  # noqa: E501
        # verify the required parameter 'input_type' is set
        if ('input_type' not in params or
                params['input_type'] is None):
            raise ValueError("Missing the required parameter `input_type` when calling `delete_template_inputs_using_delete`")  # noqa: E501
        # verify the required parameter 'uid' is set
        if ('uid' not in params or
                params['uid'] is None):
            raise ValueError("Missing the required parameter `uid` when calling `delete_template_inputs_using_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['clusterId'] = params['cluster_id']  # noqa: E501
        if 'input_type' in params:
            path_params['inputType'] = params['input_type']  # noqa: E501
        if 'uid' in params:
            path_params['uid'] = params['uid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['main']  # noqa: E501

        return self.api_client.call_api(
            '/cc-ui/v1/clusters/{clusterId}/templateInputs/{inputType}/items/{uid}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StackTemplateInput',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_tools_config_using_delete(self, cluster_id, **kwargs):  # noqa: E501
        """deleteToolsConfig  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_tools_config_using_delete(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_id: clusterId (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_tools_config_using_delete_with_http_info(cluster_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_tools_config_using_delete_with_http_info(cluster_id, **kwargs)  # noqa: E501
            return data

    def delete_tools_config_using_delete_with_http_info(self, cluster_id, **kwargs):  # noqa: E501
        """deleteToolsConfig  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_tools_config_using_delete_with_http_info(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_id: clusterId (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_tools_config_using_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params or
                params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `delete_tools_config_using_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['clusterId'] = params['cluster_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['main']  # noqa: E501

        return self.api_client.call_api(
            '/cc-ui/v1/clusters/{clusterId}/tools-config', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def detach_image_using_delete(self, body, cluster_id, **kwargs):  # noqa: E501
        """detachImage  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.detach_image_using_delete(body, cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ImageOverrideRequest body: request (required)
        :param str cluster_id: clusterId (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.detach_image_using_delete_with_http_info(body, cluster_id, **kwargs)  # noqa: E501
        else:
            (data) = self.detach_image_using_delete_with_http_info(body, cluster_id, **kwargs)  # noqa: E501
            return data

    def detach_image_using_delete_with_http_info(self, body, cluster_id, **kwargs):  # noqa: E501
        """detachImage  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.detach_image_using_delete_with_http_info(body, cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ImageOverrideRequest body: request (required)
        :param str cluster_id: clusterId (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'cluster_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method detach_image_using_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `detach_image_using_delete`")  # noqa: E501
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params or
                params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `detach_image_using_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['clusterId'] = params['cluster_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['main']  # noqa: E501

        return self.api_client.call_api(
            '/cc-ui/v1/clusters/{clusterId}/detachImage', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def edit_tools_config_using_put(self, body, cluster_id, tools_config_id, **kwargs):  # noqa: E501
        """editToolsConfig  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.edit_tools_config_using_put(body, cluster_id, tools_config_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ToolsConfig body: toolsConfig (required)
        :param str cluster_id: clusterId (required)
        :param str tools_config_id: toolsConfigId (required)
        :return: ToolsConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.edit_tools_config_using_put_with_http_info(body, cluster_id, tools_config_id, **kwargs)  # noqa: E501
        else:
            (data) = self.edit_tools_config_using_put_with_http_info(body, cluster_id, tools_config_id, **kwargs)  # noqa: E501
            return data

    def edit_tools_config_using_put_with_http_info(self, body, cluster_id, tools_config_id, **kwargs):  # noqa: E501
        """editToolsConfig  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.edit_tools_config_using_put_with_http_info(body, cluster_id, tools_config_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ToolsConfig body: toolsConfig (required)
        :param str cluster_id: clusterId (required)
        :param str tools_config_id: toolsConfigId (required)
        :return: ToolsConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'cluster_id', 'tools_config_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method edit_tools_config_using_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `edit_tools_config_using_put`")  # noqa: E501
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params or
                params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `edit_tools_config_using_put`")  # noqa: E501
        # verify the required parameter 'tools_config_id' is set
        if ('tools_config_id' not in params or
                params['tools_config_id'] is None):
            raise ValueError("Missing the required parameter `tools_config_id` when calling `edit_tools_config_using_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['clusterId'] = params['cluster_id']  # noqa: E501
        if 'tools_config_id' in params:
            path_params['toolsConfigId'] = params['tools_config_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['main']  # noqa: E501

        return self.api_client.call_api(
            '/cc-ui/v1/clusters/{clusterId}/tools-config/{toolsConfigId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ToolsConfig',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_alerts_using_get(self, cluster_id, **kwargs):  # noqa: E501
        """getAlerts  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_alerts_using_get(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_id: clusterId (required)
        :return: dict(str, object)
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_alerts_using_get_with_http_info(cluster_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_alerts_using_get_with_http_info(cluster_id, **kwargs)  # noqa: E501
            return data

    def get_alerts_using_get_with_http_info(self, cluster_id, **kwargs):  # noqa: E501
        """getAlerts  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_alerts_using_get_with_http_info(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_id: clusterId (required)
        :return: dict(str, object)
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_alerts_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params or
                params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `get_alerts_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['clusterId'] = params['cluster_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['main']  # noqa: E501

        return self.api_client.call_api(
            '/cc-ui/v1/clusters/{clusterId}/alerts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='dict(str, object)',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_template_inputs_using_get(self, cluster_id, **kwargs):  # noqa: E501
        """getAllTemplateInputs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_template_inputs_using_get(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_id: clusterId (required)
        :return: dict(str, list[StackTemplateInput])
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_template_inputs_using_get_with_http_info(cluster_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_all_template_inputs_using_get_with_http_info(cluster_id, **kwargs)  # noqa: E501
            return data

    def get_all_template_inputs_using_get_with_http_info(self, cluster_id, **kwargs):  # noqa: E501
        """getAllTemplateInputs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_template_inputs_using_get_with_http_info(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_id: clusterId (required)
        :return: dict(str, list[StackTemplateInput])
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_template_inputs_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params or
                params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `get_all_template_inputs_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['clusterId'] = params['cluster_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['main']  # noqa: E501

        return self.api_client.call_api(
            '/cc-ui/v1/clusters/{clusterId}/templateInputs/', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='dict(str, list[StackTemplateInput])',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_availability_schedules_using_get(self, cluster_id, **kwargs):  # noqa: E501
        """getAvailabilitySchedules  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_availability_schedules_using_get(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_id: clusterId (required)
        :return: AvailabilitySchedule
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_availability_schedules_using_get_with_http_info(cluster_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_availability_schedules_using_get_with_http_info(cluster_id, **kwargs)  # noqa: E501
            return data

    def get_availability_schedules_using_get_with_http_info(self, cluster_id, **kwargs):  # noqa: E501
        """getAvailabilitySchedules  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_availability_schedules_using_get_with_http_info(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_id: clusterId (required)
        :return: AvailabilitySchedule
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_availability_schedules_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params or
                params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `get_availability_schedules_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['clusterId'] = params['cluster_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['main']  # noqa: E501

        return self.api_client.call_api(
            '/cc-ui/v1/clusters/{clusterId}/availability-schedule', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AvailabilitySchedule',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_cluster_common_using_get(self, cluster_id, **kwargs):  # noqa: E501
        """getClusterCommon  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cluster_common_using_get(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_id: clusterId (required)
        :return: AbstractCluster
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_cluster_common_using_get_with_http_info(cluster_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_cluster_common_using_get_with_http_info(cluster_id, **kwargs)  # noqa: E501
            return data

    def get_cluster_common_using_get_with_http_info(self, cluster_id, **kwargs):  # noqa: E501
        """getClusterCommon  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cluster_common_using_get_with_http_info(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_id: clusterId (required)
        :return: AbstractCluster
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_cluster_common_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params or
                params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `get_cluster_common_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['clusterId'] = params['cluster_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['main']  # noqa: E501

        return self.api_client.call_api(
            '/cc-ui/v1/clusters/{clusterId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AbstractCluster',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_cluster_info_using_get(self, cluster_id, **kwargs):  # noqa: E501
        """getClusterInfo  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cluster_info_using_get(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_id: clusterId (required)
        :return: ClusterResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_cluster_info_using_get_with_http_info(cluster_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_cluster_info_using_get_with_http_info(cluster_id, **kwargs)  # noqa: E501
            return data

    def get_cluster_info_using_get_with_http_info(self, cluster_id, **kwargs):  # noqa: E501
        """getClusterInfo  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cluster_info_using_get_with_http_info(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_id: clusterId (required)
        :return: ClusterResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_cluster_info_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params or
                params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `get_cluster_info_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['clusterId'] = params['cluster_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['main']  # noqa: E501

        return self.api_client.call_api(
            '/cc-ui/v1/clusters/{clusterId}/info', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ClusterResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_cluster_metadata_using_get(self, cluster_id, **kwargs):  # noqa: E501
        """getClusterMetadata  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cluster_metadata_using_get(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_id: clusterId (required)
        :return: ClusterMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_cluster_metadata_using_get_with_http_info(cluster_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_cluster_metadata_using_get_with_http_info(cluster_id, **kwargs)  # noqa: E501
            return data

    def get_cluster_metadata_using_get_with_http_info(self, cluster_id, **kwargs):  # noqa: E501
        """getClusterMetadata  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cluster_metadata_using_get_with_http_info(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_id: clusterId (required)
        :return: ClusterMetadata
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_cluster_metadata_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params or
                params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `get_cluster_metadata_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['clusterId'] = params['cluster_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['main']  # noqa: E501

        return self.api_client.call_api(
            '/cc-ui/v1/clusters/{clusterId}/cluster-metadata', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ClusterMetadata',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_cluster_schedules_using_get(self, cluster_id, **kwargs):  # noqa: E501
        """getClusterSchedules  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cluster_schedules_using_get(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_id: clusterId (required)
        :return: list[ClusterSchedule]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_cluster_schedules_using_get_with_http_info(cluster_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_cluster_schedules_using_get_with_http_info(cluster_id, **kwargs)  # noqa: E501
            return data

    def get_cluster_schedules_using_get_with_http_info(self, cluster_id, **kwargs):  # noqa: E501
        """getClusterSchedules  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cluster_schedules_using_get_with_http_info(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_id: clusterId (required)
        :return: list[ClusterSchedule]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_cluster_schedules_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params or
                params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `get_cluster_schedules_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['clusterId'] = params['cluster_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['main']  # noqa: E501

        return self.api_client.call_api(
            '/cc-ui/v1/clusters/{clusterId}/schedule', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ClusterSchedule]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_cluster_tf_details_using_get(self, cluster_id, **kwargs):  # noqa: E501
        """getClusterTFDetails  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cluster_tf_details_using_get(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_id: clusterId (required)
        :return: TFRunConfigurations
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_cluster_tf_details_using_get_with_http_info(cluster_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_cluster_tf_details_using_get_with_http_info(cluster_id, **kwargs)  # noqa: E501
            return data

    def get_cluster_tf_details_using_get_with_http_info(self, cluster_id, **kwargs):  # noqa: E501
        """getClusterTFDetails  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_cluster_tf_details_using_get_with_http_info(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_id: clusterId (required)
        :return: TFRunConfigurations
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_cluster_tf_details_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params or
                params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `get_cluster_tf_details_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['clusterId'] = params['cluster_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['main']  # noqa: E501

        return self.api_client.call_api(
            '/cc-ui/v1/clusters/{clusterId}/tfRunConfigurations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TFRunConfigurations',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_k8s_credentials_using_get(self, cluster_id, **kwargs):  # noqa: E501
        """getK8sCredentials  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_k8s_credentials_using_get(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_id: clusterId (required)
        :param bool refresh_permissions: refreshPermissions
        :return: KubernetesCredential
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_k8s_credentials_using_get_with_http_info(cluster_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_k8s_credentials_using_get_with_http_info(cluster_id, **kwargs)  # noqa: E501
            return data

    def get_k8s_credentials_using_get_with_http_info(self, cluster_id, **kwargs):  # noqa: E501
        """getK8sCredentials  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_k8s_credentials_using_get_with_http_info(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_id: clusterId (required)
        :param bool refresh_permissions: refreshPermissions
        :return: KubernetesCredential
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_id', 'refresh_permissions']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_k8s_credentials_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params or
                params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `get_k8s_credentials_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['clusterId'] = params['cluster_id']  # noqa: E501

        query_params = []
        if 'refresh_permissions' in params:
            query_params.append(('refreshPermissions', params['refresh_permissions']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['main']  # noqa: E501

        return self.api_client.call_api(
            '/cc-ui/v1/clusters/{clusterId}/k8sCredentials', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='KubernetesCredential',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_kube_config_using_get(self, cluster_id, **kwargs):  # noqa: E501
        """getKubeConfig  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_kube_config_using_get(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_id: clusterId (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_kube_config_using_get_with_http_info(cluster_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_kube_config_using_get_with_http_info(cluster_id, **kwargs)  # noqa: E501
            return data

    def get_kube_config_using_get_with_http_info(self, cluster_id, **kwargs):  # noqa: E501
        """getKubeConfig  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_kube_config_using_get_with_http_info(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_id: clusterId (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_kube_config_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params or
                params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `get_kube_config_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['clusterId'] = params['cluster_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['main']  # noqa: E501

        return self.api_client.call_api(
            '/cc-ui/v1/clusters/{clusterId}/kubeconfig', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_matched_modules_using_get(self, cluster_id, **kwargs):  # noqa: E501
        """getMatchedModules  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_matched_modules_using_get(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_id: clusterId (required)
        :return: MatchedModuleDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_matched_modules_using_get_with_http_info(cluster_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_matched_modules_using_get_with_http_info(cluster_id, **kwargs)  # noqa: E501
            return data

    def get_matched_modules_using_get_with_http_info(self, cluster_id, **kwargs):  # noqa: E501
        """getMatchedModules  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_matched_modules_using_get_with_http_info(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_id: clusterId (required)
        :return: MatchedModuleDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_matched_modules_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params or
                params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `get_matched_modules_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['clusterId'] = params['cluster_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['main']  # noqa: E501

        return self.api_client.call_api(
            '/cc-ui/v1/clusters/{clusterId}/match-modules', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MatchedModuleDTO',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_namespaces_in_use_by_dependent_clusters_using_get(self, base_cluster_id, **kwargs):  # noqa: E501
        """getNamespacesInUseByDependentClusters  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_namespaces_in_use_by_dependent_clusters_using_get(base_cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str base_cluster_id: baseClusterId (required)
        :return: dict(str, str)
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_namespaces_in_use_by_dependent_clusters_using_get_with_http_info(base_cluster_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_namespaces_in_use_by_dependent_clusters_using_get_with_http_info(base_cluster_id, **kwargs)  # noqa: E501
            return data

    def get_namespaces_in_use_by_dependent_clusters_using_get_with_http_info(self, base_cluster_id, **kwargs):  # noqa: E501
        """getNamespacesInUseByDependentClusters  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_namespaces_in_use_by_dependent_clusters_using_get_with_http_info(base_cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str base_cluster_id: baseClusterId (required)
        :return: dict(str, str)
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['base_cluster_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_namespaces_in_use_by_dependent_clusters_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'base_cluster_id' is set
        if ('base_cluster_id' not in params or
                params['base_cluster_id'] is None):
            raise ValueError("Missing the required parameter `base_cluster_id` when calling `get_namespaces_in_use_by_dependent_clusters_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'base_cluster_id' in params:
            path_params['baseClusterId'] = params['base_cluster_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['main']  # noqa: E501

        return self.api_client.call_api(
            '/cc-ui/v1/clusters/{baseClusterId}/base-env-in-use-namespaces', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='dict(str, str)',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_open_alerts_using_get(self, cluster_id, **kwargs):  # noqa: E501
        """getOpenAlerts  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_open_alerts_using_get(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_id: clusterId (required)
        :return: dict(str, object)
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_open_alerts_using_get_with_http_info(cluster_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_open_alerts_using_get_with_http_info(cluster_id, **kwargs)  # noqa: E501
            return data

    def get_open_alerts_using_get_with_http_info(self, cluster_id, **kwargs):  # noqa: E501
        """getOpenAlerts  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_open_alerts_using_get_with_http_info(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_id: clusterId (required)
        :return: dict(str, object)
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_open_alerts_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params or
                params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `get_open_alerts_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['clusterId'] = params['cluster_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['main']  # noqa: E501

        return self.api_client.call_api(
            '/cc-ui/v1/clusters/{clusterId}/open-alerts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='dict(str, object)',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_overrides_using_get1(self, cluster_id, **kwargs):  # noqa: E501
        """getOverrides  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_overrides_using_get1(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_id: clusterId (required)
        :return: list[OverrideObject]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_overrides_using_get1_with_http_info(cluster_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_overrides_using_get1_with_http_info(cluster_id, **kwargs)  # noqa: E501
            return data

    def get_overrides_using_get1_with_http_info(self, cluster_id, **kwargs):  # noqa: E501
        """getOverrides  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_overrides_using_get1_with_http_info(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_id: clusterId (required)
        :return: list[OverrideObject]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_overrides_using_get1" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params or
                params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `get_overrides_using_get1`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['clusterId'] = params['cluster_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['main']  # noqa: E501

        return self.api_client.call_api(
            '/cc-ui/v1/clusters/{clusterId}/overrides', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[OverrideObject]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_pinned_snapshot_using_get1(self, cluster_id, instance_name, resource_type, **kwargs):  # noqa: E501
        """getPinnedSnapshot  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_pinned_snapshot_using_get1(cluster_id, instance_name, resource_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_id: clusterId (required)
        :param str instance_name: instanceName (required)
        :param str resource_type: resourceType (required)
        :return: SnapshotInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_pinned_snapshot_using_get1_with_http_info(cluster_id, instance_name, resource_type, **kwargs)  # noqa: E501
        else:
            (data) = self.get_pinned_snapshot_using_get1_with_http_info(cluster_id, instance_name, resource_type, **kwargs)  # noqa: E501
            return data

    def get_pinned_snapshot_using_get1_with_http_info(self, cluster_id, instance_name, resource_type, **kwargs):  # noqa: E501
        """getPinnedSnapshot  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_pinned_snapshot_using_get1_with_http_info(cluster_id, instance_name, resource_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_id: clusterId (required)
        :param str instance_name: instanceName (required)
        :param str resource_type: resourceType (required)
        :return: SnapshotInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_id', 'instance_name', 'resource_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pinned_snapshot_using_get1" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params or
                params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `get_pinned_snapshot_using_get1`")  # noqa: E501
        # verify the required parameter 'instance_name' is set
        if ('instance_name' not in params or
                params['instance_name'] is None):
            raise ValueError("Missing the required parameter `instance_name` when calling `get_pinned_snapshot_using_get1`")  # noqa: E501
        # verify the required parameter 'resource_type' is set
        if ('resource_type' not in params or
                params['resource_type'] is None):
            raise ValueError("Missing the required parameter `resource_type` when calling `get_pinned_snapshot_using_get1`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['clusterId'] = params['cluster_id']  # noqa: E501
        if 'instance_name' in params:
            path_params['instanceName'] = params['instance_name']  # noqa: E501
        if 'resource_type' in params:
            path_params['resourceType'] = params['resource_type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['main']  # noqa: E501

        return self.api_client.call_api(
            '/cc-ui/v1/clusters/{clusterId}/dr/{resourceType}/snapshots/{instanceName}/pinnedSnapshot', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SnapshotInfo',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_provided_resources_using_get(self, cluster_id, **kwargs):  # noqa: E501
        """getProvidedResources  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_provided_resources_using_get(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_id: clusterId (required)
        :return: ProvidedResources
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_provided_resources_using_get_with_http_info(cluster_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_provided_resources_using_get_with_http_info(cluster_id, **kwargs)  # noqa: E501
            return data

    def get_provided_resources_using_get_with_http_info(self, cluster_id, **kwargs):  # noqa: E501
        """getProvidedResources  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_provided_resources_using_get_with_http_info(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_id: clusterId (required)
        :return: ProvidedResources
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_provided_resources_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params or
                params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `get_provided_resources_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['clusterId'] = params['cluster_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['main']  # noqa: E501

        return self.api_client.call_api(
            '/cc-ui/v1/clusters/{clusterId}/providedResources', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ProvidedResources',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_release_impacts_using_get(self, cluster_id, resource_name, resource_type, **kwargs):  # noqa: E501
        """getReleaseImpacts  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_release_impacts_using_get(cluster_id, resource_name, resource_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_id: clusterId (required)
        :param str resource_name: resourceName (required)
        :param str resource_type: resourceType (required)
        :param str attribute: attribute
        :param str change_type: changeType
        :param datetime end: end
        :param int page_number: pageNumber
        :param int page_size: pageSize
        :param str release_type: releaseType
        :param datetime start: start
        :param str triggered_by: triggeredBy
        :return: PageResourceReleaseImpact
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_release_impacts_using_get_with_http_info(cluster_id, resource_name, resource_type, **kwargs)  # noqa: E501
        else:
            (data) = self.get_release_impacts_using_get_with_http_info(cluster_id, resource_name, resource_type, **kwargs)  # noqa: E501
            return data

    def get_release_impacts_using_get_with_http_info(self, cluster_id, resource_name, resource_type, **kwargs):  # noqa: E501
        """getReleaseImpacts  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_release_impacts_using_get_with_http_info(cluster_id, resource_name, resource_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_id: clusterId (required)
        :param str resource_name: resourceName (required)
        :param str resource_type: resourceType (required)
        :param str attribute: attribute
        :param str change_type: changeType
        :param datetime end: end
        :param int page_number: pageNumber
        :param int page_size: pageSize
        :param str release_type: releaseType
        :param datetime start: start
        :param str triggered_by: triggeredBy
        :return: PageResourceReleaseImpact
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_id', 'resource_name', 'resource_type', 'attribute', 'change_type', 'end', 'page_number', 'page_size', 'release_type', 'start', 'triggered_by']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_release_impacts_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params or
                params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `get_release_impacts_using_get`")  # noqa: E501
        # verify the required parameter 'resource_name' is set
        if ('resource_name' not in params or
                params['resource_name'] is None):
            raise ValueError("Missing the required parameter `resource_name` when calling `get_release_impacts_using_get`")  # noqa: E501
        # verify the required parameter 'resource_type' is set
        if ('resource_type' not in params or
                params['resource_type'] is None):
            raise ValueError("Missing the required parameter `resource_type` when calling `get_release_impacts_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['clusterId'] = params['cluster_id']  # noqa: E501
        if 'resource_name' in params:
            path_params['resourceName'] = params['resource_name']  # noqa: E501
        if 'resource_type' in params:
            path_params['resourceType'] = params['resource_type']  # noqa: E501

        query_params = []
        if 'attribute' in params:
            query_params.append(('attribute', params['attribute']))  # noqa: E501
        if 'change_type' in params:
            query_params.append(('changeType', params['change_type']))  # noqa: E501
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if 'page_number' in params:
            query_params.append(('pageNumber', params['page_number']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('pageSize', params['page_size']))  # noqa: E501
        if 'release_type' in params:
            query_params.append(('releaseType', params['release_type']))  # noqa: E501
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'triggered_by' in params:
            query_params.append(('triggeredBy', params['triggered_by']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['main']  # noqa: E501

        return self.api_client.call_api(
            '/cc-ui/v1/clusters/{clusterId}/resourceType/{resourceType}/resourceName/{resourceName}/release-impacts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PageResourceReleaseImpact',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_resource_stats_using_get(self, cluster_id, **kwargs):  # noqa: E501
        """getResourceStats  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_resource_stats_using_get(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_id: clusterId (required)
        :return: BlueprintFileSummaryDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_resource_stats_using_get_with_http_info(cluster_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_resource_stats_using_get_with_http_info(cluster_id, **kwargs)  # noqa: E501
            return data

    def get_resource_stats_using_get_with_http_info(self, cluster_id, **kwargs):  # noqa: E501
        """getResourceStats  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_resource_stats_using_get_with_http_info(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_id: clusterId (required)
        :return: BlueprintFileSummaryDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_resource_stats_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params or
                params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `get_resource_stats_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['clusterId'] = params['cluster_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['main']  # noqa: E501

        return self.api_client.call_api(
            '/cc-ui/v1/clusters/{clusterId}/resource-stats', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BlueprintFileSummaryDto',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_template_input_by_uid_using_get(self, cluster_id, input_type, uid, **kwargs):  # noqa: E501
        """getTemplateInputByUid  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_template_input_by_uid_using_get(cluster_id, input_type, uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_id: clusterId (required)
        :param str input_type: inputType (required)
        :param str uid: uid (required)
        :return: StackTemplateInput
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_template_input_by_uid_using_get_with_http_info(cluster_id, input_type, uid, **kwargs)  # noqa: E501
        else:
            (data) = self.get_template_input_by_uid_using_get_with_http_info(cluster_id, input_type, uid, **kwargs)  # noqa: E501
            return data

    def get_template_input_by_uid_using_get_with_http_info(self, cluster_id, input_type, uid, **kwargs):  # noqa: E501
        """getTemplateInputByUid  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_template_input_by_uid_using_get_with_http_info(cluster_id, input_type, uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_id: clusterId (required)
        :param str input_type: inputType (required)
        :param str uid: uid (required)
        :return: StackTemplateInput
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_id', 'input_type', 'uid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_template_input_by_uid_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params or
                params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `get_template_input_by_uid_using_get`")  # noqa: E501
        # verify the required parameter 'input_type' is set
        if ('input_type' not in params or
                params['input_type'] is None):
            raise ValueError("Missing the required parameter `input_type` when calling `get_template_input_by_uid_using_get`")  # noqa: E501
        # verify the required parameter 'uid' is set
        if ('uid' not in params or
                params['uid'] is None):
            raise ValueError("Missing the required parameter `uid` when calling `get_template_input_by_uid_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['clusterId'] = params['cluster_id']  # noqa: E501
        if 'input_type' in params:
            path_params['inputType'] = params['input_type']  # noqa: E501
        if 'uid' in params:
            path_params['uid'] = params['uid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['main']  # noqa: E501

        return self.api_client.call_api(
            '/cc-ui/v1/clusters/{clusterId}/templateInputs/{inputType}/items/{uid}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StackTemplateInput',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_template_inputs_using_get(self, cluster_id, input_type, **kwargs):  # noqa: E501
        """getTemplateInputs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_template_inputs_using_get(cluster_id, input_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_id: clusterId (required)
        :param str input_type: inputType (required)
        :return: list[StackTemplateInput]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_template_inputs_using_get_with_http_info(cluster_id, input_type, **kwargs)  # noqa: E501
        else:
            (data) = self.get_template_inputs_using_get_with_http_info(cluster_id, input_type, **kwargs)  # noqa: E501
            return data

    def get_template_inputs_using_get_with_http_info(self, cluster_id, input_type, **kwargs):  # noqa: E501
        """getTemplateInputs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_template_inputs_using_get_with_http_info(cluster_id, input_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_id: clusterId (required)
        :param str input_type: inputType (required)
        :return: list[StackTemplateInput]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_id', 'input_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_template_inputs_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params or
                params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `get_template_inputs_using_get`")  # noqa: E501
        # verify the required parameter 'input_type' is set
        if ('input_type' not in params or
                params['input_type'] is None):
            raise ValueError("Missing the required parameter `input_type` when calling `get_template_inputs_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['clusterId'] = params['cluster_id']  # noqa: E501
        if 'input_type' in params:
            path_params['inputType'] = params['input_type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['main']  # noqa: E501

        return self.api_client.call_api(
            '/cc-ui/v1/clusters/{clusterId}/templateInputs/{inputType}/items', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[StackTemplateInput]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_tools_config_using_get(self, cluster_id, **kwargs):  # noqa: E501
        """getToolsConfig  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tools_config_using_get(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_id: clusterId (required)
        :return: ToolsConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_tools_config_using_get_with_http_info(cluster_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_tools_config_using_get_with_http_info(cluster_id, **kwargs)  # noqa: E501
            return data

    def get_tools_config_using_get_with_http_info(self, cluster_id, **kwargs):  # noqa: E501
        """getToolsConfig  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tools_config_using_get_with_http_info(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_id: clusterId (required)
        :return: ToolsConfig
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_tools_config_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params or
                params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `get_tools_config_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['clusterId'] = params['cluster_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['main']  # noqa: E501

        return self.api_client.call_api(
            '/cc-ui/v1/clusters/{clusterId}/tools-config', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ToolsConfig',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_variable_counts_using_get(self, cluster_id, **kwargs):  # noqa: E501
        """getVariableCounts  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_variable_counts_using_get(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_id: clusterId (required)
        :return: VariableCountDto
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_variable_counts_using_get_with_http_info(cluster_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_variable_counts_using_get_with_http_info(cluster_id, **kwargs)  # noqa: E501
            return data

    def get_variable_counts_using_get_with_http_info(self, cluster_id, **kwargs):  # noqa: E501
        """getVariableCounts  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_variable_counts_using_get_with_http_info(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_id: clusterId (required)
        :return: VariableCountDto
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_variable_counts_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params or
                params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `get_variable_counts_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['clusterId'] = params['cluster_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['main']  # noqa: E501

        return self.api_client.call_api(
            '/cc-ui/v1/clusters/{clusterId}/variable-counts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='VariableCountDto',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_vars_using_get(self, cluster_id, **kwargs):  # noqa: E501
        """getVars  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_vars_using_get(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_id: clusterId (required)
        :return: AbstractCluster
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_vars_using_get_with_http_info(cluster_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_vars_using_get_with_http_info(cluster_id, **kwargs)  # noqa: E501
            return data

    def get_vars_using_get_with_http_info(self, cluster_id, **kwargs):  # noqa: E501
        """getVars  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_vars_using_get_with_http_info(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_id: clusterId (required)
        :return: AbstractCluster
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_vars_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params or
                params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `get_vars_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['clusterId'] = params['cluster_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['main']  # noqa: E501

        return self.api_client.call_api(
            '/cc-ui/v1/clusters/{clusterId}/vars', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AbstractCluster',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_vars_with_secrets_using_get(self, cluster_id, **kwargs):  # noqa: E501
        """getVarsWithSecrets  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_vars_with_secrets_using_get(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_id: clusterId (required)
        :return: AbstractCluster
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_vars_with_secrets_using_get_with_http_info(cluster_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_vars_with_secrets_using_get_with_http_info(cluster_id, **kwargs)  # noqa: E501
            return data

    def get_vars_with_secrets_using_get_with_http_info(self, cluster_id, **kwargs):  # noqa: E501
        """getVarsWithSecrets  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_vars_with_secrets_using_get_with_http_info(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_id: clusterId (required)
        :return: AbstractCluster
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_vars_with_secrets_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params or
                params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `get_vars_with_secrets_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['clusterId'] = params['cluster_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['main']  # noqa: E501

        return self.api_client.call_api(
            '/cc-ui/v1/clusters/{clusterId}/vars-with-secrets', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AbstractCluster',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_vars_with_status_using_get(self, cluster_id, **kwargs):  # noqa: E501
        """getVarsWithStatus  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_vars_with_status_using_get(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_id: clusterId (required)
        :return: dict(str, Variables)
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_vars_with_status_using_get_with_http_info(cluster_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_vars_with_status_using_get_with_http_info(cluster_id, **kwargs)  # noqa: E501
            return data

    def get_vars_with_status_using_get_with_http_info(self, cluster_id, **kwargs):  # noqa: E501
        """getVarsWithStatus  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_vars_with_status_using_get_with_http_info(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_id: clusterId (required)
        :return: dict(str, Variables)
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_vars_with_status_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params or
                params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `get_vars_with_status_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['clusterId'] = params['cluster_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['main']  # noqa: E501

        return self.api_client.call_api(
            '/cc-ui/v1/clusters/{clusterId}/varsWithStatus', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='dict(str, Variables)',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_vpn_profile_using_get(self, cluster_id, **kwargs):  # noqa: E501
        """getVPNProfile  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_vpn_profile_using_get(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_id: clusterId (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_vpn_profile_using_get_with_http_info(cluster_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_vpn_profile_using_get_with_http_info(cluster_id, **kwargs)  # noqa: E501
            return data

    def get_vpn_profile_using_get_with_http_info(self, cluster_id, **kwargs):  # noqa: E501
        """getVPNProfile  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_vpn_profile_using_get_with_http_info(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_id: clusterId (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_vpn_profile_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params or
                params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `get_vpn_profile_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['clusterId'] = params['cluster_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['main']  # noqa: E501

        return self.api_client.call_api(
            '/cc-ui/v1/clusters/{clusterId}/vpn-profile', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_snapshots_using_get1(self, cluster_id, instance_name, resource_type, **kwargs):  # noqa: E501
        """listSnapshots  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_snapshots_using_get1(cluster_id, instance_name, resource_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_id: clusterId (required)
        :param str instance_name: instanceName (required)
        :param str resource_type: resourceType (required)
        :return: list[SnapshotInfo]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_snapshots_using_get1_with_http_info(cluster_id, instance_name, resource_type, **kwargs)  # noqa: E501
        else:
            (data) = self.list_snapshots_using_get1_with_http_info(cluster_id, instance_name, resource_type, **kwargs)  # noqa: E501
            return data

    def list_snapshots_using_get1_with_http_info(self, cluster_id, instance_name, resource_type, **kwargs):  # noqa: E501
        """listSnapshots  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_snapshots_using_get1_with_http_info(cluster_id, instance_name, resource_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_id: clusterId (required)
        :param str instance_name: instanceName (required)
        :param str resource_type: resourceType (required)
        :return: list[SnapshotInfo]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_id', 'instance_name', 'resource_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_snapshots_using_get1" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params or
                params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `list_snapshots_using_get1`")  # noqa: E501
        # verify the required parameter 'instance_name' is set
        if ('instance_name' not in params or
                params['instance_name'] is None):
            raise ValueError("Missing the required parameter `instance_name` when calling `list_snapshots_using_get1`")  # noqa: E501
        # verify the required parameter 'resource_type' is set
        if ('resource_type' not in params or
                params['resource_type'] is None):
            raise ValueError("Missing the required parameter `resource_type` when calling `list_snapshots_using_get1`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['clusterId'] = params['cluster_id']  # noqa: E501
        if 'instance_name' in params:
            path_params['instanceName'] = params['instance_name']  # noqa: E501
        if 'resource_type' in params:
            path_params['resourceType'] = params['resource_type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['main']  # noqa: E501

        return self.api_client.call_api(
            '/cc-ui/v1/clusters/{clusterId}/dr/{resourceType}/snapshots/{instanceName}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[SnapshotInfo]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def override_sizing_using_post1(self, body, cluster_id, **kwargs):  # noqa: E501
        """overrideSizing  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.override_sizing_using_post1(body, cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[OverrideRequest] body: request (required)
        :param str cluster_id: clusterId (required)
        :return: list[OverrideObject]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.override_sizing_using_post1_with_http_info(body, cluster_id, **kwargs)  # noqa: E501
        else:
            (data) = self.override_sizing_using_post1_with_http_info(body, cluster_id, **kwargs)  # noqa: E501
            return data

    def override_sizing_using_post1_with_http_info(self, body, cluster_id, **kwargs):  # noqa: E501
        """overrideSizing  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.override_sizing_using_post1_with_http_info(body, cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[OverrideRequest] body: request (required)
        :param str cluster_id: clusterId (required)
        :return: list[OverrideObject]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'cluster_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method override_sizing_using_post1" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `override_sizing_using_post1`")  # noqa: E501
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params or
                params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `override_sizing_using_post1`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['clusterId'] = params['cluster_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['main']  # noqa: E501

        return self.api_client.call_api(
            '/cc-ui/v1/clusters/{clusterId}/overrides', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[OverrideObject]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pause_release_using_post(self, body, cluster_id, **kwargs):  # noqa: E501
        """pauseRelease  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pause_release_using_post(body, cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PauseReleaseRequest body: pauseReleaseRequest (required)
        :param str cluster_id: clusterId (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pause_release_using_post_with_http_info(body, cluster_id, **kwargs)  # noqa: E501
        else:
            (data) = self.pause_release_using_post_with_http_info(body, cluster_id, **kwargs)  # noqa: E501
            return data

    def pause_release_using_post_with_http_info(self, body, cluster_id, **kwargs):  # noqa: E501
        """pauseRelease  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pause_release_using_post_with_http_info(body, cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param PauseReleaseRequest body: pauseReleaseRequest (required)
        :param str cluster_id: clusterId (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'cluster_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pause_release_using_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `pause_release_using_post`")  # noqa: E501
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params or
                params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `pause_release_using_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['clusterId'] = params['cluster_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['main']  # noqa: E501

        return self.api_client.call_api(
            '/cc-ui/v1/clusters/{clusterId}/pause-release', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def pin_snapshot_using_post1(self, body, cluster_id, instance_name, resource_type, **kwargs):  # noqa: E501
        """pinSnapshot  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pin_snapshot_using_post1(body, cluster_id, instance_name, resource_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SnapshotInfo body: snapshotInfo (required)
        :param str cluster_id: clusterId (required)
        :param str instance_name: instanceName (required)
        :param str resource_type: resourceType (required)
        :return: SnapshotInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.pin_snapshot_using_post1_with_http_info(body, cluster_id, instance_name, resource_type, **kwargs)  # noqa: E501
        else:
            (data) = self.pin_snapshot_using_post1_with_http_info(body, cluster_id, instance_name, resource_type, **kwargs)  # noqa: E501
            return data

    def pin_snapshot_using_post1_with_http_info(self, body, cluster_id, instance_name, resource_type, **kwargs):  # noqa: E501
        """pinSnapshot  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.pin_snapshot_using_post1_with_http_info(body, cluster_id, instance_name, resource_type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SnapshotInfo body: snapshotInfo (required)
        :param str cluster_id: clusterId (required)
        :param str instance_name: instanceName (required)
        :param str resource_type: resourceType (required)
        :return: SnapshotInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'cluster_id', 'instance_name', 'resource_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method pin_snapshot_using_post1" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `pin_snapshot_using_post1`")  # noqa: E501
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params or
                params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `pin_snapshot_using_post1`")  # noqa: E501
        # verify the required parameter 'instance_name' is set
        if ('instance_name' not in params or
                params['instance_name'] is None):
            raise ValueError("Missing the required parameter `instance_name` when calling `pin_snapshot_using_post1`")  # noqa: E501
        # verify the required parameter 'resource_type' is set
        if ('resource_type' not in params or
                params['resource_type'] is None):
            raise ValueError("Missing the required parameter `resource_type` when calling `pin_snapshot_using_post1`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['clusterId'] = params['cluster_id']  # noqa: E501
        if 'instance_name' in params:
            path_params['instanceName'] = params['instance_name']  # noqa: E501
        if 'resource_type' in params:
            path_params['resourceType'] = params['resource_type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['main']  # noqa: E501

        return self.api_client.call_api(
            '/cc-ui/v1/clusters/{clusterId}/dr/{resourceType}/snapshots/{instanceName}/pinnedSnapshot', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SnapshotInfo',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def refresh_kube_config_using_get(self, cluster_id, **kwargs):  # noqa: E501
        """refreshKubeConfig  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.refresh_kube_config_using_get(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_id: clusterId (required)
        :return: bool
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.refresh_kube_config_using_get_with_http_info(cluster_id, **kwargs)  # noqa: E501
        else:
            (data) = self.refresh_kube_config_using_get_with_http_info(cluster_id, **kwargs)  # noqa: E501
            return data

    def refresh_kube_config_using_get_with_http_info(self, cluster_id, **kwargs):  # noqa: E501
        """refreshKubeConfig  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.refresh_kube_config_using_get_with_http_info(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_id: clusterId (required)
        :return: bool
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method refresh_kube_config_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params or
                params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `refresh_kube_config_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['clusterId'] = params['cluster_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['main']  # noqa: E501

        return self.api_client.call_api(
            '/cc-ui/v1/clusters/{clusterId}/kubeconfig/refresh', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='bool',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remove_silence_using_delete(self, cluster_id, silence_id, **kwargs):  # noqa: E501
        """removeSilence  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_silence_using_delete(cluster_id, silence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_id: clusterId (required)
        :param str silence_id: silenceId (required)
        :return: dict(str, object)
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.remove_silence_using_delete_with_http_info(cluster_id, silence_id, **kwargs)  # noqa: E501
        else:
            (data) = self.remove_silence_using_delete_with_http_info(cluster_id, silence_id, **kwargs)  # noqa: E501
            return data

    def remove_silence_using_delete_with_http_info(self, cluster_id, silence_id, **kwargs):  # noqa: E501
        """removeSilence  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_silence_using_delete_with_http_info(cluster_id, silence_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_id: clusterId (required)
        :param str silence_id: silenceId (required)
        :return: dict(str, object)
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_id', 'silence_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_silence_using_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params or
                params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `remove_silence_using_delete`")  # noqa: E501
        # verify the required parameter 'silence_id' is set
        if ('silence_id' not in params or
                params['silence_id'] is None):
            raise ValueError("Missing the required parameter `silence_id` when calling `remove_silence_using_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['clusterId'] = params['cluster_id']  # noqa: E501
        if 'silence_id' in params:
            path_params['silenceId'] = params['silence_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['main']  # noqa: E501

        return self.api_client.call_api(
            '/cc-ui/v1/clusters/{clusterId}/alerts/silence/{silenceId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='dict(str, object)',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def resource_details_using_get(self, cluster_id, **kwargs):  # noqa: E501
        """resourceDetails  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.resource_details_using_get(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_id: clusterId (required)
        :return: list[ResourceDetails]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.resource_details_using_get_with_http_info(cluster_id, **kwargs)  # noqa: E501
        else:
            (data) = self.resource_details_using_get_with_http_info(cluster_id, **kwargs)  # noqa: E501
            return data

    def resource_details_using_get_with_http_info(self, cluster_id, **kwargs):  # noqa: E501
        """resourceDetails  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.resource_details_using_get_with_http_info(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_id: clusterId (required)
        :return: list[ResourceDetails]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method resource_details_using_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params or
                params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `resource_details_using_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['clusterId'] = params['cluster_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['main']  # noqa: E501

        return self.api_client.call_api(
            '/cc-ui/v1/clusters/{clusterId}/resourceDetails', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ResourceDetails]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_cluster_code_using_post(self, cluster_id, **kwargs):  # noqa: E501
        """setClusterCode  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_cluster_code_using_post(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_id: clusterId (required)
        :return: bool
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_cluster_code_using_post_with_http_info(cluster_id, **kwargs)  # noqa: E501
        else:
            (data) = self.set_cluster_code_using_post_with_http_info(cluster_id, **kwargs)  # noqa: E501
            return data

    def set_cluster_code_using_post_with_http_info(self, cluster_id, **kwargs):  # noqa: E501
        """setClusterCode  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_cluster_code_using_post_with_http_info(cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str cluster_id: clusterId (required)
        :return: bool
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['cluster_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_cluster_code_using_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params or
                params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `set_cluster_code_using_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['clusterId'] = params['cluster_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = ['main']  # noqa: E501

        return self.api_client.call_api(
            '/cc-ui/v1/clusters/{clusterId}/setClusterCode', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='bool',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def silence_alerts_using_post(self, body, cluster_id, **kwargs):  # noqa: E501
        """silenceAlerts  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.silence_alerts_using_post(body, cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SilenceAlarmRequest body: request (required)
        :param str cluster_id: clusterId (required)
        :return: dict(str, object)
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.silence_alerts_using_post_with_http_info(body, cluster_id, **kwargs)  # noqa: E501
        else:
            (data) = self.silence_alerts_using_post_with_http_info(body, cluster_id, **kwargs)  # noqa: E501
            return data

    def silence_alerts_using_post_with_http_info(self, body, cluster_id, **kwargs):  # noqa: E501
        """silenceAlerts  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.silence_alerts_using_post_with_http_info(body, cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SilenceAlarmRequest body: request (required)
        :param str cluster_id: clusterId (required)
        :return: dict(str, object)
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'cluster_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method silence_alerts_using_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `silence_alerts_using_post`")  # noqa: E501
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params or
                params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `silence_alerts_using_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['clusterId'] = params['cluster_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['main']  # noqa: E501

        return self.api_client.call_api(
            '/cc-ui/v1/clusters/{clusterId}/silence-alerts', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='dict(str, object)',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_availability_schedules_using_put(self, body, cluster_id, schedule_id, **kwargs):  # noqa: E501
        """updateAvailabilitySchedules  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_availability_schedules_using_put(body, cluster_id, schedule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[ScheduleRequest] body: schedules (required)
        :param str cluster_id: clusterId (required)
        :param str schedule_id: scheduleId (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_availability_schedules_using_put_with_http_info(body, cluster_id, schedule_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_availability_schedules_using_put_with_http_info(body, cluster_id, schedule_id, **kwargs)  # noqa: E501
            return data

    def update_availability_schedules_using_put_with_http_info(self, body, cluster_id, schedule_id, **kwargs):  # noqa: E501
        """updateAvailabilitySchedules  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_availability_schedules_using_put_with_http_info(body, cluster_id, schedule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[ScheduleRequest] body: schedules (required)
        :param str cluster_id: clusterId (required)
        :param str schedule_id: scheduleId (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'cluster_id', 'schedule_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_availability_schedules_using_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_availability_schedules_using_put`")  # noqa: E501
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params or
                params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `update_availability_schedules_using_put`")  # noqa: E501
        # verify the required parameter 'schedule_id' is set
        if ('schedule_id' not in params or
                params['schedule_id'] is None):
            raise ValueError("Missing the required parameter `schedule_id` when calling `update_availability_schedules_using_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['clusterId'] = params['cluster_id']  # noqa: E501
        if 'schedule_id' in params:
            path_params['scheduleId'] = params['schedule_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['main']  # noqa: E501

        return self.api_client.call_api(
            '/cc-ui/v1/clusters/{clusterId}/availability-schedule/{scheduleId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_cluster_branch_using_patch(self, body, cluster_id, **kwargs):  # noqa: E501
        """updateClusterBranch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_cluster_branch_using_patch(body, cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BranchUpdateRequest body: req (required)
        :param str cluster_id: clusterId (required)
        :return: AbstractCluster
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_cluster_branch_using_patch_with_http_info(body, cluster_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_cluster_branch_using_patch_with_http_info(body, cluster_id, **kwargs)  # noqa: E501
            return data

    def update_cluster_branch_using_patch_with_http_info(self, body, cluster_id, **kwargs):  # noqa: E501
        """updateClusterBranch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_cluster_branch_using_patch_with_http_info(body, cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BranchUpdateRequest body: req (required)
        :param str cluster_id: clusterId (required)
        :return: AbstractCluster
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'cluster_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_cluster_branch_using_patch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_cluster_branch_using_patch`")  # noqa: E501
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params or
                params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `update_cluster_branch_using_patch`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['clusterId'] = params['cluster_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['main']  # noqa: E501

        return self.api_client.call_api(
            '/cc-ui/v1/clusters/{clusterId}/branch', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AbstractCluster',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_cluster_schedules_using_put(self, body, cluster_id, cluster_schedule_id, **kwargs):  # noqa: E501
        """updateClusterSchedules  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_cluster_schedules_using_put(body, cluster_id, cluster_schedule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ScheduleRequest body: request (required)
        :param str cluster_id: clusterId (required)
        :param str cluster_schedule_id: clusterScheduleId (required)
        :return: list[ClusterSchedule]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_cluster_schedules_using_put_with_http_info(body, cluster_id, cluster_schedule_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_cluster_schedules_using_put_with_http_info(body, cluster_id, cluster_schedule_id, **kwargs)  # noqa: E501
            return data

    def update_cluster_schedules_using_put_with_http_info(self, body, cluster_id, cluster_schedule_id, **kwargs):  # noqa: E501
        """updateClusterSchedules  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_cluster_schedules_using_put_with_http_info(body, cluster_id, cluster_schedule_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ScheduleRequest body: request (required)
        :param str cluster_id: clusterId (required)
        :param str cluster_schedule_id: clusterScheduleId (required)
        :return: list[ClusterSchedule]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'cluster_id', 'cluster_schedule_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_cluster_schedules_using_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_cluster_schedules_using_put`")  # noqa: E501
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params or
                params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `update_cluster_schedules_using_put`")  # noqa: E501
        # verify the required parameter 'cluster_schedule_id' is set
        if ('cluster_schedule_id' not in params or
                params['cluster_schedule_id'] is None):
            raise ValueError("Missing the required parameter `cluster_schedule_id` when calling `update_cluster_schedules_using_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['clusterId'] = params['cluster_id']  # noqa: E501
        if 'cluster_schedule_id' in params:
            path_params['clusterScheduleId'] = params['cluster_schedule_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['main']  # noqa: E501

        return self.api_client.call_api(
            '/cc-ui/v1/clusters/{clusterId}/schedule/{clusterScheduleId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ClusterSchedule]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_cluster_tf_details_using_put(self, body, cluster_id, **kwargs):  # noqa: E501
        """updateClusterTFDetails  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_cluster_tf_details_using_put(body, cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TFRunConfigurations body: tfRunConfigurations (required)
        :param str cluster_id: clusterId (required)
        :return: TFRunConfigurations
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_cluster_tf_details_using_put_with_http_info(body, cluster_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_cluster_tf_details_using_put_with_http_info(body, cluster_id, **kwargs)  # noqa: E501
            return data

    def update_cluster_tf_details_using_put_with_http_info(self, body, cluster_id, **kwargs):  # noqa: E501
        """updateClusterTFDetails  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_cluster_tf_details_using_put_with_http_info(body, cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TFRunConfigurations body: tfRunConfigurations (required)
        :param str cluster_id: clusterId (required)
        :return: TFRunConfigurations
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'cluster_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_cluster_tf_details_using_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_cluster_tf_details_using_put`")  # noqa: E501
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params or
                params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `update_cluster_tf_details_using_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['clusterId'] = params['cluster_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['main']  # noqa: E501

        return self.api_client.call_api(
            '/cc-ui/v1/clusters/{clusterId}/tfRunConfigurations', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TFRunConfigurations',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_draft_cluster_using_put(self, body, cluster_id, **kwargs):  # noqa: E501
        """updateDraftCluster  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_draft_cluster_using_put(body, cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DraftClusterRequest body: clusterRequest (required)
        :param str cluster_id: clusterId (required)
        :return: AbstractCluster
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_draft_cluster_using_put_with_http_info(body, cluster_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_draft_cluster_using_put_with_http_info(body, cluster_id, **kwargs)  # noqa: E501
            return data

    def update_draft_cluster_using_put_with_http_info(self, body, cluster_id, **kwargs):  # noqa: E501
        """updateDraftCluster  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_draft_cluster_using_put_with_http_info(body, cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DraftClusterRequest body: clusterRequest (required)
        :param str cluster_id: clusterId (required)
        :return: AbstractCluster
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'cluster_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_draft_cluster_using_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_draft_cluster_using_put`")  # noqa: E501
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params or
                params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `update_draft_cluster_using_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['clusterId'] = params['cluster_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['main']  # noqa: E501

        return self.api_client.call_api(
            '/cc-ui/v1/clusters/draft-cluster/{clusterId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AbstractCluster',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_template_input_using_put(self, body, cluster_id, input_type, uid, **kwargs):  # noqa: E501
        """updateTemplateInput  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_template_input_using_put(body, cluster_id, input_type, uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param StackTemplateInput body: templateInput (required)
        :param str cluster_id: clusterId (required)
        :param str input_type: inputType (required)
        :param str uid: uid (required)
        :return: StackTemplateInput
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_template_input_using_put_with_http_info(body, cluster_id, input_type, uid, **kwargs)  # noqa: E501
        else:
            (data) = self.update_template_input_using_put_with_http_info(body, cluster_id, input_type, uid, **kwargs)  # noqa: E501
            return data

    def update_template_input_using_put_with_http_info(self, body, cluster_id, input_type, uid, **kwargs):  # noqa: E501
        """updateTemplateInput  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_template_input_using_put_with_http_info(body, cluster_id, input_type, uid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param StackTemplateInput body: templateInput (required)
        :param str cluster_id: clusterId (required)
        :param str input_type: inputType (required)
        :param str uid: uid (required)
        :return: StackTemplateInput
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'cluster_id', 'input_type', 'uid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_template_input_using_put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_template_input_using_put`")  # noqa: E501
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params or
                params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `update_template_input_using_put`")  # noqa: E501
        # verify the required parameter 'input_type' is set
        if ('input_type' not in params or
                params['input_type'] is None):
            raise ValueError("Missing the required parameter `input_type` when calling `update_template_input_using_put`")  # noqa: E501
        # verify the required parameter 'uid' is set
        if ('uid' not in params or
                params['uid'] is None):
            raise ValueError("Missing the required parameter `uid` when calling `update_template_input_using_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['clusterId'] = params['cluster_id']  # noqa: E501
        if 'input_type' in params:
            path_params['inputType'] = params['input_type']  # noqa: E501
        if 'uid' in params:
            path_params['uid'] = params['uid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['main']  # noqa: E501

        return self.api_client.call_api(
            '/cc-ui/v1/clusters/{clusterId}/templateInputs/{inputType}/items/{uid}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StackTemplateInput',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def upsert_provided_resources_using_post(self, body, cluster_id, **kwargs):  # noqa: E501
        """upsertProvidedResources  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upsert_provided_resources_using_post(body, cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ProvidedResources body: providedResources (required)
        :param str cluster_id: clusterId (required)
        :return: ProvidedResources
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.upsert_provided_resources_using_post_with_http_info(body, cluster_id, **kwargs)  # noqa: E501
        else:
            (data) = self.upsert_provided_resources_using_post_with_http_info(body, cluster_id, **kwargs)  # noqa: E501
            return data

    def upsert_provided_resources_using_post_with_http_info(self, body, cluster_id, **kwargs):  # noqa: E501
        """upsertProvidedResources  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upsert_provided_resources_using_post_with_http_info(body, cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ProvidedResources body: providedResources (required)
        :param str cluster_id: clusterId (required)
        :return: ProvidedResources
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'cluster_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method upsert_provided_resources_using_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `upsert_provided_resources_using_post`")  # noqa: E501
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params or
                params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `upsert_provided_resources_using_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['clusterId'] = params['cluster_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['main']  # noqa: E501

        return self.api_client.call_api(
            '/cc-ui/v1/clusters/{clusterId}/providedResources', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ProvidedResources',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def upsert_vars_using_post1(self, body, cluster_id, **kwargs):  # noqa: E501
        """upsertVars  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upsert_vars_using_post1(body, cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param dict(str, str) body: clusterVars (required)
        :param str cluster_id: clusterId (required)
        :return: AbstractCluster
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.upsert_vars_using_post1_with_http_info(body, cluster_id, **kwargs)  # noqa: E501
        else:
            (data) = self.upsert_vars_using_post1_with_http_info(body, cluster_id, **kwargs)  # noqa: E501
            return data

    def upsert_vars_using_post1_with_http_info(self, body, cluster_id, **kwargs):  # noqa: E501
        """upsertVars  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upsert_vars_using_post1_with_http_info(body, cluster_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param dict(str, str) body: clusterVars (required)
        :param str cluster_id: clusterId (required)
        :return: AbstractCluster
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'cluster_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method upsert_vars_using_post1" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `upsert_vars_using_post1`")  # noqa: E501
        # verify the required parameter 'cluster_id' is set
        if ('cluster_id' not in params or
                params['cluster_id'] is None):
            raise ValueError("Missing the required parameter `cluster_id` when calling `upsert_vars_using_post1`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'cluster_id' in params:
            path_params['clusterId'] = params['cluster_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['main']  # noqa: E501

        return self.api_client.call_api(
            '/cc-ui/v1/clusters/{clusterId}/vars/upsert', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AbstractCluster',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
