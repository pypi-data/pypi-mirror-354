"use strict";
(self["webpackChunkpret"] = self["webpackChunkpret"] || []).push([["vendors-node_modules_valtio-yjs_dist_index_js"],{

/***/ "./node_modules/fast-deep-equal/index.js":
/*!***********************************************!*\
  !*** ./node_modules/fast-deep-equal/index.js ***!
  \***********************************************/
/***/ ((module) => {



// do not edit .js files directly - edit src/index.jst



module.exports = function equal(a, b) {
  if (a === b) return true;

  if (a && b && typeof a == 'object' && typeof b == 'object') {
    if (a.constructor !== b.constructor) return false;

    var length, i, keys;
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0;)
        if (!equal(a[i], b[i])) return false;
      return true;
    }



    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();

    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) return false;

    for (i = length; i-- !== 0;)
      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;

    for (i = length; i-- !== 0;) {
      var key = keys[i];

      if (!equal(a[key], b[key])) return false;
    }

    return true;
  }

  // true if both NaN, false otherwise
  return a!==a && b!==b;
};


/***/ }),

/***/ "./node_modules/valtio-yjs/dist/index.js":
/*!***********************************************!*\
  !*** ./node_modules/valtio-yjs/dist/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bind: () => (/* binding */ bind)
/* harmony export */ });
/* harmony import */ var valtio_vanilla__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! valtio/vanilla */ "./node_modules/valtio/esm/vanilla.mjs");
/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! yjs */ "webpack/sharing/consume/default/yjs");
/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(yjs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var fast_deep_equal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fast-deep-equal */ "./node_modules/fast-deep-equal/index.js");
/* harmony import */ var fast_deep_equal__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(fast_deep_equal__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _parseProxyOps_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./parseProxyOps.js */ "./node_modules/valtio-yjs/dist/parseProxyOps.js");
/* eslint @typescript-eslint/no-explicit-any: "off" */




const isProxyObject = (x) => typeof x === 'object' && x !== null && (0,valtio_vanilla__WEBPACK_IMPORTED_MODULE_2__.getVersion)(x) !== undefined;
const isProxyArray = (x) => Array.isArray(x) && (0,valtio_vanilla__WEBPACK_IMPORTED_MODULE_2__.getVersion)(x) !== undefined;
const isPrimitiveMapValue = (v) => v === null ||
    typeof v === 'string' ||
    typeof v === 'number' ||
    typeof v === 'boolean';
const transact = (doc, opts, fn) => {
    if (doc) {
        doc.transact(fn, opts.transactionOrigin);
    }
    else {
        fn();
    }
};
const toYValue = (val) => {
    if (isProxyArray(val)) {
        const arr = new yjs__WEBPACK_IMPORTED_MODULE_0__.Array();
        arr.insert(0, val.map(toYValue).filter((v) => v !== undefined && v !== null));
        return arr;
    }
    if (isProxyObject(val)) {
        const map = new yjs__WEBPACK_IMPORTED_MODULE_0__.Map();
        Object.entries(val).forEach(([key, value]) => {
            const v = toYValue(value);
            if (v !== undefined) {
                map.set(key, v);
            }
        });
        return map;
    }
    if (isPrimitiveMapValue(val)) {
        return val;
    }
    return undefined;
};
const toJSON = (yv) => {
    if (yv instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.AbstractType) {
        return yv.toJSON();
    }
    return yv;
};
const getNestedValues = (p, y, path) => {
    let pv = p;
    let yv = y;
    for (let i = 0; i < path.length; i += 1) {
        const k = path[i];
        if (yv instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.Map) {
            // child may already be deleted
            if (!pv)
                break;
            pv = pv[k];
            yv = yv.get(k);
        }
        else if (yv instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.Array) {
            // child may already be deleted
            if (!pv)
                break;
            const index = Number(k);
            pv = pv[k];
            yv = yv.get(index);
        }
        else {
            pv = null;
            yv = null;
        }
    }
    return { p: pv, y: yv };
};
function bind(p, y, opts = {}) {
    if (isProxyArray(p) && !(y instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.Array)) {
        if (true) {
            console.warn('proxy not same type');
        }
    }
    if (isProxyObject(p) && !isProxyArray(p) && !(y instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.Map)) {
        if (true) {
            console.warn('proxy not same type');
        }
    }
    // initialize from y
    initializeFromY(p, y);
    // initialize from p
    initializeFromP(p, y, opts);
    if (isProxyArray(p) && y instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.Array) {
        p.splice(y.length);
    }
    // subscribe p
    const unsubscribeP = subscribeP(p, y, opts);
    // subscribe y
    const unsubscribeY = subscribeY(y, p);
    return () => {
        unsubscribeP();
        unsubscribeY();
    };
}
function initializeFromP(p, y, opts) {
    transact(y.doc, opts, () => {
        if (isProxyObject(p) && y instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.Map) {
            Object.entries(p).forEach(([k, pv]) => {
                const yv = y.get(k);
                if (!fast_deep_equal__WEBPACK_IMPORTED_MODULE_1___default()(pv, toJSON(yv))) {
                    insertPValueToY(pv, y, k);
                }
            });
        }
        if (isProxyArray(p) && y instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.Array) {
            p.forEach((pv, i) => {
                const yv = y.get(i);
                if (!fast_deep_equal__WEBPACK_IMPORTED_MODULE_1___default()(pv, toJSON(yv))) {
                    insertPValueToY(pv, y, i);
                }
            });
        }
    });
}
function initializeFromY(p, y) {
    if (isProxyObject(p) && y instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.Map) {
        y.forEach((yv, k) => {
            if (!fast_deep_equal__WEBPACK_IMPORTED_MODULE_1___default()(p[k], toJSON(yv))) {
                p[k] = toJSON(yv);
            }
        });
    }
    if (isProxyArray(p) && y instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.Array) {
        y.forEach((yv, i) => {
            if (!fast_deep_equal__WEBPACK_IMPORTED_MODULE_1___default()(p[i], toJSON(yv))) {
                insertYValueToP(yv, p, i);
            }
        });
    }
}
function insertPValueToY(pv, y, k) {
    const yv = toYValue(pv);
    if (yv === undefined && "development" !== 'production') {
        console.warn('unsupported p type', pv);
        return;
    }
    if (y instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.Map && typeof k === 'string') {
        y.set(k, yv);
    }
    else if (y instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.Array && typeof k === 'number') {
        y.insert(k, [yv]);
    }
}
function insertYValueToP(yv, p, k) {
    if (isProxyObject(p) && typeof k === 'string') {
        p[k] = toJSON(yv);
    }
    else if (isProxyArray(p) && typeof k === 'number') {
        p.splice(k, 0, toJSON(yv));
    }
}
function subscribeP(p, y, opts) {
    return (0,valtio_vanilla__WEBPACK_IMPORTED_MODULE_2__.subscribe)(p, (ops) => {
        transact(y.doc, opts, () => {
            ops.forEach((op) => {
                const path = op[1].slice(0, -1);
                const k = op[1][op[1].length - 1];
                const parent = getNestedValues(p, y, path);
                if (parent.y instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.Map) {
                    if (op[0] === 'delete') {
                        parent.y.delete(k);
                    }
                    else if (op[0] === 'set') {
                        const pv = parent.p[k];
                        const yv = parent.y.get(k);
                        if (!fast_deep_equal__WEBPACK_IMPORTED_MODULE_1___default()(toJSON(yv), pv)) {
                            insertPValueToY(pv, parent.y, k);
                        }
                    }
                }
                else if (parent.y instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.Array) {
                    if (fast_deep_equal__WEBPACK_IMPORTED_MODULE_1___default()(toJSON(parent.y), parent.p)) {
                        return;
                    }
                    const arrayOps = (0,_parseProxyOps_js__WEBPACK_IMPORTED_MODULE_3__.parseProxyOps)(ops);
                    arrayOps.forEach((aOp) => {
                        const i = aOp[1];
                        if (aOp[0] === 'delete') {
                            if (parent.y.length > i) {
                                parent.y.delete(i, 1);
                            }
                            return;
                        }
                        const pv = parent.p[i];
                        if (pv === undefined) {
                            return;
                        }
                        if (aOp[0] === 'set') {
                            if (parent.y.length > i) {
                                parent.y.delete(i, 1);
                            }
                            insertPValueToY(pv, parent.y, i);
                        }
                        else if (aOp[0] === 'insert') {
                            insertPValueToY(pv, parent.y, i);
                        }
                    });
                }
            });
        });
    });
}
function subscribeY(y, p) {
    const observer = (events) => {
        events.forEach((event) => {
            const path = event.path;
            const parent = getNestedValues(p, y, path);
            if (parent.y instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.Map) {
                event.changes.keys.forEach((item, k) => {
                    if (item.action === 'delete') {
                        delete parent.p[k];
                    }
                    else {
                        const yv = parent.y.get(k);
                        insertYValueToP(yv, parent.p, k);
                    }
                });
            }
            else if (parent.y instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.Array) {
                if (fast_deep_equal__WEBPACK_IMPORTED_MODULE_1___default()(parent.p, toJSON(parent.y))) {
                    return;
                }
                let retain = 0;
                event.changes.delta.forEach((item) => {
                    if (item.retain) {
                        retain += item.retain;
                    }
                    if (item.delete) {
                        parent.p.splice(retain, item.delete);
                    }
                    if (item.insert) {
                        if (Array.isArray(item.insert)) {
                            item.insert.forEach((yv, i) => {
                                insertYValueToP(yv, parent.p, retain + i);
                            });
                        }
                        else {
                            insertYValueToP(item.insert, parent.p, retain);
                        }
                        retain += item.insert.length;
                    }
                });
            }
        });
    };
    y.observeDeep(observer);
    return () => {
        y.unobserveDeep(observer);
    };
}


/***/ }),

/***/ "./node_modules/valtio-yjs/dist/parseProxyOps.js":
/*!*******************************************************!*\
  !*** ./node_modules/valtio-yjs/dist/parseProxyOps.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parseProxyOps: () => (/* binding */ parseProxyOps)
/* harmony export */ });

const parseProxyOps = (ops) => {
    const arrayOps = ops.flatMap((op) => {
        if (op[0] === 'resolve' || op[0] === 'reject')
            return [];
        const index = Number(op[1][op[1].length - 1]);
        if (!Number.isFinite(index))
            return [];
        return [[op[0], index, op[2], op[3]]];
    });
    const findCorrespondingInsert = (startOpIndex, startArrayIndex) => {
        let s = 0;
        let noInsert = null;
        while (startOpIndex + s + 1 < arrayOps.length) {
            if ((arrayOps[startOpIndex + s + 1][0] === 'set' ||
                arrayOps[startOpIndex + s + 1][0] === 'insert') &&
                arrayOps[startOpIndex + s + 1][1] < startArrayIndex &&
                arrayOps[startOpIndex + s + 1][3] === arrayOps[startOpIndex][2]) {
                return s + 1;
            }
            if (noInsert === null &&
                (arrayOps[startOpIndex + s + 1][0] === 'set' ||
                    arrayOps[startOpIndex + s + 1][0] === 'insert') &&
                arrayOps[startOpIndex + s + 1][1] === startArrayIndex - (s + 1) &&
                arrayOps[startOpIndex + s + 1][3] === undefined) {
                s += 1;
            }
            else if (noInsert === null &&
                startOpIndex + s + 1 < arrayOps.length &&
                arrayOps[startOpIndex + s + 1][0] === 'set' &&
                arrayOps[startOpIndex + s + 1][3] !== undefined) {
                noInsert = [startOpIndex + s + 1, arrayOps[startOpIndex + s + 1][1]];
                s += 1;
            }
            else if (noInsert !== null &&
                arrayOps[startOpIndex + s + 1][0] === 'set' &&
                arrayOps[startOpIndex + s + 1][1] ===
                    noInsert[1] + (s + 1 - noInsert[0]) &&
                arrayOps[startOpIndex + s + 1][3] !== undefined) {
                s += 1;
            }
            else {
                return null;
            }
        }
        return null;
    };
    const findContinuousDelete = (startOpIndex, startArrayIndex) => {
        let d = 0;
        while (startOpIndex + d + 1 < arrayOps.length &&
            arrayOps[startOpIndex + d + 1][0] === 'delete' &&
            arrayOps[startOpIndex + d + 1][1] === startArrayIndex - (d + 1)) {
            d += 1;
        }
        return d;
    };
    let i = 0;
    while (i < arrayOps.length) {
        if ((arrayOps[i][0] === 'set' || arrayOps[i][0] === 'insert') &&
            arrayOps[i][3] === undefined) {
            const startArrayIndex = arrayOps[i][1];
            const s = findCorrespondingInsert(i, startArrayIndex);
            if (s !== null) {
                const newArrayOp = [
                    'insert',
                    arrayOps[i + s][1],
                    arrayOps[i + s][2],
                    undefined,
                ];
                arrayOps.splice(i + s, 1, newArrayOp);
                arrayOps.splice(i, 1);
            }
            else {
                i += 1;
            }
        }
        else if (i > 0 && arrayOps[i][0] === 'delete') {
            const startArrayIndex = arrayOps[i][1];
            const d = findContinuousDelete(i, startArrayIndex);
            if (arrayOps[i - 1][0] === 'set' &&
                arrayOps[i - 1][1] === startArrayIndex - (d + 1) &&
                arrayOps[i - 1][2] === arrayOps[i][2]) {
                const newArrayOp = [
                    'delete',
                    startArrayIndex - (d + 1),
                    arrayOps[i - 1][3],
                    undefined,
                ];
                arrayOps.splice(i - 1, 2);
                arrayOps.splice(i - 1 + d, 0, newArrayOp);
                i -= 1;
            }
            else {
                i += 1;
            }
        }
        else {
            i += 1;
        }
    }
    return arrayOps;
};


/***/ }),

/***/ "./node_modules/valtio/esm/vanilla.mjs":
/*!*********************************************!*\
  !*** ./node_modules/valtio/esm/vanilla.mjs ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getVersion: () => (/* binding */ getVersion),
/* harmony export */   proxy: () => (/* binding */ proxy),
/* harmony export */   ref: () => (/* binding */ ref),
/* harmony export */   snapshot: () => (/* binding */ snapshot),
/* harmony export */   subscribe: () => (/* binding */ subscribe),
/* harmony export */   unstable_getInternalStates: () => (/* binding */ unstable_getInternalStates),
/* harmony export */   unstable_replaceInternalFunction: () => (/* binding */ unstable_replaceInternalFunction)
/* harmony export */ });
/* harmony import */ var proxy_compare__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! proxy-compare */ "./node_modules/proxy-compare/dist/index.js");


const isObject = (x) => typeof x === "object" && x !== null;
const canProxyDefault = (x) => isObject(x) && !refSet.has(x) && (Array.isArray(x) || !(Symbol.iterator in x)) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer) && !(x instanceof Promise);
const createSnapshotDefault = (target, version) => {
  const cache = snapCache.get(target);
  if ((cache == null ? void 0 : cache[0]) === version) {
    return cache[1];
  }
  const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
  (0,proxy_compare__WEBPACK_IMPORTED_MODULE_0__.markToTrack)(snap, true);
  snapCache.set(target, [version, snap]);
  Reflect.ownKeys(target).forEach((key) => {
    if (Object.getOwnPropertyDescriptor(snap, key)) {
      return;
    }
    const value = Reflect.get(target, key);
    const { enumerable } = Reflect.getOwnPropertyDescriptor(
      target,
      key
    );
    const desc = {
      value,
      enumerable,
      // This is intentional to avoid copying with proxy-compare.
      // It's still non-writable, so it avoids assigning a value.
      configurable: true
    };
    if (refSet.has(value)) {
      (0,proxy_compare__WEBPACK_IMPORTED_MODULE_0__.markToTrack)(value, false);
    } else if (proxyStateMap.has(value)) {
      const [target2, ensureVersion] = proxyStateMap.get(
        value
      );
      desc.value = createSnapshotDefault(target2, ensureVersion());
    }
    Object.defineProperty(snap, key, desc);
  });
  return Object.preventExtensions(snap);
};
const createHandlerDefault = (isInitializing, addPropListener, removePropListener, notifyUpdate) => ({
  deleteProperty(target, prop) {
    const prevValue = Reflect.get(target, prop);
    removePropListener(prop);
    const deleted = Reflect.deleteProperty(target, prop);
    if (deleted) {
      notifyUpdate(["delete", [prop], prevValue]);
    }
    return deleted;
  },
  set(target, prop, value, receiver) {
    const hasPrevValue = !isInitializing() && Reflect.has(target, prop);
    const prevValue = Reflect.get(target, prop, receiver);
    if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) {
      return true;
    }
    removePropListener(prop);
    if (isObject(value)) {
      value = (0,proxy_compare__WEBPACK_IMPORTED_MODULE_0__.getUntracked)(value) || value;
    }
    const nextValue = !proxyStateMap.has(value) && canProxy(value) ? proxy(value) : value;
    addPropListener(prop, nextValue);
    Reflect.set(target, prop, nextValue, receiver);
    notifyUpdate(["set", [prop], value, prevValue]);
    return true;
  }
});
const proxyStateMap = /* @__PURE__ */ new WeakMap();
const refSet = /* @__PURE__ */ new WeakSet();
const snapCache = /* @__PURE__ */ new WeakMap();
const versionHolder = [1, 1];
const proxyCache = /* @__PURE__ */ new WeakMap();
let objectIs = Object.is;
let newProxy = (target, handler) => new Proxy(target, handler);
let canProxy = canProxyDefault;
let createSnapshot = createSnapshotDefault;
let createHandler = createHandlerDefault;
function proxy(baseObject = {}) {
  if (!isObject(baseObject)) {
    throw new Error("object required");
  }
  const found = proxyCache.get(baseObject);
  if (found) {
    return found;
  }
  let version = versionHolder[0];
  const listeners = /* @__PURE__ */ new Set();
  const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {
    if (version !== nextVersion) {
      version = nextVersion;
      listeners.forEach((listener) => listener(op, nextVersion));
    }
  };
  let checkVersion = versionHolder[1];
  const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {
    if (checkVersion !== nextCheckVersion && !listeners.size) {
      checkVersion = nextCheckVersion;
      propProxyStates.forEach(([propProxyState]) => {
        const propVersion = propProxyState[1](nextCheckVersion);
        if (propVersion > version) {
          version = propVersion;
        }
      });
    }
    return version;
  };
  const createPropListener = (prop) => (op, nextVersion) => {
    const newOp = [...op];
    newOp[1] = [prop, ...newOp[1]];
    notifyUpdate(newOp, nextVersion);
  };
  const propProxyStates = /* @__PURE__ */ new Map();
  const addPropListener = (prop, propValue) => {
    const propProxyState = !refSet.has(propValue) && proxyStateMap.get(propValue);
    if (propProxyState) {
      if (( false ? 0 : void 0) !== "production" && propProxyStates.has(prop)) {
        throw new Error("prop listener already exists");
      }
      if (listeners.size) {
        const remove = propProxyState[2](createPropListener(prop));
        propProxyStates.set(prop, [propProxyState, remove]);
      } else {
        propProxyStates.set(prop, [propProxyState]);
      }
    }
  };
  const removePropListener = (prop) => {
    var _a;
    const entry = propProxyStates.get(prop);
    if (entry) {
      propProxyStates.delete(prop);
      (_a = entry[1]) == null ? void 0 : _a.call(entry);
    }
  };
  const addListener = (listener) => {
    listeners.add(listener);
    if (listeners.size === 1) {
      propProxyStates.forEach(([propProxyState, prevRemove], prop) => {
        if (( false ? 0 : void 0) !== "production" && prevRemove) {
          throw new Error("remove already exists");
        }
        const remove = propProxyState[2](createPropListener(prop));
        propProxyStates.set(prop, [propProxyState, remove]);
      });
    }
    const removeListener = () => {
      listeners.delete(listener);
      if (listeners.size === 0) {
        propProxyStates.forEach(([propProxyState, remove], prop) => {
          if (remove) {
            remove();
            propProxyStates.set(prop, [propProxyState]);
          }
        });
      }
    };
    return removeListener;
  };
  let initializing = true;
  const handler = createHandler(
    () => initializing,
    addPropListener,
    removePropListener,
    notifyUpdate
  );
  const proxyObject = newProxy(baseObject, handler);
  proxyCache.set(baseObject, proxyObject);
  const proxyState = [baseObject, ensureVersion, addListener];
  proxyStateMap.set(proxyObject, proxyState);
  Reflect.ownKeys(baseObject).forEach((key) => {
    const desc = Object.getOwnPropertyDescriptor(
      baseObject,
      key
    );
    if ("value" in desc && desc.writable) {
      proxyObject[key] = baseObject[key];
    }
  });
  initializing = false;
  return proxyObject;
}
function getVersion(proxyObject) {
  const proxyState = proxyStateMap.get(proxyObject);
  return proxyState == null ? void 0 : proxyState[1]();
}
function subscribe(proxyObject, callback, notifyInSync) {
  const proxyState = proxyStateMap.get(proxyObject);
  if (( false ? 0 : void 0) !== "production" && !proxyState) {
    console.warn("Please use proxy object");
  }
  let promise;
  const ops = [];
  const addListener = proxyState[2];
  let isListenerActive = false;
  const listener = (op) => {
    ops.push(op);
    if (notifyInSync) {
      callback(ops.splice(0));
      return;
    }
    if (!promise) {
      promise = Promise.resolve().then(() => {
        promise = void 0;
        if (isListenerActive) {
          callback(ops.splice(0));
        }
      });
    }
  };
  const removeListener = addListener(listener);
  isListenerActive = true;
  return () => {
    isListenerActive = false;
    removeListener();
  };
}
function snapshot(proxyObject) {
  const proxyState = proxyStateMap.get(proxyObject);
  if (( false ? 0 : void 0) !== "production" && !proxyState) {
    console.warn("Please use proxy object");
  }
  const [target, ensureVersion] = proxyState;
  return createSnapshot(target, ensureVersion());
}
function ref(obj) {
  refSet.add(obj);
  return obj;
}
function unstable_getInternalStates() {
  return {
    proxyStateMap,
    refSet,
    snapCache,
    versionHolder,
    proxyCache
  };
}
function unstable_replaceInternalFunction(name, fn) {
  switch (name) {
    case "objectIs":
      objectIs = fn(objectIs);
      break;
    case "newProxy":
      newProxy = fn(newProxy);
      break;
    case "canProxy":
      canProxy = fn(canProxy);
      break;
    case "createSnapshot":
      createSnapshot = fn(createSnapshot);
      break;
    case "createHandler":
      createHandler = fn(createHandler);
      break;
    default:
      throw new Error("unknown function");
  }
}




/***/ })

}]);
//# sourceMappingURL=vendors-node_modules_valtio-yjs_dist_index_js.847ed5a07dd273859f71.js.map