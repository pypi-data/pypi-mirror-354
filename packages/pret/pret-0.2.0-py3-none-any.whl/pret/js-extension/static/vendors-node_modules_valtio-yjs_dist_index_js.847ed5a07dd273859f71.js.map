{"version":3,"file":"vendors-node_modules_valtio-yjs_dist_index_js.847ed5a07dd273859f71.js","mappings":";;;;;;;;;AAAa;;AAEb;;;;AAIA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,uBAAuB,UAAU;AACjC;AACA;AACA;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,UAAU;AAC/B;;AAEA,qBAAqB,UAAU;AAC/B;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AC7CA;AACuD;AAC9B;AACe;AACW;AACnD,oEAAoE,0DAAU;AAC9E,gDAAgD,0DAAU;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sCAAO;AAC/B;AACA;AACA;AACA;AACA,wBAAwB,oCAAK;AAC7B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,6CAAc;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA,0BAA0B,oCAAK;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,sCAAO;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACO,6BAA6B;AACpC,0CAA0C,sCAAO;AACjD,YAAY,IAAqC;AACjD;AACA;AACA;AACA,+DAA+D,oCAAK;AACpE,YAAY,IAAqC;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,sCAAO;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,oCAAK;AAClD;AACA;AACA,qBAAqB,sDAAS;AAC9B;AACA;AACA,aAAa;AACb;AACA,4CAA4C,sCAAO;AACnD;AACA;AACA,qBAAqB,sDAAS;AAC9B;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;AACA,yCAAyC,oCAAK;AAC9C;AACA,iBAAiB,sDAAS;AAC1B;AACA;AACA,SAAS;AACT;AACA,wCAAwC,sCAAO;AAC/C;AACA,iBAAiB,sDAAS;AAC1B;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,4BAA4B,aAAoB;AAChD;AACA;AACA;AACA,qBAAqB,oCAAK;AAC1B;AACA;AACA,0BAA0B,sCAAO;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,yDAAS;AACpB;AACA;AACA;AACA;AACA;AACA,wCAAwC,oCAAK;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,sDAAS;AACtC;AACA;AACA;AACA;AACA,6CAA6C,sCAAO;AACpD,wBAAwB,sDAAS;AACjC;AACA;AACA,qCAAqC,gEAAa;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,oCAAK;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,yCAAyC,sCAAO;AAChD,oBAAoB,sDAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC/P2C;AACpC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACrG0D;;AAE1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,0DAAW;AACb;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,0DAAW;AACjB,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,2DAAY;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAe,GAAG,CAAoB;AACjD;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAe,GAAG,CAAoB;AACnD;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAe,GAAG,CAAoB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAe,GAAG,CAAoB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEqH","sources":["webpack://pret/./node_modules/fast-deep-equal/index.js","webpack://pret/./node_modules/valtio-yjs/dist/index.js","webpack://pret/./node_modules/valtio-yjs/dist/parseProxyOps.js","webpack://pret/./node_modules/valtio/esm/vanilla.mjs"],"sourcesContent":["'use strict';\n\n// do not edit .js files directly - edit src/index.jst\n\n\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n","/* eslint @typescript-eslint/no-explicit-any: \"off\" */\nimport { subscribe, getVersion } from 'valtio/vanilla';\nimport * as Y from 'yjs';\nimport deepEqual from 'fast-deep-equal';\nimport { parseProxyOps } from './parseProxyOps.js';\nconst isProxyObject = (x) => typeof x === 'object' && x !== null && getVersion(x) !== undefined;\nconst isProxyArray = (x) => Array.isArray(x) && getVersion(x) !== undefined;\nconst isPrimitiveMapValue = (v) => v === null ||\n    typeof v === 'string' ||\n    typeof v === 'number' ||\n    typeof v === 'boolean';\nconst transact = (doc, opts, fn) => {\n    if (doc) {\n        doc.transact(fn, opts.transactionOrigin);\n    }\n    else {\n        fn();\n    }\n};\nconst toYValue = (val) => {\n    if (isProxyArray(val)) {\n        const arr = new Y.Array();\n        arr.insert(0, val.map(toYValue).filter((v) => v !== undefined && v !== null));\n        return arr;\n    }\n    if (isProxyObject(val)) {\n        const map = new Y.Map();\n        Object.entries(val).forEach(([key, value]) => {\n            const v = toYValue(value);\n            if (v !== undefined) {\n                map.set(key, v);\n            }\n        });\n        return map;\n    }\n    if (isPrimitiveMapValue(val)) {\n        return val;\n    }\n    return undefined;\n};\nconst toJSON = (yv) => {\n    if (yv instanceof Y.AbstractType) {\n        return yv.toJSON();\n    }\n    return yv;\n};\nconst getNestedValues = (p, y, path) => {\n    let pv = p;\n    let yv = y;\n    for (let i = 0; i < path.length; i += 1) {\n        const k = path[i];\n        if (yv instanceof Y.Map) {\n            // child may already be deleted\n            if (!pv)\n                break;\n            pv = pv[k];\n            yv = yv.get(k);\n        }\n        else if (yv instanceof Y.Array) {\n            // child may already be deleted\n            if (!pv)\n                break;\n            const index = Number(k);\n            pv = pv[k];\n            yv = yv.get(index);\n        }\n        else {\n            pv = null;\n            yv = null;\n        }\n    }\n    return { p: pv, y: yv };\n};\nexport function bind(p, y, opts = {}) {\n    if (isProxyArray(p) && !(y instanceof Y.Array)) {\n        if (process.env.NODE_ENV !== 'production') {\n            console.warn('proxy not same type');\n        }\n    }\n    if (isProxyObject(p) && !isProxyArray(p) && !(y instanceof Y.Map)) {\n        if (process.env.NODE_ENV !== 'production') {\n            console.warn('proxy not same type');\n        }\n    }\n    // initialize from y\n    initializeFromY(p, y);\n    // initialize from p\n    initializeFromP(p, y, opts);\n    if (isProxyArray(p) && y instanceof Y.Array) {\n        p.splice(y.length);\n    }\n    // subscribe p\n    const unsubscribeP = subscribeP(p, y, opts);\n    // subscribe y\n    const unsubscribeY = subscribeY(y, p);\n    return () => {\n        unsubscribeP();\n        unsubscribeY();\n    };\n}\nfunction initializeFromP(p, y, opts) {\n    transact(y.doc, opts, () => {\n        if (isProxyObject(p) && y instanceof Y.Map) {\n            Object.entries(p).forEach(([k, pv]) => {\n                const yv = y.get(k);\n                if (!deepEqual(pv, toJSON(yv))) {\n                    insertPValueToY(pv, y, k);\n                }\n            });\n        }\n        if (isProxyArray(p) && y instanceof Y.Array) {\n            p.forEach((pv, i) => {\n                const yv = y.get(i);\n                if (!deepEqual(pv, toJSON(yv))) {\n                    insertPValueToY(pv, y, i);\n                }\n            });\n        }\n    });\n}\nfunction initializeFromY(p, y) {\n    if (isProxyObject(p) && y instanceof Y.Map) {\n        y.forEach((yv, k) => {\n            if (!deepEqual(p[k], toJSON(yv))) {\n                p[k] = toJSON(yv);\n            }\n        });\n    }\n    if (isProxyArray(p) && y instanceof Y.Array) {\n        y.forEach((yv, i) => {\n            if (!deepEqual(p[i], toJSON(yv))) {\n                insertYValueToP(yv, p, i);\n            }\n        });\n    }\n}\nfunction insertPValueToY(pv, y, k) {\n    const yv = toYValue(pv);\n    if (yv === undefined && process.env.NODE_ENV !== 'production') {\n        console.warn('unsupported p type', pv);\n        return;\n    }\n    if (y instanceof Y.Map && typeof k === 'string') {\n        y.set(k, yv);\n    }\n    else if (y instanceof Y.Array && typeof k === 'number') {\n        y.insert(k, [yv]);\n    }\n}\nfunction insertYValueToP(yv, p, k) {\n    if (isProxyObject(p) && typeof k === 'string') {\n        p[k] = toJSON(yv);\n    }\n    else if (isProxyArray(p) && typeof k === 'number') {\n        p.splice(k, 0, toJSON(yv));\n    }\n}\nfunction subscribeP(p, y, opts) {\n    return subscribe(p, (ops) => {\n        transact(y.doc, opts, () => {\n            ops.forEach((op) => {\n                const path = op[1].slice(0, -1);\n                const k = op[1][op[1].length - 1];\n                const parent = getNestedValues(p, y, path);\n                if (parent.y instanceof Y.Map) {\n                    if (op[0] === 'delete') {\n                        parent.y.delete(k);\n                    }\n                    else if (op[0] === 'set') {\n                        const pv = parent.p[k];\n                        const yv = parent.y.get(k);\n                        if (!deepEqual(toJSON(yv), pv)) {\n                            insertPValueToY(pv, parent.y, k);\n                        }\n                    }\n                }\n                else if (parent.y instanceof Y.Array) {\n                    if (deepEqual(toJSON(parent.y), parent.p)) {\n                        return;\n                    }\n                    const arrayOps = parseProxyOps(ops);\n                    arrayOps.forEach((aOp) => {\n                        const i = aOp[1];\n                        if (aOp[0] === 'delete') {\n                            if (parent.y.length > i) {\n                                parent.y.delete(i, 1);\n                            }\n                            return;\n                        }\n                        const pv = parent.p[i];\n                        if (pv === undefined) {\n                            return;\n                        }\n                        if (aOp[0] === 'set') {\n                            if (parent.y.length > i) {\n                                parent.y.delete(i, 1);\n                            }\n                            insertPValueToY(pv, parent.y, i);\n                        }\n                        else if (aOp[0] === 'insert') {\n                            insertPValueToY(pv, parent.y, i);\n                        }\n                    });\n                }\n            });\n        });\n    });\n}\nfunction subscribeY(y, p) {\n    const observer = (events) => {\n        events.forEach((event) => {\n            const path = event.path;\n            const parent = getNestedValues(p, y, path);\n            if (parent.y instanceof Y.Map) {\n                event.changes.keys.forEach((item, k) => {\n                    if (item.action === 'delete') {\n                        delete parent.p[k];\n                    }\n                    else {\n                        const yv = parent.y.get(k);\n                        insertYValueToP(yv, parent.p, k);\n                    }\n                });\n            }\n            else if (parent.y instanceof Y.Array) {\n                if (deepEqual(parent.p, toJSON(parent.y))) {\n                    return;\n                }\n                let retain = 0;\n                event.changes.delta.forEach((item) => {\n                    if (item.retain) {\n                        retain += item.retain;\n                    }\n                    if (item.delete) {\n                        parent.p.splice(retain, item.delete);\n                    }\n                    if (item.insert) {\n                        if (Array.isArray(item.insert)) {\n                            item.insert.forEach((yv, i) => {\n                                insertYValueToP(yv, parent.p, retain + i);\n                            });\n                        }\n                        else {\n                            insertYValueToP(item.insert, parent.p, retain);\n                        }\n                        retain += item.insert.length;\n                    }\n                });\n            }\n        });\n    };\n    y.observeDeep(observer);\n    return () => {\n        y.unobserveDeep(observer);\n    };\n}\n","import { subscribe } from 'valtio/vanilla';\nexport const parseProxyOps = (ops) => {\n    const arrayOps = ops.flatMap((op) => {\n        if (op[0] === 'resolve' || op[0] === 'reject')\n            return [];\n        const index = Number(op[1][op[1].length - 1]);\n        if (!Number.isFinite(index))\n            return [];\n        return [[op[0], index, op[2], op[3]]];\n    });\n    const findCorrespondingInsert = (startOpIndex, startArrayIndex) => {\n        let s = 0;\n        let noInsert = null;\n        while (startOpIndex + s + 1 < arrayOps.length) {\n            if ((arrayOps[startOpIndex + s + 1][0] === 'set' ||\n                arrayOps[startOpIndex + s + 1][0] === 'insert') &&\n                arrayOps[startOpIndex + s + 1][1] < startArrayIndex &&\n                arrayOps[startOpIndex + s + 1][3] === arrayOps[startOpIndex][2]) {\n                return s + 1;\n            }\n            if (noInsert === null &&\n                (arrayOps[startOpIndex + s + 1][0] === 'set' ||\n                    arrayOps[startOpIndex + s + 1][0] === 'insert') &&\n                arrayOps[startOpIndex + s + 1][1] === startArrayIndex - (s + 1) &&\n                arrayOps[startOpIndex + s + 1][3] === undefined) {\n                s += 1;\n            }\n            else if (noInsert === null &&\n                startOpIndex + s + 1 < arrayOps.length &&\n                arrayOps[startOpIndex + s + 1][0] === 'set' &&\n                arrayOps[startOpIndex + s + 1][3] !== undefined) {\n                noInsert = [startOpIndex + s + 1, arrayOps[startOpIndex + s + 1][1]];\n                s += 1;\n            }\n            else if (noInsert !== null &&\n                arrayOps[startOpIndex + s + 1][0] === 'set' &&\n                arrayOps[startOpIndex + s + 1][1] ===\n                    noInsert[1] + (s + 1 - noInsert[0]) &&\n                arrayOps[startOpIndex + s + 1][3] !== undefined) {\n                s += 1;\n            }\n            else {\n                return null;\n            }\n        }\n        return null;\n    };\n    const findContinuousDelete = (startOpIndex, startArrayIndex) => {\n        let d = 0;\n        while (startOpIndex + d + 1 < arrayOps.length &&\n            arrayOps[startOpIndex + d + 1][0] === 'delete' &&\n            arrayOps[startOpIndex + d + 1][1] === startArrayIndex - (d + 1)) {\n            d += 1;\n        }\n        return d;\n    };\n    let i = 0;\n    while (i < arrayOps.length) {\n        if ((arrayOps[i][0] === 'set' || arrayOps[i][0] === 'insert') &&\n            arrayOps[i][3] === undefined) {\n            const startArrayIndex = arrayOps[i][1];\n            const s = findCorrespondingInsert(i, startArrayIndex);\n            if (s !== null) {\n                const newArrayOp = [\n                    'insert',\n                    arrayOps[i + s][1],\n                    arrayOps[i + s][2],\n                    undefined,\n                ];\n                arrayOps.splice(i + s, 1, newArrayOp);\n                arrayOps.splice(i, 1);\n            }\n            else {\n                i += 1;\n            }\n        }\n        else if (i > 0 && arrayOps[i][0] === 'delete') {\n            const startArrayIndex = arrayOps[i][1];\n            const d = findContinuousDelete(i, startArrayIndex);\n            if (arrayOps[i - 1][0] === 'set' &&\n                arrayOps[i - 1][1] === startArrayIndex - (d + 1) &&\n                arrayOps[i - 1][2] === arrayOps[i][2]) {\n                const newArrayOp = [\n                    'delete',\n                    startArrayIndex - (d + 1),\n                    arrayOps[i - 1][3],\n                    undefined,\n                ];\n                arrayOps.splice(i - 1, 2);\n                arrayOps.splice(i - 1 + d, 0, newArrayOp);\n                i -= 1;\n            }\n            else {\n                i += 1;\n            }\n        }\n        else {\n            i += 1;\n        }\n    }\n    return arrayOps;\n};\n","import { markToTrack, getUntracked } from 'proxy-compare';\n\nconst isObject = (x) => typeof x === \"object\" && x !== null;\nconst canProxyDefault = (x) => isObject(x) && !refSet.has(x) && (Array.isArray(x) || !(Symbol.iterator in x)) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer) && !(x instanceof Promise);\nconst createSnapshotDefault = (target, version) => {\n  const cache = snapCache.get(target);\n  if ((cache == null ? void 0 : cache[0]) === version) {\n    return cache[1];\n  }\n  const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));\n  markToTrack(snap, true);\n  snapCache.set(target, [version, snap]);\n  Reflect.ownKeys(target).forEach((key) => {\n    if (Object.getOwnPropertyDescriptor(snap, key)) {\n      return;\n    }\n    const value = Reflect.get(target, key);\n    const { enumerable } = Reflect.getOwnPropertyDescriptor(\n      target,\n      key\n    );\n    const desc = {\n      value,\n      enumerable,\n      // This is intentional to avoid copying with proxy-compare.\n      // It's still non-writable, so it avoids assigning a value.\n      configurable: true\n    };\n    if (refSet.has(value)) {\n      markToTrack(value, false);\n    } else if (proxyStateMap.has(value)) {\n      const [target2, ensureVersion] = proxyStateMap.get(\n        value\n      );\n      desc.value = createSnapshotDefault(target2, ensureVersion());\n    }\n    Object.defineProperty(snap, key, desc);\n  });\n  return Object.preventExtensions(snap);\n};\nconst createHandlerDefault = (isInitializing, addPropListener, removePropListener, notifyUpdate) => ({\n  deleteProperty(target, prop) {\n    const prevValue = Reflect.get(target, prop);\n    removePropListener(prop);\n    const deleted = Reflect.deleteProperty(target, prop);\n    if (deleted) {\n      notifyUpdate([\"delete\", [prop], prevValue]);\n    }\n    return deleted;\n  },\n  set(target, prop, value, receiver) {\n    const hasPrevValue = !isInitializing() && Reflect.has(target, prop);\n    const prevValue = Reflect.get(target, prop, receiver);\n    if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) {\n      return true;\n    }\n    removePropListener(prop);\n    if (isObject(value)) {\n      value = getUntracked(value) || value;\n    }\n    const nextValue = !proxyStateMap.has(value) && canProxy(value) ? proxy(value) : value;\n    addPropListener(prop, nextValue);\n    Reflect.set(target, prop, nextValue, receiver);\n    notifyUpdate([\"set\", [prop], value, prevValue]);\n    return true;\n  }\n});\nconst proxyStateMap = /* @__PURE__ */ new WeakMap();\nconst refSet = /* @__PURE__ */ new WeakSet();\nconst snapCache = /* @__PURE__ */ new WeakMap();\nconst versionHolder = [1, 1];\nconst proxyCache = /* @__PURE__ */ new WeakMap();\nlet objectIs = Object.is;\nlet newProxy = (target, handler) => new Proxy(target, handler);\nlet canProxy = canProxyDefault;\nlet createSnapshot = createSnapshotDefault;\nlet createHandler = createHandlerDefault;\nfunction proxy(baseObject = {}) {\n  if (!isObject(baseObject)) {\n    throw new Error(\"object required\");\n  }\n  const found = proxyCache.get(baseObject);\n  if (found) {\n    return found;\n  }\n  let version = versionHolder[0];\n  const listeners = /* @__PURE__ */ new Set();\n  const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {\n    if (version !== nextVersion) {\n      version = nextVersion;\n      listeners.forEach((listener) => listener(op, nextVersion));\n    }\n  };\n  let checkVersion = versionHolder[1];\n  const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {\n    if (checkVersion !== nextCheckVersion && !listeners.size) {\n      checkVersion = nextCheckVersion;\n      propProxyStates.forEach(([propProxyState]) => {\n        const propVersion = propProxyState[1](nextCheckVersion);\n        if (propVersion > version) {\n          version = propVersion;\n        }\n      });\n    }\n    return version;\n  };\n  const createPropListener = (prop) => (op, nextVersion) => {\n    const newOp = [...op];\n    newOp[1] = [prop, ...newOp[1]];\n    notifyUpdate(newOp, nextVersion);\n  };\n  const propProxyStates = /* @__PURE__ */ new Map();\n  const addPropListener = (prop, propValue) => {\n    const propProxyState = !refSet.has(propValue) && proxyStateMap.get(propValue);\n    if (propProxyState) {\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && propProxyStates.has(prop)) {\n        throw new Error(\"prop listener already exists\");\n      }\n      if (listeners.size) {\n        const remove = propProxyState[2](createPropListener(prop));\n        propProxyStates.set(prop, [propProxyState, remove]);\n      } else {\n        propProxyStates.set(prop, [propProxyState]);\n      }\n    }\n  };\n  const removePropListener = (prop) => {\n    var _a;\n    const entry = propProxyStates.get(prop);\n    if (entry) {\n      propProxyStates.delete(prop);\n      (_a = entry[1]) == null ? void 0 : _a.call(entry);\n    }\n  };\n  const addListener = (listener) => {\n    listeners.add(listener);\n    if (listeners.size === 1) {\n      propProxyStates.forEach(([propProxyState, prevRemove], prop) => {\n        if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && prevRemove) {\n          throw new Error(\"remove already exists\");\n        }\n        const remove = propProxyState[2](createPropListener(prop));\n        propProxyStates.set(prop, [propProxyState, remove]);\n      });\n    }\n    const removeListener = () => {\n      listeners.delete(listener);\n      if (listeners.size === 0) {\n        propProxyStates.forEach(([propProxyState, remove], prop) => {\n          if (remove) {\n            remove();\n            propProxyStates.set(prop, [propProxyState]);\n          }\n        });\n      }\n    };\n    return removeListener;\n  };\n  let initializing = true;\n  const handler = createHandler(\n    () => initializing,\n    addPropListener,\n    removePropListener,\n    notifyUpdate\n  );\n  const proxyObject = newProxy(baseObject, handler);\n  proxyCache.set(baseObject, proxyObject);\n  const proxyState = [baseObject, ensureVersion, addListener];\n  proxyStateMap.set(proxyObject, proxyState);\n  Reflect.ownKeys(baseObject).forEach((key) => {\n    const desc = Object.getOwnPropertyDescriptor(\n      baseObject,\n      key\n    );\n    if (\"value\" in desc && desc.writable) {\n      proxyObject[key] = baseObject[key];\n    }\n  });\n  initializing = false;\n  return proxyObject;\n}\nfunction getVersion(proxyObject) {\n  const proxyState = proxyStateMap.get(proxyObject);\n  return proxyState == null ? void 0 : proxyState[1]();\n}\nfunction subscribe(proxyObject, callback, notifyInSync) {\n  const proxyState = proxyStateMap.get(proxyObject);\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !proxyState) {\n    console.warn(\"Please use proxy object\");\n  }\n  let promise;\n  const ops = [];\n  const addListener = proxyState[2];\n  let isListenerActive = false;\n  const listener = (op) => {\n    ops.push(op);\n    if (notifyInSync) {\n      callback(ops.splice(0));\n      return;\n    }\n    if (!promise) {\n      promise = Promise.resolve().then(() => {\n        promise = void 0;\n        if (isListenerActive) {\n          callback(ops.splice(0));\n        }\n      });\n    }\n  };\n  const removeListener = addListener(listener);\n  isListenerActive = true;\n  return () => {\n    isListenerActive = false;\n    removeListener();\n  };\n}\nfunction snapshot(proxyObject) {\n  const proxyState = proxyStateMap.get(proxyObject);\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !proxyState) {\n    console.warn(\"Please use proxy object\");\n  }\n  const [target, ensureVersion] = proxyState;\n  return createSnapshot(target, ensureVersion());\n}\nfunction ref(obj) {\n  refSet.add(obj);\n  return obj;\n}\nfunction unstable_getInternalStates() {\n  return {\n    proxyStateMap,\n    refSet,\n    snapCache,\n    versionHolder,\n    proxyCache\n  };\n}\nfunction unstable_replaceInternalFunction(name, fn) {\n  switch (name) {\n    case \"objectIs\":\n      objectIs = fn(objectIs);\n      break;\n    case \"newProxy\":\n      newProxy = fn(newProxy);\n      break;\n    case \"canProxy\":\n      canProxy = fn(canProxy);\n      break;\n    case \"createSnapshot\":\n      createSnapshot = fn(createSnapshot);\n      break;\n    case \"createHandler\":\n      createHandler = fn(createHandler);\n      break;\n    default:\n      throw new Error(\"unknown function\");\n  }\n}\n\nexport { getVersion, proxy, ref, snapshot, subscribe, unstable_getInternalStates, unstable_replaceInternalFunction };\n"],"names":[],"sourceRoot":""}