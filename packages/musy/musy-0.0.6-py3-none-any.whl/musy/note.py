"""Basic atomic building block for music"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_note.ipynb.

# %% auto 0
__all__ = ['BASE_NOTES', 'CHROMATIC_NOTES', 'INTERVALS', 'NOTE_MAPPING', 'STEPS_TO_INTERVAL', 'STEPS_TO_INTERVAL_FULL',
           'INTERVAL_TYPES', 'Note', 'Interval']

# %% ../nbs/00_note.ipynb 3
import io
import numpy as np
from fastcore.all import *
import scipy.io.wavfile as wav
from IPython.display import Audio

# %% ../nbs/00_note.ipynb 4
BASE_NOTES = ["C", "D", "E", "F", "G", "A", "B"]
CHROMATIC_NOTES = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"]
INTERVALS = ["1", "b2", "2", "b3", "3", "4", "#4", "5", "b6", "6", "b7", "7"]
NOTE_MAPPING = {
    "C": 0,
    "B#": 0,
    "Dbb": 0,
    "C#": 1,
    "Db": 1,
    "B##": 1,
    "C##": 2,
    "D": 2,
    "Ebb": 2,
    "D#": 3,
    "Eb": 3,
    "Fbb": 3,
    "E": 4,
    "Fb": 4,
    "D##": 4,
    "E#": 5,
    "F": 5,
    "Gbb": 5,
    "F#": 6,
    "Gb": 6,
    "E##": 6,
    "G": 7,
    "F##": 7,
    "Abb": 7,
    "G#": 8,
    "Ab": 8,
    "A": 9,
    "Bbb": 9,
    "G##": 9,
    "A#": 10,
    "Bb": 10,
    "Cbb": 10,
    "B": 11,
    "Cb": 11,
    "A##": 11,
}
STEPS_TO_INTERVAL = {
    0: "1",
    1: "b2",
    2: "2",
    3: "b3",
    4: "3",
    5: "4",
    6: "b5",
    7: "5",
    8: "b6",
    9: "6",
    10: "b7",
    11: "7",
}

STEPS_TO_INTERVAL_FULL = {
    0: "unison",
    1: "minor second",
    2: "major second",
    3: "minor third",
    4: "major third",
    5: "perfect fourth",
    6: "tritone",
    7: "perfect fifth",
    8: "minor sixth",
    9: "major sixth",
    10: "minor seventh",
    11: "major seventh",
}
INTERVAL_TYPES = {
    0: "Perfect Consonant", # Unison
    1: "Sharp Dissonant", # Minor Second
    2: "Mild Dissonant", # Major Second
    3: "Soft Consonant", # Minor Third
    4: "Soft Consonant", # Major Third
    5: "Contextual", # Perfect Fourth
    6: "Neutral", # Tritone/Augmented Fourth/Diminished Fifth
    7: "Perfect Consonant", # Perfect Fifth
    8: "Soft Consonant", # Minor Sixth
    9: "Soft Consonant", # Major Sixth
    10: "Mild Dissonant", # Minor Seventh
    11: "Sharp Dissonant", # Major Seventh
}

# %% ../nbs/00_note.ipynb 7
class Note(BasicRepr):
    def __init__(self, note: str, oct: int = 4):
        assert isinstance(oct, int) and oct > 0, f"Octave must be a positive integer, got oct={oct}."
        store_attr()
        # Transform note to uppercase
        if isinstance(note, str):
            note = note[0].upper() + note[1:]
            assert note in NOTE_MAPPING, f"Note '{note}' is not valid"
            self.note = note

        self.flat = "b" in self.note
        self.sharp = "#" in self.note
        self.accidental = self.flat or self.sharp
        self.natural = not self.flat and not self.sharp
        self.double_flat = "bb" in self.note
        self.double_sharp = "##" in self.note
        self.double_accidental = self.double_flat or self.double_sharp
        self.num_flats = self.note.count("b")
        self.num_sharps = self.note.count("#")
    
    def __index__(self): return self.oct * 12 + int(self) # MIDI Note number
    @property
    def midi(self): return self.__index__()
    def __str__(self): return self.note
    def __int__(self): return NOTE_MAPPING[str(self)]
    def __eq__(self, other): return self.__index__() == other.__index__()
    def __ne__(self, other): return self.__index__() != other.__index__()
    def __lt__(self, other): return self.__index__() < other.__index__()
    def __le__(self, other): return self.__index__() <= other.__index__()
    def __gt__(self, other): return self.__index__() > other.__index__()
    def __ge__(self, other): return self.__index__() >= other.__index__()

    def __repr__(self): return f"{self.note}{self.oct}"

# %% ../nbs/00_note.ipynb 33
@patch
def __add__(self:Note, other):
    """Add n semitones to a note."""
    octave_change = (other + int(self)) // 12
    return Note(CHROMATIC_NOTES[(int(self) + other) % 12], oct=self.oct + octave_change)

# %% ../nbs/00_note.ipynb 40
@patch
def __mod__(self:Note, other):
    """Add n whole notes."""
    return self + other * 2

# %% ../nbs/00_note.ipynb 45
@patch
def __sub__(self:Note, other):
    """Subtract n semitones from a note."""
    octave_change = (other + int(self)) // 12
    return Note(CHROMATIC_NOTES[(int(self) - other) % 12], oct=self.oct - octave_change)

# %% ../nbs/00_note.ipynb 50
@patch
def __floordiv__(self:Note, other):
    """Subtract n whole notes"""
    return self - other * 2

# %% ../nbs/00_note.ipynb 56
@patch
def minor(self:Note): return self - 3

# %% ../nbs/00_note.ipynb 59
@patch
def major(self:Note): return self + 3

# %% ../nbs/00_note.ipynb 63
@patch 
def get_audio_array(self:Note, length=1, sr=44100):
    t = np.linspace(0, length, int(sr * length), False)
    def freq(n): return 440 * 2**((12 * (int(n[-1])+1) + NOTE_MAPPING[n[:-1]] - 69)/12)
    wave = np.sin(2 * np.pi * freq(f"{self.note}{self.oct}") * t)
    wave = (wave / np.max(np.abs(wave)) * 32767).astype(np.int16)
    return wave

@patch
def get_audio_bytes(self:Note, length=1, sr=44100):
    buf = io.BytesIO(); wav.write(buf, sr, self.get_audio_array(length, sr))
    return buf.getvalue()

# %% ../nbs/00_note.ipynb 66
@patch
def play(self:Note, length=1): return Audio(data=self.get_audio_bytes(length))

# %% ../nbs/00_note.ipynb 75
class Interval:
    def __init__(self, note1: Note, note2: Note):
        store_attr()
        self.notes = [note1, note2]
        self.semitones = self.set_semitones()
    
    @property
    def short(self): return STEPS_TO_INTERVAL[abs(self.semitones)]
    @property
    def long(self): return STEPS_TO_INTERVAL_FULL[abs(self.semitones)]

    def set_semitones(self):
        # TODO Add upper extensions to semitone calculation and interval names (2+ octaves)
        return (12 + int(self.note2) - int(self.note1) + (self.note2.oct - self.note1.oct) * 12) % 12
    
    @classmethod
    def from_semitones(cls, semitones: int):
        return cls(Note("C"), Note("C")+semitones)

    def __repr__(self): return f"{str(self.long)} ({str(self.short)})"
    def __eq__(self, other): return self.semitones == other.semitones
    def __ne__(self, other): return not self.semitones == other.semitones
    def __lt__(self, other): return self.semitones < other.semitones
    def __le__(self, other): return self.semitones <= other.semitones
    def __gt__(self, other): return self.semitones > other.semitones
    def __ge__(self, other): return self.semitones >= other.semitones
    def __abs__(self): 
        c = Interval(self.note1, self.note2)
        c.semitones = abs(c.semitones)
        return c

# %% ../nbs/00_note.ipynb 77
@patch
def interval(self:Note, other:Note): return Interval(self, other)

@patch
def __and__(self:Note, other:Note): return self.interval(other)

# %% ../nbs/00_note.ipynb 96
@patch
def type(self:Interval): return INTERVAL_TYPES[abs(self.semitones) % 12]

@patch
def is_consonant(self:Interval): return "Consonant" in self.type()
@patch
def is_dissonant(self:Interval): return "Dissonant" in self.type()
@patch
def is_perfect(self:Interval): return "Perfect" in self.type()
@patch 
def is_contextual(self:Interval): return "Contextual" in self.type()

# %% ../nbs/00_note.ipynb 107
@patch
def __add__(self:Interval, other):
    return Interval(self.note1, self.note2+other)

@patch 
def __sub__(self:Interval, other):
    return Interval(self.note1, self.note2-other)
